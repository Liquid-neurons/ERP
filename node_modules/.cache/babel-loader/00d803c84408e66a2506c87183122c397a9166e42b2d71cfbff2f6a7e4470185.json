{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar PDFPage_1 = tslib_1.__importDefault(require(\"../PDFPage\"));\nvar PDFFont_1 = tslib_1.__importDefault(require(\"../PDFFont\"));\nvar PDFField_1 = tslib_1.__importStar(require(\"./PDFField\"));\nvar appearances_1 = require(\"./appearances\");\nvar colors_1 = require(\"../colors\");\nvar rotations_1 = require(\"../rotations\");\nvar errors_1 = require(\"../errors\");\nvar alignment_1 = require(\"../image/alignment\");\nvar alignment_2 = require(\"../text/alignment\");\nvar core_1 = require(\"../../core\");\nvar utils_1 = require(\"../../utils\");\n/**\n * Represents a text field of a [[PDFForm]].\n *\n * [[PDFTextField]] fields are boxes that display text entered by the user. The\n * purpose of a text field is to enable users to enter text or view text values\n * in the document prefilled by software. Users can click on a text field and\n * input text via their keyboard. Some text fields allow multiple lines of text\n * to be entered (see [[PDFTextField.isMultiline]]).\n */\nvar PDFTextField = /** @class */function (_super) {\n  tslib_1.__extends(PDFTextField, _super);\n  function PDFTextField(acroText, ref, doc) {\n    var _this = _super.call(this, acroText, ref, doc) || this;\n    utils_1.assertIs(acroText, 'acroText', [[core_1.PDFAcroText, 'PDFAcroText']]);\n    _this.acroField = acroText;\n    return _this;\n  }\n  /**\n   * Get the text that this field contains. This text is visible to users who\n   * view this field in a PDF reader.\n   *\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * const text = textField.getText()\n   * console.log('Text field contents:', text)\n   * ```\n   *\n   * Note that if this text field contains no underlying value, `undefined`\n   * will be returned. Text fields may also contain an underlying value that\n   * is simply an empty string (`''`). This detail is largely irrelevant for\n   * most applications. In general, you'll want to treat both cases the same\n   * way and simply consider the text field to be empty. In either case, the\n   * text field will appear empty to users when viewed in a PDF reader.\n   *\n   * An error will be thrown if this is a rich text field. `pdf-lib` does not\n   * support reading rich text fields. Nor do most PDF readers and writers.\n   * Rich text fields are based on XFA (XML Forms Architecture). Relatively few\n   * PDFs use rich text fields or XFA. Unlike PDF itself, XFA is not an ISO\n   * standard. XFA has been deprecated in PDF 2.0:\n   * * https://en.wikipedia.org/wiki/XFA\n   * * http://blog.pdfshareforms.com/pdf-2-0-release-bid-farewell-xfa-forms/\n   *\n   * @returns The text contained in this text field.\n   */\n  PDFTextField.prototype.getText = function () {\n    var value = this.acroField.getValue();\n    if (!value && this.isRichFormatted()) {\n      throw new errors_1.RichTextFieldReadError(this.getName());\n    }\n    return value === null || value === void 0 ? void 0 : value.decodeText();\n  };\n  /**\n   * Set the text for this field. This operation is analogous to a human user\n   * clicking on the text field in a PDF reader and typing in text via their\n   * keyboard. This method will update the underlying state of the text field\n   * to indicate what text has been set. PDF libraries and readers will be able\n   * to extract these values from the saved document and determine what text\n   * was set.\n   *\n   * For example:\n   * ```js\n   * const textField = form.getTextField('best.superhero.text.field')\n   * textField.setText('One Punch Man')\n   * ```\n   *\n   * This method will mark this text field as dirty, causing its appearance\n   * streams to be updated when either [[PDFDocument.save]] or\n   * [[PDFForm.updateFieldAppearances]] is called. The updated streams will\n   * display the text this field contains inside the widgets of this text\n   * field.\n   *\n   * **IMPORTANT:** The default font used to update appearance streams is\n   * [[StandardFonts.Helvetica]]. Note that this is a WinAnsi font. This means\n   * that encoding errors will be thrown if this field contains text outside\n   * the WinAnsi character set (the latin alphabet).\n   *\n   * Embedding a custom font and passing it to\n   * [[PDFForm.updateFieldAppearances]] or [[PDFTextField.updateAppearances]]\n   * allows you to generate appearance streams with characters outside the\n   * latin alphabet (assuming the custom font supports them).\n   *\n   * If this is a rich text field, it will be converted to a standard text\n   * field in order to set the text. `pdf-lib` does not support writing rich\n   * text strings. Nor do most PDF readers and writers. See\n   * [[PDFTextField.getText]] for more information about rich text fields and\n   * their deprecation in PDF 2.0.\n   *\n   * @param text The text this field should contain.\n   */\n  PDFTextField.prototype.setText = function (text) {\n    utils_1.assertOrUndefined(text, 'text', ['string']);\n    var maxLength = this.getMaxLength();\n    if (maxLength !== undefined && text && text.length > maxLength) {\n      throw new errors_1.ExceededMaxLengthError(text.length, maxLength, this.getName());\n    }\n    this.markAsDirty();\n    this.disableRichFormatting();\n    if (text) {\n      this.acroField.setValue(core_1.PDFHexString.fromText(text));\n    } else {\n      this.acroField.removeValue();\n    }\n  };\n  /**\n   * Get the alignment for this text field. This value represents the\n   * justification of the text when it is displayed to the user in PDF readers.\n   * There are three possible alignments: left, center, and right. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * const alignment = textField.getAlignment()\n   * if (alignment === TextAlignment.Left) console.log('Text is left justified')\n   * if (alignment === TextAlignment.Center) console.log('Text is centered')\n   * if (alignment === TextAlignment.Right) console.log('Text is right justified')\n   * ```\n   * @returns The alignment of this text field.\n   */\n  PDFTextField.prototype.getAlignment = function () {\n    var quadding = this.acroField.getQuadding();\n    // prettier-ignore\n    return quadding === 0 ? alignment_2.TextAlignment.Left : quadding === 1 ? alignment_2.TextAlignment.Center : quadding === 2 ? alignment_2.TextAlignment.Right : alignment_2.TextAlignment.Left;\n  };\n  /**\n   * Set the alignment for this text field. This will determine the\n   * justification of the text when it is displayed to the user in PDF readers.\n   * There are three possible alignments: left, center, and right. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   *\n   * // Text will be left justified when displayed\n   * textField.setAlignment(TextAlignment.Left)\n   *\n   * // Text will be centered when displayed\n   * textField.setAlignment(TextAlignment.Center)\n   *\n   * // Text will be right justified when displayed\n   * textField.setAlignment(TextAlignment.Right)\n   * ```\n   * This method will mark this text field as dirty. See\n   * [[PDFTextField.setText]] for more details about what this means.\n   * @param alignment The alignment for this text field.\n   */\n  PDFTextField.prototype.setAlignment = function (alignment) {\n    utils_1.assertIsOneOf(alignment, 'alignment', alignment_2.TextAlignment);\n    this.markAsDirty();\n    this.acroField.setQuadding(alignment);\n  };\n  /**\n   * Get the maximum length of this field. This value represents the maximum\n   * number of characters that can be typed into this field by the user. If\n   * this field does not have a maximum length, `undefined` is returned.\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * const maxLength = textField.getMaxLength()\n   * if (maxLength === undefined) console.log('No max length')\n   * else console.log(`Max length is ${maxLength}`)\n   * ```\n   * @returns The maximum number of characters allowed in this field, or\n   *          `undefined` if no limit exists.\n   */\n  PDFTextField.prototype.getMaxLength = function () {\n    return this.acroField.getMaxLength();\n  };\n  /**\n   * Set the maximum length of this field. This limits the number of characters\n   * that can be typed into this field by the user. This also limits the length\n   * of the string that can be passed to [[PDFTextField.setText]]. This limit\n   * can be removed by passing `undefined` as `maxLength`. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   *\n   * // Allow between 0 and 5 characters to be entered\n   * textField.setMaxLength(5)\n   *\n   * // Allow any number of characters to be entered\n   * textField.setMaxLength(undefined)\n   * ```\n   * This method will mark this text field as dirty. See\n   * [[PDFTextField.setText]] for more details about what this means.\n   * @param maxLength The maximum number of characters allowed in this field, or\n   *                  `undefined` to remove the limit.\n   */\n  PDFTextField.prototype.setMaxLength = function (maxLength) {\n    utils_1.assertRangeOrUndefined(maxLength, 'maxLength', 0, Number.MAX_SAFE_INTEGER);\n    this.markAsDirty();\n    if (maxLength === undefined) {\n      this.acroField.removeMaxLength();\n    } else {\n      var text = this.getText();\n      if (text && text.length > maxLength) {\n        throw new errors_1.InvalidMaxLengthError(text.length, maxLength, this.getName());\n      }\n      this.acroField.setMaxLength(maxLength);\n    }\n  };\n  /**\n   * Remove the maximum length for this text field. This allows any number of\n   * characters to be typed into this field by the user. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.removeMaxLength()\n   * ```\n   * Calling this method is equivalent to passing `undefined` to\n   * [[PDFTextField.setMaxLength]].\n   */\n  PDFTextField.prototype.removeMaxLength = function () {\n    this.markAsDirty();\n    this.acroField.removeMaxLength();\n  };\n  /**\n   * Display an image inside the bounds of this text field's widgets. For example:\n   * ```js\n   * const pngImage = await pdfDoc.embedPng(...)\n   * const textField = form.getTextField('some.text.field')\n   * textField.setImage(pngImage)\n   * ```\n   * This will update the appearances streams for each of this text field's widgets.\n   * @param image The image that should be displayed.\n   */\n  PDFTextField.prototype.setImage = function (image) {\n    var fieldAlignment = this.getAlignment();\n    // prettier-ignore\n    var alignment = fieldAlignment === alignment_2.TextAlignment.Center ? alignment_1.ImageAlignment.Center : fieldAlignment === alignment_2.TextAlignment.Right ? alignment_1.ImageAlignment.Right : alignment_1.ImageAlignment.Left;\n    var widgets = this.acroField.getWidgets();\n    for (var idx = 0, len = widgets.length; idx < len; idx++) {\n      var widget = widgets[idx];\n      var streamRef = this.createImageAppearanceStream(widget, image, alignment);\n      this.updateWidgetAppearances(widget, {\n        normal: streamRef\n      });\n    }\n    this.markAsClean();\n  };\n  /**\n   * Set the font size for this field. Larger font sizes will result in larger\n   * text being displayed when PDF readers render this text field. Font sizes\n   * may be integer or floating point numbers. Supplying a negative font size\n   * will cause this method to throw an error.\n   *\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.setFontSize(4)\n   * textField.setFontSize(15.7)\n   * ```\n   *\n   * > This method depends upon the existence of a default appearance\n   * > (`/DA`) string. If this field does not have a default appearance string,\n   * > or that string does not contain a font size (via the `Tf` operator),\n   * > then this method will throw an error.\n   *\n   * @param fontSize The font size to be used when rendering text in this field.\n   */\n  PDFTextField.prototype.setFontSize = function (fontSize) {\n    utils_1.assertPositive(fontSize, 'fontSize');\n    this.acroField.setFontSize(fontSize);\n    this.markAsDirty();\n  };\n  /**\n   * Returns `true` if each line of text is shown on a new line when this\n   * field is displayed in a PDF reader. The alternative is that all lines of\n   * text are merged onto a single line when displayed. See\n   * [[PDFTextField.enableMultiline]] and [[PDFTextField.disableMultiline]].\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isMultiline()) console.log('Multiline is enabled')\n   * ```\n   * @returns Whether or not this is a multiline text field.\n   */\n  PDFTextField.prototype.isMultiline = function () {\n    return this.acroField.hasFlag(core_1.AcroTextFlags.Multiline);\n  };\n  /**\n   * Display each line of text on a new line when this field is displayed in a\n   * PDF reader. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enableMultiline()\n   * ```\n   * This method will mark this text field as dirty. See\n   * [[PDFTextField.setText]] for more details about what this means.\n   */\n  PDFTextField.prototype.enableMultiline = function () {\n    this.markAsDirty();\n    this.acroField.setFlagTo(core_1.AcroTextFlags.Multiline, true);\n  };\n  /**\n   * Display each line of text on the same line when this field is displayed\n   * in a PDF reader. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disableMultiline()\n   * ```\n   * This method will mark this text field as dirty. See\n   * [[PDFTextField.setText]] for more details about what this means.\n   */\n  PDFTextField.prototype.disableMultiline = function () {\n    this.markAsDirty();\n    this.acroField.setFlagTo(core_1.AcroTextFlags.Multiline, false);\n  };\n  /**\n   * Returns `true` if this is a password text field. This means that the field\n   * is intended for storing a secure password. See\n   * [[PDFTextField.enablePassword]] and [[PDFTextField.disablePassword]].\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isPassword()) console.log('Password is enabled')\n   * ```\n   * @returns Whether or not this is a password text field.\n   */\n  PDFTextField.prototype.isPassword = function () {\n    return this.acroField.hasFlag(core_1.AcroTextFlags.Password);\n  };\n  /**\n   * Indicate that this text field is intended for storing a secure password.\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enablePassword()\n   * ```\n   * Values entered into password text fields should not be displayed on the\n   * screen by PDF readers. Most PDF readers will display the value as\n   * asterisks or bullets. PDF readers should never store values entered by the\n   * user into password text fields. Similarly, applications should not\n   * write data to a password text field.\n   *\n   * **Please note that this method does not cause entered values to be\n   * encrypted or secured in any way! It simply sets a flag that PDF software\n   * and readers can access to determine the _purpose_ of this field.**\n   */\n  PDFTextField.prototype.enablePassword = function () {\n    this.acroField.setFlagTo(core_1.AcroTextFlags.Password, true);\n  };\n  /**\n   * Indicate that this text field is **not** intended for storing a secure\n   * password. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disablePassword()\n   * ```\n   */\n  PDFTextField.prototype.disablePassword = function () {\n    this.acroField.setFlagTo(core_1.AcroTextFlags.Password, false);\n  };\n  /**\n   * Returns `true` if the contents of this text field represent a file path.\n   * See [[PDFTextField.enableFileSelection]] and\n   * [[PDFTextField.disableFileSelection]]. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isFileSelector()) console.log('Is a file selector')\n   * ```\n   * @returns Whether or not this field should contain file paths.\n   */\n  PDFTextField.prototype.isFileSelector = function () {\n    return this.acroField.hasFlag(core_1.AcroTextFlags.FileSelect);\n  };\n  /**\n   * Indicate that this text field is intended to store a file path. The\n   * contents of the file stored at that path should be submitted as the value\n   * of the field. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enableFileSelection()\n   * ```\n   */\n  PDFTextField.prototype.enableFileSelection = function () {\n    this.acroField.setFlagTo(core_1.AcroTextFlags.FileSelect, true);\n  };\n  /**\n   * Indicate that this text field is **not** intended to store a file path.\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disableFileSelection()\n   * ```\n   */\n  PDFTextField.prototype.disableFileSelection = function () {\n    this.acroField.setFlagTo(core_1.AcroTextFlags.FileSelect, false);\n  };\n  /**\n   * Returns `true` if the text entered in this field should be spell checked\n   * by PDF readers. See [[PDFTextField.enableSpellChecking]] and\n   * [[PDFTextField.disableSpellChecking]]. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isSpellChecked()) console.log('Spell checking is enabled')\n   * ```\n   * @returns Whether or not this field should be spell checked.\n   */\n  PDFTextField.prototype.isSpellChecked = function () {\n    return !this.acroField.hasFlag(core_1.AcroTextFlags.DoNotSpellCheck);\n  };\n  /**\n   * Allow PDF readers to spell check the text entered in this field.\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enableSpellChecking()\n   * ```\n   */\n  PDFTextField.prototype.enableSpellChecking = function () {\n    this.acroField.setFlagTo(core_1.AcroTextFlags.DoNotSpellCheck, false);\n  };\n  /**\n   * Do not allow PDF readers to spell check the text entered in this field.\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disableSpellChecking()\n   * ```\n   */\n  PDFTextField.prototype.disableSpellChecking = function () {\n    this.acroField.setFlagTo(core_1.AcroTextFlags.DoNotSpellCheck, true);\n  };\n  /**\n   * Returns `true` if PDF readers should allow the user to scroll the text\n   * field when its contents do not fit within the field's view bounds. See\n   * [[PDFTextField.enableScrolling]] and [[PDFTextField.disableScrolling]].\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isScrollable()) console.log('Scrolling is enabled')\n   * ```\n   * @returns Whether or not the field is scrollable in PDF readers.\n   */\n  PDFTextField.prototype.isScrollable = function () {\n    return !this.acroField.hasFlag(core_1.AcroTextFlags.DoNotScroll);\n  };\n  /**\n   * Allow PDF readers to present a scroll bar to the user when the contents\n   * of this text field do not fit within its view bounds. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enableScrolling()\n   * ```\n   * A horizontal scroll bar should be shown for singleline fields. A vertical\n   * scroll bar should be shown for multiline fields.\n   */\n  PDFTextField.prototype.enableScrolling = function () {\n    this.acroField.setFlagTo(core_1.AcroTextFlags.DoNotScroll, false);\n  };\n  /**\n   * Do not allow PDF readers to present a scroll bar to the user when the\n   * contents of this text field do not fit within its view bounds. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disableScrolling()\n   * ```\n   */\n  PDFTextField.prototype.disableScrolling = function () {\n    this.acroField.setFlagTo(core_1.AcroTextFlags.DoNotScroll, true);\n  };\n  /**\n   * Returns `true` if this is a combed text field. This means that the field\n   * is split into `n` equal size cells with one character in each (where `n`\n   * is equal to the max length of the text field). The result is that all\n   * characters in this field are displayed an equal distance apart from one\n   * another. See [[PDFTextField.enableCombing]] and\n   * [[PDFTextField.disableCombing]]. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isCombed()) console.log('Combing is enabled')\n   * ```\n   * Note that in order for a text field to be combed, the following must be\n   * true (in addition to enabling combing):\n   * * It must not be a multiline field (see [[PDFTextField.isMultiline]])\n   * * It must not be a password field (see [[PDFTextField.isPassword]])\n   * * It must not be a file selector field (see [[PDFTextField.isFileSelector]])\n   * * It must have a max length defined (see [[PDFTextField.setMaxLength]])\n   * @returns Whether or not this field is combed.\n   */\n  PDFTextField.prototype.isCombed = function () {\n    return this.acroField.hasFlag(core_1.AcroTextFlags.Comb) && !this.isMultiline() && !this.isPassword() && !this.isFileSelector() && this.getMaxLength() !== undefined;\n  };\n  /**\n   * Split this field into `n` equal size cells with one character in each\n   * (where `n` is equal to the max length of the text field). This will cause\n   * all characters in the field to be displayed an equal distance apart from\n   * one another. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enableCombing()\n   * ```\n   *\n   * In addition to calling this method, text fields must have a max length\n   * defined in order to be combed (see [[PDFTextField.setMaxLength]]).\n   *\n   * This method will also call the following three methods internally:\n   * * [[PDFTextField.disableMultiline]]\n   * * [[PDFTextField.disablePassword]]\n   * * [[PDFTextField.disableFileSelection]]\n   *\n   * This method will mark this text field as dirty. See\n   * [[PDFTextField.setText]] for more details about what this means.\n   */\n  PDFTextField.prototype.enableCombing = function () {\n    if (this.getMaxLength() === undefined) {\n      var msg = \"PDFTextFields must have a max length in order to be combed\";\n      console.warn(msg);\n    }\n    this.markAsDirty();\n    this.disableMultiline();\n    this.disablePassword();\n    this.disableFileSelection();\n    this.acroField.setFlagTo(core_1.AcroTextFlags.Comb, true);\n  };\n  /**\n   * Turn off combing for this text field. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disableCombing()\n   * ```\n   * See [[PDFTextField.isCombed]] and [[PDFTextField.enableCombing]] for more\n   * information about what combing is.\n   *\n   * This method will mark this text field as dirty. See\n   * [[PDFTextField.setText]] for more details about what this means.\n   */\n  PDFTextField.prototype.disableCombing = function () {\n    this.markAsDirty();\n    this.acroField.setFlagTo(core_1.AcroTextFlags.Comb, false);\n  };\n  /**\n   * Returns `true` if this text field contains rich text. See\n   * [[PDFTextField.enableRichFormatting]] and\n   * [[PDFTextField.disableRichFormatting]]. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isRichFormatted()) console.log('Rich formatting enabled')\n   * ```\n   * @returns Whether or not this field contains rich text.\n   */\n  PDFTextField.prototype.isRichFormatted = function () {\n    return this.acroField.hasFlag(core_1.AcroTextFlags.RichText);\n  };\n  /**\n   * Indicate that this field contains XFA data - or rich text. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enableRichFormatting()\n   * ```\n   * Note that `pdf-lib` does not support reading or writing rich text fields.\n   * Nor do most PDF readers and writers. Rich text fields are based on XFA\n   * (XML Forms Architecture). Relatively few PDFs use rich text fields or XFA.\n   * Unlike PDF itself, XFA is not an ISO standard. XFA has been deprecated in\n   * PDF 2.0:\n   * * https://en.wikipedia.org/wiki/XFA\n   * * http://blog.pdfshareforms.com/pdf-2-0-release-bid-farewell-xfa-forms/\n   */\n  PDFTextField.prototype.enableRichFormatting = function () {\n    this.acroField.setFlagTo(core_1.AcroTextFlags.RichText, true);\n  };\n  /**\n   * Indicate that this is a standard text field that does not XFA data (rich\n   * text). For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disableRichFormatting()\n   * ```\n   */\n  PDFTextField.prototype.disableRichFormatting = function () {\n    this.acroField.setFlagTo(core_1.AcroTextFlags.RichText, false);\n  };\n  /**\n   * Show this text field on the specified page. For example:\n   * ```js\n   * const ubuntuFont = await pdfDoc.embedFont(ubuntuFontBytes)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const textField = form.createTextField('best.gundam')\n   * textField.setText('Exia')\n   *\n   * textField.addToPage(page, {\n   *   x: 50,\n   *   y: 75,\n   *   width: 200,\n   *   height: 100,\n   *   textColor: rgb(1, 0, 0),\n   *   backgroundColor: rgb(0, 1, 0),\n   *   borderColor: rgb(0, 0, 1),\n   *   borderWidth: 2,\n   *   rotate: degrees(90),\n   *   font: ubuntuFont,\n   * })\n   * ```\n   * This will create a new widget for this text field.\n   * @param page The page to which this text field widget should be added.\n   * @param options The options to be used when adding this text field widget.\n   */\n  PDFTextField.prototype.addToPage = function (page, options) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    utils_1.assertIs(page, 'page', [[PDFPage_1.default, 'PDFPage']]);\n    PDFField_1.assertFieldAppearanceOptions(options);\n    if (!options) options = {};\n    if (!('textColor' in options)) options.textColor = colors_1.rgb(0, 0, 0);\n    if (!('backgroundColor' in options)) options.backgroundColor = colors_1.rgb(1, 1, 1);\n    if (!('borderColor' in options)) options.borderColor = colors_1.rgb(0, 0, 0);\n    if (!('borderWidth' in options)) options.borderWidth = 1;\n    // Create a widget for this text field\n    var widget = this.createWidget({\n      x: (_a = options.x) !== null && _a !== void 0 ? _a : 0,\n      y: (_b = options.y) !== null && _b !== void 0 ? _b : 0,\n      width: (_c = options.width) !== null && _c !== void 0 ? _c : 200,\n      height: (_d = options.height) !== null && _d !== void 0 ? _d : 50,\n      textColor: options.textColor,\n      backgroundColor: options.backgroundColor,\n      borderColor: options.borderColor,\n      borderWidth: (_e = options.borderWidth) !== null && _e !== void 0 ? _e : 0,\n      rotate: (_f = options.rotate) !== null && _f !== void 0 ? _f : rotations_1.degrees(0),\n      hidden: options.hidden,\n      page: page.ref\n    });\n    var widgetRef = this.doc.context.register(widget.dict);\n    // Add widget to this field\n    this.acroField.addWidget(widgetRef);\n    // Set appearance streams for widget\n    var font = (_g = options.font) !== null && _g !== void 0 ? _g : this.doc.getForm().getDefaultFont();\n    this.updateWidgetAppearance(widget, font);\n    // Add widget to the given page\n    page.node.addAnnot(widgetRef);\n  };\n  /**\n   * Returns `true` if this text field has been marked as dirty, or if any of\n   * this text field's widgets do not have an appearance stream. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.needsAppearancesUpdate()) console.log('Needs update')\n   * ```\n   * @returns Whether or not this text field needs an appearance update.\n   */\n  PDFTextField.prototype.needsAppearancesUpdate = function () {\n    var _a;\n    if (this.isDirty()) return true;\n    var widgets = this.acroField.getWidgets();\n    for (var idx = 0, len = widgets.length; idx < len; idx++) {\n      var widget = widgets[idx];\n      var hasAppearances = ((_a = widget.getAppearances()) === null || _a === void 0 ? void 0 : _a.normal) instanceof core_1.PDFStream;\n      if (!hasAppearances) return true;\n    }\n    return false;\n  };\n  /**\n   * Update the appearance streams for each of this text field's widgets using\n   * the default appearance provider for text fields. For example:\n   * ```js\n   * const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const textField = form.getTextField('some.text.field')\n   * textField.defaultUpdateAppearances(helvetica)\n   * ```\n   * @param font The font to be used for creating the appearance streams.\n   */\n  PDFTextField.prototype.defaultUpdateAppearances = function (font) {\n    utils_1.assertIs(font, 'font', [[PDFFont_1.default, 'PDFFont']]);\n    this.updateAppearances(font);\n  };\n  /**\n   * Update the appearance streams for each of this text field's widgets using\n   * the given appearance provider. If no `provider` is passed, the default\n   * appearance provider for text fields will be used. For example:\n   * ```js\n   * const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const textField = form.getTextField('some.text.field')\n   * textField.updateAppearances(helvetica, (field, widget, font) => {\n   *   ...\n   *   return drawTextField(...)\n   * })\n   * ```\n   * @param font The font to be used for creating the appearance streams.\n   * @param provider Optionally, the appearance provider to be used for\n   *                 generating the contents of the appearance streams.\n   */\n  PDFTextField.prototype.updateAppearances = function (font, provider) {\n    utils_1.assertIs(font, 'font', [[PDFFont_1.default, 'PDFFont']]);\n    utils_1.assertOrUndefined(provider, 'provider', [Function]);\n    var widgets = this.acroField.getWidgets();\n    for (var idx = 0, len = widgets.length; idx < len; idx++) {\n      var widget = widgets[idx];\n      this.updateWidgetAppearance(widget, font, provider);\n    }\n    this.markAsClean();\n  };\n  PDFTextField.prototype.updateWidgetAppearance = function (widget, font, provider) {\n    var apProvider = provider !== null && provider !== void 0 ? provider : appearances_1.defaultTextFieldAppearanceProvider;\n    var appearances = appearances_1.normalizeAppearance(apProvider(this, widget, font));\n    this.updateWidgetAppearanceWithFont(widget, font, appearances);\n  };\n  /**\n   * > **NOTE:** You probably don't want to call this method directly. Instead,\n   * > consider using the [[PDFForm.getTextField]] method, which will create an\n   * > instance of [[PDFTextField]] for you.\n   *\n   * Create an instance of [[PDFTextField]] from an existing acroText and ref\n   *\n   * @param acroText The underlying `PDFAcroText` for this text field.\n   * @param ref The unique reference for this text field.\n   * @param doc The document to which this text field will belong.\n   */\n  PDFTextField.of = function (acroText, ref, doc) {\n    return new PDFTextField(acroText, ref, doc);\n  };\n  return PDFTextField;\n}(PDFField_1.default);\nexports.default = PDFTextField;","map":{"version":3,"names":["PDFPage_1","tslib_1","__importDefault","require","PDFFont_1","PDFField_1","__importStar","appearances_1","colors_1","rotations_1","errors_1","alignment_1","alignment_2","core_1","utils_1","PDFTextField","_super","__extends","acroText","ref","doc","_this","call","assertIs","PDFAcroText","acroField","prototype","getText","value","getValue","isRichFormatted","RichTextFieldReadError","getName","decodeText","setText","text","assertOrUndefined","maxLength","getMaxLength","undefined","length","ExceededMaxLengthError","markAsDirty","disableRichFormatting","setValue","PDFHexString","fromText","removeValue","getAlignment","quadding","getQuadding","TextAlignment","Left","Center","Right","setAlignment","alignment","assertIsOneOf","setQuadding","setMaxLength","assertRangeOrUndefined","Number","MAX_SAFE_INTEGER","removeMaxLength","InvalidMaxLengthError","setImage","image","fieldAlignment","ImageAlignment","widgets","getWidgets","idx","len","widget","streamRef","createImageAppearanceStream","updateWidgetAppearances","normal","markAsClean","setFontSize","fontSize","assertPositive","isMultiline","hasFlag","AcroTextFlags","Multiline","enableMultiline","setFlagTo","disableMultiline","isPassword","Password","enablePassword","disablePassword","isFileSelector","FileSelect","enableFileSelection","disableFileSelection","isSpellChecked","DoNotSpellCheck","enableSpellChecking","disableSpellChecking","isScrollable","DoNotScroll","enableScrolling","disableScrolling","isCombed","Comb","enableCombing","msg","console","warn","disableCombing","RichText","enableRichFormatting","addToPage","page","options","default","assertFieldAppearanceOptions","textColor","rgb","backgroundColor","borderColor","borderWidth","createWidget","x","_a","y","_b","width","_c","height","_d","_e","rotate","_f","degrees","hidden","widgetRef","context","register","dict","addWidget","font","_g","getForm","getDefaultFont","updateWidgetAppearance","node","addAnnot","needsAppearancesUpdate","isDirty","hasAppearances","getAppearances","PDFStream","defaultUpdateAppearances","updateAppearances","provider","Function","apProvider","defaultTextFieldAppearanceProvider","appearances","normalizeAppearance","updateWidgetAppearanceWithFont","of"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/api/form/PDFTextField.ts"],"sourcesContent":["import PDFDocument from 'src/api/PDFDocument';\nimport PDFPage from 'src/api/PDFPage';\nimport PDFFont from 'src/api/PDFFont';\nimport PDFImage from 'src/api/PDFImage';\nimport PDFField, {\n  FieldAppearanceOptions,\n  assertFieldAppearanceOptions,\n} from 'src/api/form/PDFField';\nimport {\n  AppearanceProviderFor,\n  normalizeAppearance,\n  defaultTextFieldAppearanceProvider,\n} from 'src/api/form/appearances';\nimport { rgb } from 'src/api/colors';\nimport { degrees } from 'src/api/rotations';\nimport {\n  RichTextFieldReadError,\n  ExceededMaxLengthError,\n  InvalidMaxLengthError,\n} from 'src/api/errors';\nimport { ImageAlignment } from 'src/api/image/alignment';\nimport { TextAlignment } from 'src/api/text/alignment';\n\nimport {\n  PDFHexString,\n  PDFRef,\n  PDFStream,\n  PDFAcroText,\n  AcroTextFlags,\n  PDFWidgetAnnotation,\n} from 'src/core';\nimport {\n  assertIs,\n  assertIsOneOf,\n  assertOrUndefined,\n  assertPositive,\n  assertRangeOrUndefined,\n} from 'src/utils';\n\n/**\n * Represents a text field of a [[PDFForm]].\n *\n * [[PDFTextField]] fields are boxes that display text entered by the user. The\n * purpose of a text field is to enable users to enter text or view text values\n * in the document prefilled by software. Users can click on a text field and\n * input text via their keyboard. Some text fields allow multiple lines of text\n * to be entered (see [[PDFTextField.isMultiline]]).\n */\nexport default class PDFTextField extends PDFField {\n  /**\n   * > **NOTE:** You probably don't want to call this method directly. Instead,\n   * > consider using the [[PDFForm.getTextField]] method, which will create an\n   * > instance of [[PDFTextField]] for you.\n   *\n   * Create an instance of [[PDFTextField]] from an existing acroText and ref\n   *\n   * @param acroText The underlying `PDFAcroText` for this text field.\n   * @param ref The unique reference for this text field.\n   * @param doc The document to which this text field will belong.\n   */\n  static of = (acroText: PDFAcroText, ref: PDFRef, doc: PDFDocument) =>\n    new PDFTextField(acroText, ref, doc);\n\n  /** The low-level PDFAcroText wrapped by this text field. */\n  readonly acroField: PDFAcroText;\n\n  private constructor(acroText: PDFAcroText, ref: PDFRef, doc: PDFDocument) {\n    super(acroText, ref, doc);\n\n    assertIs(acroText, 'acroText', [[PDFAcroText, 'PDFAcroText']]);\n\n    this.acroField = acroText;\n  }\n\n  /**\n   * Get the text that this field contains. This text is visible to users who\n   * view this field in a PDF reader.\n   *\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * const text = textField.getText()\n   * console.log('Text field contents:', text)\n   * ```\n   *\n   * Note that if this text field contains no underlying value, `undefined`\n   * will be returned. Text fields may also contain an underlying value that\n   * is simply an empty string (`''`). This detail is largely irrelevant for\n   * most applications. In general, you'll want to treat both cases the same\n   * way and simply consider the text field to be empty. In either case, the\n   * text field will appear empty to users when viewed in a PDF reader.\n   *\n   * An error will be thrown if this is a rich text field. `pdf-lib` does not\n   * support reading rich text fields. Nor do most PDF readers and writers.\n   * Rich text fields are based on XFA (XML Forms Architecture). Relatively few\n   * PDFs use rich text fields or XFA. Unlike PDF itself, XFA is not an ISO\n   * standard. XFA has been deprecated in PDF 2.0:\n   * * https://en.wikipedia.org/wiki/XFA\n   * * http://blog.pdfshareforms.com/pdf-2-0-release-bid-farewell-xfa-forms/\n   *\n   * @returns The text contained in this text field.\n   */\n  getText(): string | undefined {\n    const value = this.acroField.getValue();\n    if (!value && this.isRichFormatted()) {\n      throw new RichTextFieldReadError(this.getName());\n    }\n    return value?.decodeText();\n  }\n\n  /**\n   * Set the text for this field. This operation is analogous to a human user\n   * clicking on the text field in a PDF reader and typing in text via their\n   * keyboard. This method will update the underlying state of the text field\n   * to indicate what text has been set. PDF libraries and readers will be able\n   * to extract these values from the saved document and determine what text\n   * was set.\n   *\n   * For example:\n   * ```js\n   * const textField = form.getTextField('best.superhero.text.field')\n   * textField.setText('One Punch Man')\n   * ```\n   *\n   * This method will mark this text field as dirty, causing its appearance\n   * streams to be updated when either [[PDFDocument.save]] or\n   * [[PDFForm.updateFieldAppearances]] is called. The updated streams will\n   * display the text this field contains inside the widgets of this text\n   * field.\n   *\n   * **IMPORTANT:** The default font used to update appearance streams is\n   * [[StandardFonts.Helvetica]]. Note that this is a WinAnsi font. This means\n   * that encoding errors will be thrown if this field contains text outside\n   * the WinAnsi character set (the latin alphabet).\n   *\n   * Embedding a custom font and passing it to\n   * [[PDFForm.updateFieldAppearances]] or [[PDFTextField.updateAppearances]]\n   * allows you to generate appearance streams with characters outside the\n   * latin alphabet (assuming the custom font supports them).\n   *\n   * If this is a rich text field, it will be converted to a standard text\n   * field in order to set the text. `pdf-lib` does not support writing rich\n   * text strings. Nor do most PDF readers and writers. See\n   * [[PDFTextField.getText]] for more information about rich text fields and\n   * their deprecation in PDF 2.0.\n   *\n   * @param text The text this field should contain.\n   */\n  setText(text: string | undefined) {\n    assertOrUndefined(text, 'text', ['string']);\n\n    const maxLength = this.getMaxLength();\n    if (maxLength !== undefined && text && text.length > maxLength) {\n      throw new ExceededMaxLengthError(text.length, maxLength, this.getName());\n    }\n\n    this.markAsDirty();\n    this.disableRichFormatting();\n\n    if (text) {\n      this.acroField.setValue(PDFHexString.fromText(text));\n    } else {\n      this.acroField.removeValue();\n    }\n  }\n\n  /**\n   * Get the alignment for this text field. This value represents the\n   * justification of the text when it is displayed to the user in PDF readers.\n   * There are three possible alignments: left, center, and right. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * const alignment = textField.getAlignment()\n   * if (alignment === TextAlignment.Left) console.log('Text is left justified')\n   * if (alignment === TextAlignment.Center) console.log('Text is centered')\n   * if (alignment === TextAlignment.Right) console.log('Text is right justified')\n   * ```\n   * @returns The alignment of this text field.\n   */\n  getAlignment(): TextAlignment {\n    const quadding = this.acroField.getQuadding();\n\n    // prettier-ignore\n    return (\n        quadding === 0 ? TextAlignment.Left\n      : quadding === 1 ? TextAlignment.Center\n      : quadding === 2 ? TextAlignment.Right\n      : TextAlignment.Left\n    );\n  }\n\n  /**\n   * Set the alignment for this text field. This will determine the\n   * justification of the text when it is displayed to the user in PDF readers.\n   * There are three possible alignments: left, center, and right. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   *\n   * // Text will be left justified when displayed\n   * textField.setAlignment(TextAlignment.Left)\n   *\n   * // Text will be centered when displayed\n   * textField.setAlignment(TextAlignment.Center)\n   *\n   * // Text will be right justified when displayed\n   * textField.setAlignment(TextAlignment.Right)\n   * ```\n   * This method will mark this text field as dirty. See\n   * [[PDFTextField.setText]] for more details about what this means.\n   * @param alignment The alignment for this text field.\n   */\n  setAlignment(alignment: TextAlignment) {\n    assertIsOneOf(alignment, 'alignment', TextAlignment);\n    this.markAsDirty();\n    this.acroField.setQuadding(alignment);\n  }\n\n  /**\n   * Get the maximum length of this field. This value represents the maximum\n   * number of characters that can be typed into this field by the user. If\n   * this field does not have a maximum length, `undefined` is returned.\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * const maxLength = textField.getMaxLength()\n   * if (maxLength === undefined) console.log('No max length')\n   * else console.log(`Max length is ${maxLength}`)\n   * ```\n   * @returns The maximum number of characters allowed in this field, or\n   *          `undefined` if no limit exists.\n   */\n  getMaxLength(): number | undefined {\n    return this.acroField.getMaxLength();\n  }\n\n  /**\n   * Set the maximum length of this field. This limits the number of characters\n   * that can be typed into this field by the user. This also limits the length\n   * of the string that can be passed to [[PDFTextField.setText]]. This limit\n   * can be removed by passing `undefined` as `maxLength`. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   *\n   * // Allow between 0 and 5 characters to be entered\n   * textField.setMaxLength(5)\n   *\n   * // Allow any number of characters to be entered\n   * textField.setMaxLength(undefined)\n   * ```\n   * This method will mark this text field as dirty. See\n   * [[PDFTextField.setText]] for more details about what this means.\n   * @param maxLength The maximum number of characters allowed in this field, or\n   *                  `undefined` to remove the limit.\n   */\n  setMaxLength(maxLength?: number) {\n    assertRangeOrUndefined(maxLength, 'maxLength', 0, Number.MAX_SAFE_INTEGER);\n\n    this.markAsDirty();\n\n    if (maxLength === undefined) {\n      this.acroField.removeMaxLength();\n    } else {\n      const text = this.getText();\n      if (text && text.length > maxLength) {\n        throw new InvalidMaxLengthError(text.length, maxLength, this.getName());\n      }\n      this.acroField.setMaxLength(maxLength);\n    }\n  }\n\n  /**\n   * Remove the maximum length for this text field. This allows any number of\n   * characters to be typed into this field by the user. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.removeMaxLength()\n   * ```\n   * Calling this method is equivalent to passing `undefined` to\n   * [[PDFTextField.setMaxLength]].\n   */\n  removeMaxLength() {\n    this.markAsDirty();\n    this.acroField.removeMaxLength();\n  }\n\n  /**\n   * Display an image inside the bounds of this text field's widgets. For example:\n   * ```js\n   * const pngImage = await pdfDoc.embedPng(...)\n   * const textField = form.getTextField('some.text.field')\n   * textField.setImage(pngImage)\n   * ```\n   * This will update the appearances streams for each of this text field's widgets.\n   * @param image The image that should be displayed.\n   */\n  setImage(image: PDFImage) {\n    const fieldAlignment = this.getAlignment();\n\n    // prettier-ignore\n    const alignment = \n        fieldAlignment === TextAlignment.Center ? ImageAlignment.Center\n      : fieldAlignment === TextAlignment.Right ? ImageAlignment.Right\n      : ImageAlignment.Left;\n\n    const widgets = this.acroField.getWidgets();\n    for (let idx = 0, len = widgets.length; idx < len; idx++) {\n      const widget = widgets[idx];\n      const streamRef = this.createImageAppearanceStream(\n        widget,\n        image,\n        alignment,\n      );\n      this.updateWidgetAppearances(widget, { normal: streamRef });\n    }\n\n    this.markAsClean();\n  }\n\n  /**\n   * Set the font size for this field. Larger font sizes will result in larger\n   * text being displayed when PDF readers render this text field. Font sizes\n   * may be integer or floating point numbers. Supplying a negative font size\n   * will cause this method to throw an error.\n   *\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.setFontSize(4)\n   * textField.setFontSize(15.7)\n   * ```\n   *\n   * > This method depends upon the existence of a default appearance\n   * > (`/DA`) string. If this field does not have a default appearance string,\n   * > or that string does not contain a font size (via the `Tf` operator),\n   * > then this method will throw an error.\n   *\n   * @param fontSize The font size to be used when rendering text in this field.\n   */\n  setFontSize(fontSize: number) {\n    assertPositive(fontSize, 'fontSize');\n    this.acroField.setFontSize(fontSize);\n    this.markAsDirty();\n  }\n\n  /**\n   * Returns `true` if each line of text is shown on a new line when this\n   * field is displayed in a PDF reader. The alternative is that all lines of\n   * text are merged onto a single line when displayed. See\n   * [[PDFTextField.enableMultiline]] and [[PDFTextField.disableMultiline]].\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isMultiline()) console.log('Multiline is enabled')\n   * ```\n   * @returns Whether or not this is a multiline text field.\n   */\n  isMultiline(): boolean {\n    return this.acroField.hasFlag(AcroTextFlags.Multiline);\n  }\n\n  /**\n   * Display each line of text on a new line when this field is displayed in a\n   * PDF reader. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enableMultiline()\n   * ```\n   * This method will mark this text field as dirty. See\n   * [[PDFTextField.setText]] for more details about what this means.\n   */\n  enableMultiline() {\n    this.markAsDirty();\n    this.acroField.setFlagTo(AcroTextFlags.Multiline, true);\n  }\n\n  /**\n   * Display each line of text on the same line when this field is displayed\n   * in a PDF reader. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disableMultiline()\n   * ```\n   * This method will mark this text field as dirty. See\n   * [[PDFTextField.setText]] for more details about what this means.\n   */\n  disableMultiline() {\n    this.markAsDirty();\n    this.acroField.setFlagTo(AcroTextFlags.Multiline, false);\n  }\n\n  /**\n   * Returns `true` if this is a password text field. This means that the field\n   * is intended for storing a secure password. See\n   * [[PDFTextField.enablePassword]] and [[PDFTextField.disablePassword]].\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isPassword()) console.log('Password is enabled')\n   * ```\n   * @returns Whether or not this is a password text field.\n   */\n  isPassword(): boolean {\n    return this.acroField.hasFlag(AcroTextFlags.Password);\n  }\n\n  /**\n   * Indicate that this text field is intended for storing a secure password.\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enablePassword()\n   * ```\n   * Values entered into password text fields should not be displayed on the\n   * screen by PDF readers. Most PDF readers will display the value as\n   * asterisks or bullets. PDF readers should never store values entered by the\n   * user into password text fields. Similarly, applications should not\n   * write data to a password text field.\n   *\n   * **Please note that this method does not cause entered values to be\n   * encrypted or secured in any way! It simply sets a flag that PDF software\n   * and readers can access to determine the _purpose_ of this field.**\n   */\n  enablePassword() {\n    this.acroField.setFlagTo(AcroTextFlags.Password, true);\n  }\n\n  /**\n   * Indicate that this text field is **not** intended for storing a secure\n   * password. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disablePassword()\n   * ```\n   */\n  disablePassword() {\n    this.acroField.setFlagTo(AcroTextFlags.Password, false);\n  }\n\n  /**\n   * Returns `true` if the contents of this text field represent a file path.\n   * See [[PDFTextField.enableFileSelection]] and\n   * [[PDFTextField.disableFileSelection]]. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isFileSelector()) console.log('Is a file selector')\n   * ```\n   * @returns Whether or not this field should contain file paths.\n   */\n  isFileSelector(): boolean {\n    return this.acroField.hasFlag(AcroTextFlags.FileSelect);\n  }\n\n  /**\n   * Indicate that this text field is intended to store a file path. The\n   * contents of the file stored at that path should be submitted as the value\n   * of the field. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enableFileSelection()\n   * ```\n   */\n  enableFileSelection() {\n    this.acroField.setFlagTo(AcroTextFlags.FileSelect, true);\n  }\n\n  /**\n   * Indicate that this text field is **not** intended to store a file path.\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disableFileSelection()\n   * ```\n   */\n  disableFileSelection() {\n    this.acroField.setFlagTo(AcroTextFlags.FileSelect, false);\n  }\n\n  /**\n   * Returns `true` if the text entered in this field should be spell checked\n   * by PDF readers. See [[PDFTextField.enableSpellChecking]] and\n   * [[PDFTextField.disableSpellChecking]]. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isSpellChecked()) console.log('Spell checking is enabled')\n   * ```\n   * @returns Whether or not this field should be spell checked.\n   */\n  isSpellChecked(): boolean {\n    return !this.acroField.hasFlag(AcroTextFlags.DoNotSpellCheck);\n  }\n\n  /**\n   * Allow PDF readers to spell check the text entered in this field.\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enableSpellChecking()\n   * ```\n   */\n  enableSpellChecking() {\n    this.acroField.setFlagTo(AcroTextFlags.DoNotSpellCheck, false);\n  }\n\n  /**\n   * Do not allow PDF readers to spell check the text entered in this field.\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disableSpellChecking()\n   * ```\n   */\n  disableSpellChecking() {\n    this.acroField.setFlagTo(AcroTextFlags.DoNotSpellCheck, true);\n  }\n\n  /**\n   * Returns `true` if PDF readers should allow the user to scroll the text\n   * field when its contents do not fit within the field's view bounds. See\n   * [[PDFTextField.enableScrolling]] and [[PDFTextField.disableScrolling]].\n   * For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isScrollable()) console.log('Scrolling is enabled')\n   * ```\n   * @returns Whether or not the field is scrollable in PDF readers.\n   */\n  isScrollable(): boolean {\n    return !this.acroField.hasFlag(AcroTextFlags.DoNotScroll);\n  }\n\n  /**\n   * Allow PDF readers to present a scroll bar to the user when the contents\n   * of this text field do not fit within its view bounds. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enableScrolling()\n   * ```\n   * A horizontal scroll bar should be shown for singleline fields. A vertical\n   * scroll bar should be shown for multiline fields.\n   */\n  enableScrolling() {\n    this.acroField.setFlagTo(AcroTextFlags.DoNotScroll, false);\n  }\n\n  /**\n   * Do not allow PDF readers to present a scroll bar to the user when the\n   * contents of this text field do not fit within its view bounds. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disableScrolling()\n   * ```\n   */\n  disableScrolling() {\n    this.acroField.setFlagTo(AcroTextFlags.DoNotScroll, true);\n  }\n\n  /**\n   * Returns `true` if this is a combed text field. This means that the field\n   * is split into `n` equal size cells with one character in each (where `n`\n   * is equal to the max length of the text field). The result is that all\n   * characters in this field are displayed an equal distance apart from one\n   * another. See [[PDFTextField.enableCombing]] and\n   * [[PDFTextField.disableCombing]]. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isCombed()) console.log('Combing is enabled')\n   * ```\n   * Note that in order for a text field to be combed, the following must be\n   * true (in addition to enabling combing):\n   * * It must not be a multiline field (see [[PDFTextField.isMultiline]])\n   * * It must not be a password field (see [[PDFTextField.isPassword]])\n   * * It must not be a file selector field (see [[PDFTextField.isFileSelector]])\n   * * It must have a max length defined (see [[PDFTextField.setMaxLength]])\n   * @returns Whether or not this field is combed.\n   */\n  isCombed(): boolean {\n    return (\n      this.acroField.hasFlag(AcroTextFlags.Comb) &&\n      !this.isMultiline() &&\n      !this.isPassword() &&\n      !this.isFileSelector() &&\n      this.getMaxLength() !== undefined\n    );\n  }\n\n  /**\n   * Split this field into `n` equal size cells with one character in each\n   * (where `n` is equal to the max length of the text field). This will cause\n   * all characters in the field to be displayed an equal distance apart from\n   * one another. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enableCombing()\n   * ```\n   *\n   * In addition to calling this method, text fields must have a max length\n   * defined in order to be combed (see [[PDFTextField.setMaxLength]]).\n   *\n   * This method will also call the following three methods internally:\n   * * [[PDFTextField.disableMultiline]]\n   * * [[PDFTextField.disablePassword]]\n   * * [[PDFTextField.disableFileSelection]]\n   *\n   * This method will mark this text field as dirty. See\n   * [[PDFTextField.setText]] for more details about what this means.\n   */\n  enableCombing() {\n    if (this.getMaxLength() === undefined) {\n      const msg = `PDFTextFields must have a max length in order to be combed`;\n      console.warn(msg);\n    }\n\n    this.markAsDirty();\n\n    this.disableMultiline();\n    this.disablePassword();\n    this.disableFileSelection();\n\n    this.acroField.setFlagTo(AcroTextFlags.Comb, true);\n  }\n\n  /**\n   * Turn off combing for this text field. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disableCombing()\n   * ```\n   * See [[PDFTextField.isCombed]] and [[PDFTextField.enableCombing]] for more\n   * information about what combing is.\n   *\n   * This method will mark this text field as dirty. See\n   * [[PDFTextField.setText]] for more details about what this means.\n   */\n  disableCombing() {\n    this.markAsDirty();\n    this.acroField.setFlagTo(AcroTextFlags.Comb, false);\n  }\n\n  /**\n   * Returns `true` if this text field contains rich text. See\n   * [[PDFTextField.enableRichFormatting]] and\n   * [[PDFTextField.disableRichFormatting]]. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.isRichFormatted()) console.log('Rich formatting enabled')\n   * ```\n   * @returns Whether or not this field contains rich text.\n   */\n  isRichFormatted(): boolean {\n    return this.acroField.hasFlag(AcroTextFlags.RichText);\n  }\n\n  /**\n   * Indicate that this field contains XFA data - or rich text. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.enableRichFormatting()\n   * ```\n   * Note that `pdf-lib` does not support reading or writing rich text fields.\n   * Nor do most PDF readers and writers. Rich text fields are based on XFA\n   * (XML Forms Architecture). Relatively few PDFs use rich text fields or XFA.\n   * Unlike PDF itself, XFA is not an ISO standard. XFA has been deprecated in\n   * PDF 2.0:\n   * * https://en.wikipedia.org/wiki/XFA\n   * * http://blog.pdfshareforms.com/pdf-2-0-release-bid-farewell-xfa-forms/\n   */\n  enableRichFormatting() {\n    this.acroField.setFlagTo(AcroTextFlags.RichText, true);\n  }\n\n  /**\n   * Indicate that this is a standard text field that does not XFA data (rich\n   * text). For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * textField.disableRichFormatting()\n   * ```\n   */\n  disableRichFormatting() {\n    this.acroField.setFlagTo(AcroTextFlags.RichText, false);\n  }\n\n  /**\n   * Show this text field on the specified page. For example:\n   * ```js\n   * const ubuntuFont = await pdfDoc.embedFont(ubuntuFontBytes)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const textField = form.createTextField('best.gundam')\n   * textField.setText('Exia')\n   *\n   * textField.addToPage(page, {\n   *   x: 50,\n   *   y: 75,\n   *   width: 200,\n   *   height: 100,\n   *   textColor: rgb(1, 0, 0),\n   *   backgroundColor: rgb(0, 1, 0),\n   *   borderColor: rgb(0, 0, 1),\n   *   borderWidth: 2,\n   *   rotate: degrees(90),\n   *   font: ubuntuFont,\n   * })\n   * ```\n   * This will create a new widget for this text field.\n   * @param page The page to which this text field widget should be added.\n   * @param options The options to be used when adding this text field widget.\n   */\n  addToPage(page: PDFPage, options?: FieldAppearanceOptions) {\n    assertIs(page, 'page', [[PDFPage, 'PDFPage']]);\n    assertFieldAppearanceOptions(options);\n\n    if (!options) options = {};\n\n    if (!('textColor' in options)) options.textColor = rgb(0, 0, 0);\n    if (!('backgroundColor' in options)) options.backgroundColor = rgb(1, 1, 1);\n    if (!('borderColor' in options)) options.borderColor = rgb(0, 0, 0);\n    if (!('borderWidth' in options)) options.borderWidth = 1;\n\n    // Create a widget for this text field\n    const widget = this.createWidget({\n      x: options.x ?? 0,\n      y: options.y ?? 0,\n      width: options.width ?? 200,\n      height: options.height ?? 50,\n      textColor: options.textColor,\n      backgroundColor: options.backgroundColor,\n      borderColor: options.borderColor,\n      borderWidth: options.borderWidth ?? 0,\n      rotate: options.rotate ?? degrees(0),\n      hidden: options.hidden,\n      page: page.ref,\n    });\n    const widgetRef = this.doc.context.register(widget.dict);\n\n    // Add widget to this field\n    this.acroField.addWidget(widgetRef);\n\n    // Set appearance streams for widget\n    const font = options.font ?? this.doc.getForm().getDefaultFont();\n    this.updateWidgetAppearance(widget, font);\n\n    // Add widget to the given page\n    page.node.addAnnot(widgetRef);\n  }\n\n  /**\n   * Returns `true` if this text field has been marked as dirty, or if any of\n   * this text field's widgets do not have an appearance stream. For example:\n   * ```js\n   * const textField = form.getTextField('some.text.field')\n   * if (textField.needsAppearancesUpdate()) console.log('Needs update')\n   * ```\n   * @returns Whether or not this text field needs an appearance update.\n   */\n  needsAppearancesUpdate(): boolean {\n    if (this.isDirty()) return true;\n\n    const widgets = this.acroField.getWidgets();\n    for (let idx = 0, len = widgets.length; idx < len; idx++) {\n      const widget = widgets[idx];\n      const hasAppearances =\n        widget.getAppearances()?.normal instanceof PDFStream;\n      if (!hasAppearances) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Update the appearance streams for each of this text field's widgets using\n   * the default appearance provider for text fields. For example:\n   * ```js\n   * const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const textField = form.getTextField('some.text.field')\n   * textField.defaultUpdateAppearances(helvetica)\n   * ```\n   * @param font The font to be used for creating the appearance streams.\n   */\n  defaultUpdateAppearances(font: PDFFont) {\n    assertIs(font, 'font', [[PDFFont, 'PDFFont']]);\n    this.updateAppearances(font);\n  }\n\n  /**\n   * Update the appearance streams for each of this text field's widgets using\n   * the given appearance provider. If no `provider` is passed, the default\n   * appearance provider for text fields will be used. For example:\n   * ```js\n   * const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const textField = form.getTextField('some.text.field')\n   * textField.updateAppearances(helvetica, (field, widget, font) => {\n   *   ...\n   *   return drawTextField(...)\n   * })\n   * ```\n   * @param font The font to be used for creating the appearance streams.\n   * @param provider Optionally, the appearance provider to be used for\n   *                 generating the contents of the appearance streams.\n   */\n  updateAppearances(\n    font: PDFFont,\n    provider?: AppearanceProviderFor<PDFTextField>,\n  ) {\n    assertIs(font, 'font', [[PDFFont, 'PDFFont']]);\n    assertOrUndefined(provider, 'provider', [Function]);\n\n    const widgets = this.acroField.getWidgets();\n    for (let idx = 0, len = widgets.length; idx < len; idx++) {\n      const widget = widgets[idx];\n      this.updateWidgetAppearance(widget, font, provider);\n    }\n    this.markAsClean();\n  }\n\n  private updateWidgetAppearance(\n    widget: PDFWidgetAnnotation,\n    font: PDFFont,\n    provider?: AppearanceProviderFor<PDFTextField>,\n  ) {\n    const apProvider = provider ?? defaultTextFieldAppearanceProvider;\n    const appearances = normalizeAppearance(apProvider(this, widget, font));\n    this.updateWidgetAppearanceWithFont(widget, font, appearances);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}