{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PrivateConstructorError } from \"../errors\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsIrregular } from \"../syntax/Irregular\";\nimport { charFromHexCode, copyStringIntoBuffer, toCharCode, toHexString } from \"../../utils\";\nvar decodeName = function (name) {\n  return name.replace(/#([\\dABCDEF]{2})/g, function (_, hex) {\n    return charFromHexCode(hex);\n  });\n};\nvar isRegularChar = function (charCode) {\n  return charCode >= CharCodes.ExclamationPoint && charCode <= CharCodes.Tilde && !IsIrregular[charCode];\n};\nvar ENFORCER = {};\nvar pool = new Map();\nvar PDFName = /** @class */function (_super) {\n  __extends(PDFName, _super);\n  function PDFName(enforcer, name) {\n    var _this = this;\n    if (enforcer !== ENFORCER) throw new PrivateConstructorError('PDFName');\n    _this = _super.call(this) || this;\n    var encodedName = '/';\n    for (var idx = 0, len = name.length; idx < len; idx++) {\n      var character = name[idx];\n      var code = toCharCode(character);\n      encodedName += isRegularChar(code) ? character : \"#\" + toHexString(code);\n    }\n    _this.encodedName = encodedName;\n    return _this;\n  }\n  PDFName.prototype.asBytes = function () {\n    var bytes = [];\n    var hex = '';\n    var escaped = false;\n    var pushByte = function (byte) {\n      if (byte !== undefined) bytes.push(byte);\n      escaped = false;\n    };\n    for (var idx = 1, len = this.encodedName.length; idx < len; idx++) {\n      var char = this.encodedName[idx];\n      var byte = toCharCode(char);\n      var nextChar = this.encodedName[idx + 1];\n      if (!escaped) {\n        if (byte === CharCodes.Hash) escaped = true;else pushByte(byte);\n      } else {\n        if (byte >= CharCodes.Zero && byte <= CharCodes.Nine || byte >= CharCodes.a && byte <= CharCodes.f || byte >= CharCodes.A && byte <= CharCodes.F) {\n          hex += char;\n          if (hex.length === 2 || !(nextChar >= '0' && nextChar <= '9' || nextChar >= 'a' && nextChar <= 'f' || nextChar >= 'A' && nextChar <= 'F')) {\n            pushByte(parseInt(hex, 16));\n            hex = '';\n          }\n        } else {\n          pushByte(byte);\n        }\n      }\n    }\n    return new Uint8Array(bytes);\n  };\n  // TODO: This should probably use `utf8Decode()`\n  // TODO: Polyfill Array.from?\n  PDFName.prototype.decodeText = function () {\n    var bytes = this.asBytes();\n    return String.fromCharCode.apply(String, Array.from(bytes));\n  };\n  PDFName.prototype.asString = function () {\n    return this.encodedName;\n  };\n  /** @deprecated in favor of [[PDFName.asString]] */\n  PDFName.prototype.value = function () {\n    return this.encodedName;\n  };\n  PDFName.prototype.clone = function () {\n    return this;\n  };\n  PDFName.prototype.toString = function () {\n    return this.encodedName;\n  };\n  PDFName.prototype.sizeInBytes = function () {\n    return this.encodedName.length;\n  };\n  PDFName.prototype.copyBytesInto = function (buffer, offset) {\n    offset += copyStringIntoBuffer(this.encodedName, buffer, offset);\n    return this.encodedName.length;\n  };\n  PDFName.of = function (name) {\n    var decodedValue = decodeName(name);\n    var instance = pool.get(decodedValue);\n    if (!instance) {\n      instance = new PDFName(ENFORCER, decodedValue);\n      pool.set(decodedValue, instance);\n    }\n    return instance;\n  };\n  /* tslint:disable member-ordering */\n  PDFName.Length = PDFName.of('Length');\n  PDFName.FlateDecode = PDFName.of('FlateDecode');\n  PDFName.Resources = PDFName.of('Resources');\n  PDFName.Font = PDFName.of('Font');\n  PDFName.XObject = PDFName.of('XObject');\n  PDFName.ExtGState = PDFName.of('ExtGState');\n  PDFName.Contents = PDFName.of('Contents');\n  PDFName.Type = PDFName.of('Type');\n  PDFName.Parent = PDFName.of('Parent');\n  PDFName.MediaBox = PDFName.of('MediaBox');\n  PDFName.Page = PDFName.of('Page');\n  PDFName.Annots = PDFName.of('Annots');\n  PDFName.TrimBox = PDFName.of('TrimBox');\n  PDFName.ArtBox = PDFName.of('ArtBox');\n  PDFName.BleedBox = PDFName.of('BleedBox');\n  PDFName.CropBox = PDFName.of('CropBox');\n  PDFName.Rotate = PDFName.of('Rotate');\n  PDFName.Title = PDFName.of('Title');\n  PDFName.Author = PDFName.of('Author');\n  PDFName.Subject = PDFName.of('Subject');\n  PDFName.Creator = PDFName.of('Creator');\n  PDFName.Keywords = PDFName.of('Keywords');\n  PDFName.Producer = PDFName.of('Producer');\n  PDFName.CreationDate = PDFName.of('CreationDate');\n  PDFName.ModDate = PDFName.of('ModDate');\n  return PDFName;\n}(PDFObject);\nexport default PDFName;","map":{"version":3,"names":["PrivateConstructorError","PDFObject","CharCodes","IsIrregular","charFromHexCode","copyStringIntoBuffer","toCharCode","toHexString","decodeName","name","replace","_","hex","isRegularChar","charCode","ExclamationPoint","Tilde","ENFORCER","pool","Map","PDFName","_super","__extends","enforcer","_this","call","encodedName","idx","len","length","character","code","prototype","asBytes","bytes","escaped","pushByte","byte","undefined","push","char","nextChar","Hash","Zero","Nine","a","f","A","F","parseInt","Uint8Array","decodeText","String","fromCharCode","apply","Array","from","asString","value","clone","toString","sizeInBytes","copyBytesInto","buffer","offset","of","decodedValue","instance","get","set","Length","FlateDecode","Resources","Font","XObject","ExtGState","Contents","Type","Parent","MediaBox","Page","Annots","TrimBox","ArtBox","BleedBox","CropBox","Rotate","Title","Author","Subject","Creator","Keywords","Producer","CreationDate","ModDate"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/objects/PDFName.ts"],"sourcesContent":["import { PrivateConstructorError } from 'src/core/errors';\nimport PDFObject from 'src/core/objects/PDFObject';\nimport CharCodes from 'src/core/syntax/CharCodes';\nimport { IsIrregular } from 'src/core/syntax/Irregular';\nimport {\n  charFromHexCode,\n  copyStringIntoBuffer,\n  toCharCode,\n  toHexString,\n} from 'src/utils';\n\nconst decodeName = (name: string) =>\n  name.replace(/#([\\dABCDEF]{2})/g, (_, hex) => charFromHexCode(hex));\n\nconst isRegularChar = (charCode: number) =>\n  charCode >= CharCodes.ExclamationPoint &&\n  charCode <= CharCodes.Tilde &&\n  !IsIrregular[charCode];\n\nconst ENFORCER = {};\nconst pool = new Map<string, PDFName>();\n\nclass PDFName extends PDFObject {\n  static of = (name: string): PDFName => {\n    const decodedValue = decodeName(name);\n\n    let instance = pool.get(decodedValue);\n    if (!instance) {\n      instance = new PDFName(ENFORCER, decodedValue);\n      pool.set(decodedValue, instance);\n    }\n\n    return instance;\n  };\n\n  /* tslint:disable member-ordering */\n  static readonly Length = PDFName.of('Length');\n  static readonly FlateDecode = PDFName.of('FlateDecode');\n  static readonly Resources = PDFName.of('Resources');\n  static readonly Font = PDFName.of('Font');\n  static readonly XObject = PDFName.of('XObject');\n  static readonly ExtGState = PDFName.of('ExtGState');\n  static readonly Contents = PDFName.of('Contents');\n  static readonly Type = PDFName.of('Type');\n  static readonly Parent = PDFName.of('Parent');\n  static readonly MediaBox = PDFName.of('MediaBox');\n  static readonly Page = PDFName.of('Page');\n  static readonly Annots = PDFName.of('Annots');\n  static readonly TrimBox = PDFName.of('TrimBox');\n  static readonly ArtBox = PDFName.of('ArtBox');\n  static readonly BleedBox = PDFName.of('BleedBox');\n  static readonly CropBox = PDFName.of('CropBox');\n  static readonly Rotate = PDFName.of('Rotate');\n  static readonly Title = PDFName.of('Title');\n  static readonly Author = PDFName.of('Author');\n  static readonly Subject = PDFName.of('Subject');\n  static readonly Creator = PDFName.of('Creator');\n  static readonly Keywords = PDFName.of('Keywords');\n  static readonly Producer = PDFName.of('Producer');\n  static readonly CreationDate = PDFName.of('CreationDate');\n  static readonly ModDate = PDFName.of('ModDate');\n  /* tslint:enable member-ordering */\n\n  private readonly encodedName: string;\n\n  private constructor(enforcer: any, name: string) {\n    if (enforcer !== ENFORCER) throw new PrivateConstructorError('PDFName');\n    super();\n\n    let encodedName = '/';\n    for (let idx = 0, len = name.length; idx < len; idx++) {\n      const character = name[idx];\n      const code = toCharCode(character);\n      encodedName += isRegularChar(code) ? character : `#${toHexString(code)}`;\n    }\n\n    this.encodedName = encodedName;\n  }\n\n  asBytes(): Uint8Array {\n    const bytes: number[] = [];\n\n    let hex = '';\n    let escaped = false;\n\n    const pushByte = (byte?: number) => {\n      if (byte !== undefined) bytes.push(byte);\n      escaped = false;\n    };\n\n    for (let idx = 1, len = this.encodedName.length; idx < len; idx++) {\n      const char = this.encodedName[idx];\n      const byte = toCharCode(char);\n      const nextChar = this.encodedName[idx + 1];\n      if (!escaped) {\n        if (byte === CharCodes.Hash) escaped = true;\n        else pushByte(byte);\n      } else {\n        if (\n          (byte >= CharCodes.Zero && byte <= CharCodes.Nine) ||\n          (byte >= CharCodes.a && byte <= CharCodes.f) ||\n          (byte >= CharCodes.A && byte <= CharCodes.F)\n        ) {\n          hex += char;\n          if (\n            hex.length === 2 ||\n            !(\n              (nextChar >= '0' && nextChar <= '9') ||\n              (nextChar >= 'a' && nextChar <= 'f') ||\n              (nextChar >= 'A' && nextChar <= 'F')\n            )\n          ) {\n            pushByte(parseInt(hex, 16));\n            hex = '';\n          }\n        } else {\n          pushByte(byte);\n        }\n      }\n    }\n\n    return new Uint8Array(bytes);\n  }\n\n  // TODO: This should probably use `utf8Decode()`\n  // TODO: Polyfill Array.from?\n  decodeText(): string {\n    const bytes = this.asBytes();\n    return String.fromCharCode(...Array.from(bytes));\n  }\n\n  asString(): string {\n    return this.encodedName;\n  }\n\n  /** @deprecated in favor of [[PDFName.asString]] */\n  value(): string {\n    return this.encodedName;\n  }\n\n  clone(): PDFName {\n    return this;\n  }\n\n  toString(): string {\n    return this.encodedName;\n  }\n\n  sizeInBytes(): number {\n    return this.encodedName.length;\n  }\n\n  copyBytesInto(buffer: Uint8Array, offset: number): number {\n    offset += copyStringIntoBuffer(this.encodedName, buffer, offset);\n    return this.encodedName.length;\n  }\n}\n\nexport default PDFName;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}