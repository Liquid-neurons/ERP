{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PDFObjectParsingError, PDFStreamParsingError, UnbalancedParenthesisError } from \"../errors\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFBool from \"../objects/PDFBool\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFHexString from \"../objects/PDFHexString\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNull from \"../objects/PDFNull\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFString from \"../objects/PDFString\";\nimport BaseParser from \"./BaseParser\";\nimport ByteStream from \"./ByteStream\";\nimport PDFCatalog from \"../structures/PDFCatalog\";\nimport PDFPageLeaf from \"../structures/PDFPageLeaf\";\nimport PDFPageTree from \"../structures/PDFPageTree\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDelimiter } from \"../syntax/Delimiters\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\n// TODO: Throw error if eof is reached before finishing object parse...\nvar PDFObjectParser = /** @class */function (_super) {\n  __extends(PDFObjectParser, _super);\n  function PDFObjectParser(byteStream, context, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    var _this = _super.call(this, byteStream, capNumbers) || this;\n    _this.context = context;\n    return _this;\n  }\n  // TODO: Is it possible to reduce duplicate parsing for ref lookaheads?\n  PDFObjectParser.prototype.parseObject = function () {\n    this.skipWhitespaceAndComments();\n    if (this.matchKeyword(Keywords.true)) return PDFBool.True;\n    if (this.matchKeyword(Keywords.false)) return PDFBool.False;\n    if (this.matchKeyword(Keywords.null)) return PDFNull;\n    var byte = this.bytes.peek();\n    if (byte === CharCodes.LessThan && this.bytes.peekAhead(1) === CharCodes.LessThan) {\n      return this.parseDictOrStream();\n    }\n    if (byte === CharCodes.LessThan) return this.parseHexString();\n    if (byte === CharCodes.LeftParen) return this.parseString();\n    if (byte === CharCodes.ForwardSlash) return this.parseName();\n    if (byte === CharCodes.LeftSquareBracket) return this.parseArray();\n    if (IsNumeric[byte]) return this.parseNumberOrRef();\n    throw new PDFObjectParsingError(this.bytes.position(), byte);\n  };\n  PDFObjectParser.prototype.parseNumberOrRef = function () {\n    var firstNum = this.parseRawNumber();\n    this.skipWhitespaceAndComments();\n    var lookaheadStart = this.bytes.offset();\n    if (IsDigit[this.bytes.peek()]) {\n      var secondNum = this.parseRawNumber();\n      this.skipWhitespaceAndComments();\n      if (this.bytes.peek() === CharCodes.R) {\n        this.bytes.assertNext(CharCodes.R);\n        return PDFRef.of(firstNum, secondNum);\n      }\n    }\n    this.bytes.moveTo(lookaheadStart);\n    return PDFNumber.of(firstNum);\n  };\n  // TODO: Maybe update PDFHexString.of() logic to remove whitespace and validate input?\n  PDFObjectParser.prototype.parseHexString = function () {\n    var value = '';\n    this.bytes.assertNext(CharCodes.LessThan);\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan) {\n      value += charFromCode(this.bytes.next());\n    }\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    return PDFHexString.of(value);\n  };\n  PDFObjectParser.prototype.parseString = function () {\n    var nestingLvl = 0;\n    var isEscaped = false;\n    var value = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.next();\n      value += charFromCode(byte);\n      // Check for unescaped parenthesis\n      if (!isEscaped) {\n        if (byte === CharCodes.LeftParen) nestingLvl += 1;\n        if (byte === CharCodes.RightParen) nestingLvl -= 1;\n      }\n      // Track whether current character is being escaped or not\n      if (byte === CharCodes.BackSlash) {\n        isEscaped = !isEscaped;\n      } else if (isEscaped) {\n        isEscaped = false;\n      }\n      // Once (if) the unescaped parenthesis balance out, return their contents\n      if (nestingLvl === 0) {\n        // Remove the outer parens so they aren't part of the contents\n        return PDFString.of(value.substring(1, value.length - 1));\n      }\n    }\n    throw new UnbalancedParenthesisError(this.bytes.position());\n  };\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  // TODO: Maybe preallocate small Uint8Array if can use charFromCode?\n  PDFObjectParser.prototype.parseName = function () {\n    this.bytes.assertNext(CharCodes.ForwardSlash);\n    var name = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (IsWhitespace[byte] || IsDelimiter[byte]) break;\n      name += charFromCode(byte);\n      this.bytes.next();\n    }\n    return PDFName.of(name);\n  };\n  PDFObjectParser.prototype.parseArray = function () {\n    this.bytes.assertNext(CharCodes.LeftSquareBracket);\n    this.skipWhitespaceAndComments();\n    var pdfArray = PDFArray.withContext(this.context);\n    while (this.bytes.peek() !== CharCodes.RightSquareBracket) {\n      var element = this.parseObject();\n      pdfArray.push(element);\n      this.skipWhitespaceAndComments();\n    }\n    this.bytes.assertNext(CharCodes.RightSquareBracket);\n    return pdfArray;\n  };\n  PDFObjectParser.prototype.parseDict = function () {\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.skipWhitespaceAndComments();\n    var dict = new Map();\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan && this.bytes.peekAhead(1) !== CharCodes.GreaterThan) {\n      var key = this.parseName();\n      var value = this.parseObject();\n      dict.set(key, value);\n      this.skipWhitespaceAndComments();\n    }\n    this.skipWhitespaceAndComments();\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    var Type = dict.get(PDFName.of('Type'));\n    if (Type === PDFName.of('Catalog')) {\n      return PDFCatalog.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Pages')) {\n      return PDFPageTree.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Page')) {\n      return PDFPageLeaf.fromMapWithContext(dict, this.context);\n    } else {\n      return PDFDict.fromMapWithContext(dict, this.context);\n    }\n  };\n  PDFObjectParser.prototype.parseDictOrStream = function () {\n    var startPos = this.bytes.position();\n    var dict = this.parseDict();\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.streamEOF1) && !this.matchKeyword(Keywords.streamEOF2) && !this.matchKeyword(Keywords.streamEOF3) && !this.matchKeyword(Keywords.streamEOF4) && !this.matchKeyword(Keywords.stream)) {\n      return dict;\n    }\n    var start = this.bytes.offset();\n    var end;\n    var Length = dict.get(PDFName.of('Length'));\n    if (Length instanceof PDFNumber) {\n      end = start + Length.asNumber();\n      this.bytes.moveTo(end);\n      this.skipWhitespaceAndComments();\n      if (!this.matchKeyword(Keywords.endstream)) {\n        this.bytes.moveTo(start);\n        end = this.findEndOfStreamFallback(startPos);\n      }\n    } else {\n      end = this.findEndOfStreamFallback(startPos);\n    }\n    var contents = this.bytes.slice(start, end);\n    return PDFRawStream.of(dict, contents);\n  };\n  PDFObjectParser.prototype.findEndOfStreamFallback = function (startPos) {\n    // Move to end of stream, while handling nested streams\n    var nestingLvl = 1;\n    var end = this.bytes.offset();\n    while (!this.bytes.done()) {\n      end = this.bytes.offset();\n      if (this.matchKeyword(Keywords.stream)) {\n        nestingLvl += 1;\n      } else if (this.matchKeyword(Keywords.EOF1endstream) || this.matchKeyword(Keywords.EOF2endstream) || this.matchKeyword(Keywords.EOF3endstream) || this.matchKeyword(Keywords.endstream)) {\n        nestingLvl -= 1;\n      } else {\n        this.bytes.next();\n      }\n      if (nestingLvl === 0) break;\n    }\n    if (nestingLvl !== 0) throw new PDFStreamParsingError(startPos);\n    return end;\n  };\n  PDFObjectParser.forBytes = function (bytes, context, capNumbers) {\n    return new PDFObjectParser(ByteStream.of(bytes), context, capNumbers);\n  };\n  PDFObjectParser.forByteStream = function (byteStream, context, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    return new PDFObjectParser(byteStream, context, capNumbers);\n  };\n  return PDFObjectParser;\n}(BaseParser);\nexport default PDFObjectParser;","map":{"version":3,"names":["PDFObjectParsingError","PDFStreamParsingError","UnbalancedParenthesisError","PDFArray","PDFBool","PDFDict","PDFHexString","PDFName","PDFNull","PDFNumber","PDFRawStream","PDFRef","PDFString","BaseParser","ByteStream","PDFCatalog","PDFPageLeaf","PDFPageTree","CharCodes","IsDelimiter","Keywords","IsDigit","IsNumeric","IsWhitespace","charFromCode","PDFObjectParser","_super","__extends","byteStream","context","capNumbers","_this","call","prototype","parseObject","skipWhitespaceAndComments","matchKeyword","true","True","false","False","null","byte","bytes","peek","LessThan","peekAhead","parseDictOrStream","parseHexString","LeftParen","parseString","ForwardSlash","parseName","LeftSquareBracket","parseArray","parseNumberOrRef","position","firstNum","parseRawNumber","lookaheadStart","offset","secondNum","R","assertNext","of","moveTo","value","done","GreaterThan","next","nestingLvl","isEscaped","RightParen","BackSlash","substring","length","name","pdfArray","withContext","RightSquareBracket","element","push","parseDict","dict","Map","key","set","Type","get","fromMapWithContext","startPos","streamEOF1","streamEOF2","streamEOF3","streamEOF4","stream","start","end","Length","asNumber","endstream","findEndOfStreamFallback","contents","slice","EOF1endstream","EOF2endstream","EOF3endstream","forBytes","forByteStream"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/parser/PDFObjectParser.ts"],"sourcesContent":["import {\n  PDFObjectParsingError,\n  PDFStreamParsingError,\n  Position,\n  UnbalancedParenthesisError,\n} from 'src/core/errors';\nimport PDFArray from 'src/core/objects/PDFArray';\nimport PDFBool from 'src/core/objects/PDFBool';\nimport PDFDict, { DictMap } from 'src/core/objects/PDFDict';\nimport PDFHexString from 'src/core/objects/PDFHexString';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFNull from 'src/core/objects/PDFNull';\nimport PDFNumber from 'src/core/objects/PDFNumber';\nimport PDFObject from 'src/core/objects/PDFObject';\nimport PDFRawStream from 'src/core/objects/PDFRawStream';\nimport PDFRef from 'src/core/objects/PDFRef';\nimport PDFStream from 'src/core/objects/PDFStream';\nimport PDFString from 'src/core/objects/PDFString';\nimport BaseParser from 'src/core/parser/BaseParser';\nimport ByteStream from 'src/core/parser/ByteStream';\nimport PDFContext from 'src/core/PDFContext';\nimport PDFCatalog from 'src/core/structures/PDFCatalog';\nimport PDFPageLeaf from 'src/core/structures/PDFPageLeaf';\nimport PDFPageTree from 'src/core/structures/PDFPageTree';\nimport CharCodes from 'src/core/syntax/CharCodes';\nimport { IsDelimiter } from 'src/core/syntax/Delimiters';\nimport { Keywords } from 'src/core/syntax/Keywords';\nimport { IsDigit, IsNumeric } from 'src/core/syntax/Numeric';\nimport { IsWhitespace } from 'src/core/syntax/Whitespace';\nimport { charFromCode } from 'src/utils';\n\n// TODO: Throw error if eof is reached before finishing object parse...\nclass PDFObjectParser extends BaseParser {\n  static forBytes = (\n    bytes: Uint8Array,\n    context: PDFContext,\n    capNumbers?: boolean,\n  ) => new PDFObjectParser(ByteStream.of(bytes), context, capNumbers);\n\n  static forByteStream = (\n    byteStream: ByteStream,\n    context: PDFContext,\n    capNumbers = false,\n  ) => new PDFObjectParser(byteStream, context, capNumbers);\n\n  protected readonly context: PDFContext;\n\n  constructor(byteStream: ByteStream, context: PDFContext, capNumbers = false) {\n    super(byteStream, capNumbers);\n    this.context = context;\n  }\n\n  // TODO: Is it possible to reduce duplicate parsing for ref lookaheads?\n  parseObject(): PDFObject {\n    this.skipWhitespaceAndComments();\n\n    if (this.matchKeyword(Keywords.true)) return PDFBool.True;\n    if (this.matchKeyword(Keywords.false)) return PDFBool.False;\n    if (this.matchKeyword(Keywords.null)) return PDFNull;\n\n    const byte = this.bytes.peek();\n\n    if (\n      byte === CharCodes.LessThan &&\n      this.bytes.peekAhead(1) === CharCodes.LessThan\n    ) {\n      return this.parseDictOrStream();\n    }\n    if (byte === CharCodes.LessThan) return this.parseHexString();\n    if (byte === CharCodes.LeftParen) return this.parseString();\n    if (byte === CharCodes.ForwardSlash) return this.parseName();\n    if (byte === CharCodes.LeftSquareBracket) return this.parseArray();\n    if (IsNumeric[byte]) return this.parseNumberOrRef();\n\n    throw new PDFObjectParsingError(this.bytes.position(), byte);\n  }\n\n  protected parseNumberOrRef(): PDFNumber | PDFRef {\n    const firstNum = this.parseRawNumber();\n    this.skipWhitespaceAndComments();\n\n    const lookaheadStart = this.bytes.offset();\n    if (IsDigit[this.bytes.peek()]) {\n      const secondNum = this.parseRawNumber();\n      this.skipWhitespaceAndComments();\n      if (this.bytes.peek() === CharCodes.R) {\n        this.bytes.assertNext(CharCodes.R);\n        return PDFRef.of(firstNum, secondNum);\n      }\n    }\n\n    this.bytes.moveTo(lookaheadStart);\n    return PDFNumber.of(firstNum);\n  }\n\n  // TODO: Maybe update PDFHexString.of() logic to remove whitespace and validate input?\n  protected parseHexString(): PDFHexString {\n    let value = '';\n\n    this.bytes.assertNext(CharCodes.LessThan);\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan) {\n      value += charFromCode(this.bytes.next());\n    }\n    this.bytes.assertNext(CharCodes.GreaterThan);\n\n    return PDFHexString.of(value);\n  }\n\n  protected parseString(): PDFString {\n    let nestingLvl = 0;\n    let isEscaped = false;\n    let value = '';\n\n    while (!this.bytes.done()) {\n      const byte = this.bytes.next();\n      value += charFromCode(byte);\n\n      // Check for unescaped parenthesis\n      if (!isEscaped) {\n        if (byte === CharCodes.LeftParen) nestingLvl += 1;\n        if (byte === CharCodes.RightParen) nestingLvl -= 1;\n      }\n\n      // Track whether current character is being escaped or not\n      if (byte === CharCodes.BackSlash) {\n        isEscaped = !isEscaped;\n      } else if (isEscaped) {\n        isEscaped = false;\n      }\n\n      // Once (if) the unescaped parenthesis balance out, return their contents\n      if (nestingLvl === 0) {\n        // Remove the outer parens so they aren't part of the contents\n        return PDFString.of(value.substring(1, value.length - 1));\n      }\n    }\n\n    throw new UnbalancedParenthesisError(this.bytes.position());\n  }\n\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  // TODO: Maybe preallocate small Uint8Array if can use charFromCode?\n  protected parseName(): PDFName {\n    this.bytes.assertNext(CharCodes.ForwardSlash);\n\n    let name = '';\n    while (!this.bytes.done()) {\n      const byte = this.bytes.peek();\n      if (IsWhitespace[byte] || IsDelimiter[byte]) break;\n      name += charFromCode(byte);\n      this.bytes.next();\n    }\n\n    return PDFName.of(name);\n  }\n\n  protected parseArray(): PDFArray {\n    this.bytes.assertNext(CharCodes.LeftSquareBracket);\n    this.skipWhitespaceAndComments();\n\n    const pdfArray = PDFArray.withContext(this.context);\n    while (this.bytes.peek() !== CharCodes.RightSquareBracket) {\n      const element = this.parseObject();\n      pdfArray.push(element);\n      this.skipWhitespaceAndComments();\n    }\n    this.bytes.assertNext(CharCodes.RightSquareBracket);\n    return pdfArray;\n  }\n\n  protected parseDict(): PDFDict {\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.skipWhitespaceAndComments();\n\n    const dict: DictMap = new Map();\n\n    while (\n      !this.bytes.done() &&\n      this.bytes.peek() !== CharCodes.GreaterThan &&\n      this.bytes.peekAhead(1) !== CharCodes.GreaterThan\n    ) {\n      const key = this.parseName();\n      const value = this.parseObject();\n      dict.set(key, value);\n      this.skipWhitespaceAndComments();\n    }\n\n    this.skipWhitespaceAndComments();\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    this.bytes.assertNext(CharCodes.GreaterThan);\n\n    const Type = dict.get(PDFName.of('Type'));\n\n    if (Type === PDFName.of('Catalog')) {\n      return PDFCatalog.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Pages')) {\n      return PDFPageTree.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Page')) {\n      return PDFPageLeaf.fromMapWithContext(dict, this.context);\n    } else {\n      return PDFDict.fromMapWithContext(dict, this.context);\n    }\n  }\n\n  protected parseDictOrStream(): PDFDict | PDFStream {\n    const startPos = this.bytes.position();\n\n    const dict = this.parseDict();\n\n    this.skipWhitespaceAndComments();\n\n    if (\n      !this.matchKeyword(Keywords.streamEOF1) &&\n      !this.matchKeyword(Keywords.streamEOF2) &&\n      !this.matchKeyword(Keywords.streamEOF3) &&\n      !this.matchKeyword(Keywords.streamEOF4) &&\n      !this.matchKeyword(Keywords.stream)\n    ) {\n      return dict;\n    }\n\n    const start = this.bytes.offset();\n    let end: number;\n\n    const Length = dict.get(PDFName.of('Length'));\n    if (Length instanceof PDFNumber) {\n      end = start + Length.asNumber();\n      this.bytes.moveTo(end);\n      this.skipWhitespaceAndComments();\n      if (!this.matchKeyword(Keywords.endstream)) {\n        this.bytes.moveTo(start);\n        end = this.findEndOfStreamFallback(startPos);\n      }\n    } else {\n      end = this.findEndOfStreamFallback(startPos);\n    }\n\n    const contents = this.bytes.slice(start, end);\n\n    return PDFRawStream.of(dict, contents);\n  }\n\n  protected findEndOfStreamFallback(startPos: Position) {\n    // Move to end of stream, while handling nested streams\n    let nestingLvl = 1;\n    let end = this.bytes.offset();\n\n    while (!this.bytes.done()) {\n      end = this.bytes.offset();\n\n      if (this.matchKeyword(Keywords.stream)) {\n        nestingLvl += 1;\n      } else if (\n        this.matchKeyword(Keywords.EOF1endstream) ||\n        this.matchKeyword(Keywords.EOF2endstream) ||\n        this.matchKeyword(Keywords.EOF3endstream) ||\n        this.matchKeyword(Keywords.endstream)\n      ) {\n        nestingLvl -= 1;\n      } else {\n        this.bytes.next();\n      }\n\n      if (nestingLvl === 0) break;\n    }\n\n    if (nestingLvl !== 0) throw new PDFStreamParsingError(startPos);\n\n    return end;\n  }\n}\n\nexport default PDFObjectParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}