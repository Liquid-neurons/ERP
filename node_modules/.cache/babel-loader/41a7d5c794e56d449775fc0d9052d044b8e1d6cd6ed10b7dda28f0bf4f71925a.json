{"ast":null,"code":"import PDFRef from \"../objects/PDFRef\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, padStart } from \"../../utils\";\n/**\n * Entries should be added using the [[addEntry]] and [[addDeletedEntry]]\n * methods **in order of ascending object number**.\n */\nvar PDFCrossRefSection = /** @class */function () {\n  function PDFCrossRefSection(firstEntry) {\n    this.subsections = firstEntry ? [[firstEntry]] : [];\n    this.chunkIdx = 0;\n    this.chunkLength = firstEntry ? 1 : 0;\n  }\n  PDFCrossRefSection.prototype.addEntry = function (ref, offset) {\n    this.append({\n      ref: ref,\n      offset: offset,\n      deleted: false\n    });\n  };\n  PDFCrossRefSection.prototype.addDeletedEntry = function (ref, nextFreeObjectNumber) {\n    this.append({\n      ref: ref,\n      offset: nextFreeObjectNumber,\n      deleted: true\n    });\n  };\n  PDFCrossRefSection.prototype.toString = function () {\n    var section = \"xref\\n\";\n    for (var rangeIdx = 0, rangeLen = this.subsections.length; rangeIdx < rangeLen; rangeIdx++) {\n      var range = this.subsections[rangeIdx];\n      section += range[0].ref.objectNumber + \" \" + range.length + \"\\n\";\n      for (var entryIdx = 0, entryLen = range.length; entryIdx < entryLen; entryIdx++) {\n        var entry = range[entryIdx];\n        section += padStart(String(entry.offset), 10, '0');\n        section += ' ';\n        section += padStart(String(entry.ref.generationNumber), 5, '0');\n        section += ' ';\n        section += entry.deleted ? 'f' : 'n';\n        section += ' \\n';\n      }\n    }\n    return section;\n  };\n  PDFCrossRefSection.prototype.sizeInBytes = function () {\n    var size = 5;\n    for (var idx = 0, len = this.subsections.length; idx < len; idx++) {\n      var subsection = this.subsections[idx];\n      var subsectionLength = subsection.length;\n      var firstEntry = subsection[0];\n      size += 2;\n      size += String(firstEntry.ref.objectNumber).length;\n      size += String(subsectionLength).length;\n      size += 20 * subsectionLength;\n    }\n    return size;\n  };\n  PDFCrossRefSection.prototype.copyBytesInto = function (buffer, offset) {\n    var initialOffset = offset;\n    buffer[offset++] = CharCodes.x;\n    buffer[offset++] = CharCodes.r;\n    buffer[offset++] = CharCodes.e;\n    buffer[offset++] = CharCodes.f;\n    buffer[offset++] = CharCodes.Newline;\n    offset += this.copySubsectionsIntoBuffer(this.subsections, buffer, offset);\n    return offset - initialOffset;\n  };\n  PDFCrossRefSection.prototype.copySubsectionsIntoBuffer = function (subsections, buffer, offset) {\n    var initialOffset = offset;\n    var length = subsections.length;\n    for (var idx = 0; idx < length; idx++) {\n      var subsection = this.subsections[idx];\n      var firstObjectNumber = String(subsection[0].ref.objectNumber);\n      offset += copyStringIntoBuffer(firstObjectNumber, buffer, offset);\n      buffer[offset++] = CharCodes.Space;\n      var rangeLength = String(subsection.length);\n      offset += copyStringIntoBuffer(rangeLength, buffer, offset);\n      buffer[offset++] = CharCodes.Newline;\n      offset += this.copyEntriesIntoBuffer(subsection, buffer, offset);\n    }\n    return offset - initialOffset;\n  };\n  PDFCrossRefSection.prototype.copyEntriesIntoBuffer = function (entries, buffer, offset) {\n    var length = entries.length;\n    for (var idx = 0; idx < length; idx++) {\n      var entry = entries[idx];\n      var entryOffset = padStart(String(entry.offset), 10, '0');\n      offset += copyStringIntoBuffer(entryOffset, buffer, offset);\n      buffer[offset++] = CharCodes.Space;\n      var entryGen = padStart(String(entry.ref.generationNumber), 5, '0');\n      offset += copyStringIntoBuffer(entryGen, buffer, offset);\n      buffer[offset++] = CharCodes.Space;\n      buffer[offset++] = entry.deleted ? CharCodes.f : CharCodes.n;\n      buffer[offset++] = CharCodes.Space;\n      buffer[offset++] = CharCodes.Newline;\n    }\n    return 20 * length;\n  };\n  PDFCrossRefSection.prototype.append = function (currEntry) {\n    if (this.chunkLength === 0) {\n      this.subsections.push([currEntry]);\n      this.chunkIdx = 0;\n      this.chunkLength = 1;\n      return;\n    }\n    var chunk = this.subsections[this.chunkIdx];\n    var prevEntry = chunk[this.chunkLength - 1];\n    if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {\n      this.subsections.push([currEntry]);\n      this.chunkIdx += 1;\n      this.chunkLength = 1;\n    } else {\n      chunk.push(currEntry);\n      this.chunkLength += 1;\n    }\n  };\n  PDFCrossRefSection.create = function () {\n    return new PDFCrossRefSection({\n      ref: PDFRef.of(0, 65535),\n      offset: 0,\n      deleted: true\n    });\n  };\n  PDFCrossRefSection.createEmpty = function () {\n    return new PDFCrossRefSection();\n  };\n  return PDFCrossRefSection;\n}();\nexport default PDFCrossRefSection;","map":{"version":3,"names":["PDFRef","CharCodes","copyStringIntoBuffer","padStart","PDFCrossRefSection","firstEntry","subsections","chunkIdx","chunkLength","prototype","addEntry","ref","offset","append","deleted","addDeletedEntry","nextFreeObjectNumber","toString","section","rangeIdx","rangeLen","length","range","objectNumber","entryIdx","entryLen","entry","String","generationNumber","sizeInBytes","size","idx","len","subsection","subsectionLength","copyBytesInto","buffer","initialOffset","x","r","e","f","Newline","copySubsectionsIntoBuffer","firstObjectNumber","Space","rangeLength","copyEntriesIntoBuffer","entries","entryOffset","entryGen","n","currEntry","push","chunk","prevEntry","create","of","createEmpty"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/document/PDFCrossRefSection.ts"],"sourcesContent":["import PDFRef from 'src/core/objects/PDFRef';\nimport CharCodes from 'src/core/syntax/CharCodes';\nimport { copyStringIntoBuffer, padStart } from 'src/utils';\n\nexport interface Entry {\n  ref: PDFRef;\n  offset: number;\n  deleted: boolean;\n}\n\n/**\n * Entries should be added using the [[addEntry]] and [[addDeletedEntry]]\n * methods **in order of ascending object number**.\n */\nclass PDFCrossRefSection {\n  static create = () =>\n    new PDFCrossRefSection({\n      ref: PDFRef.of(0, 65535),\n      offset: 0,\n      deleted: true,\n    });\n\n  static createEmpty = () => new PDFCrossRefSection();\n\n  private subsections: Entry[][];\n  private chunkIdx: number;\n  private chunkLength: number;\n\n  private constructor(firstEntry: Entry | void) {\n    this.subsections = firstEntry ? [[firstEntry]] : [];\n    this.chunkIdx = 0;\n    this.chunkLength = firstEntry ? 1 : 0;\n  }\n\n  addEntry(ref: PDFRef, offset: number): void {\n    this.append({ ref, offset, deleted: false });\n  }\n\n  addDeletedEntry(ref: PDFRef, nextFreeObjectNumber: number): void {\n    this.append({ ref, offset: nextFreeObjectNumber, deleted: true });\n  }\n\n  toString(): string {\n    let section = `xref\\n`;\n\n    for (\n      let rangeIdx = 0, rangeLen = this.subsections.length;\n      rangeIdx < rangeLen;\n      rangeIdx++\n    ) {\n      const range = this.subsections[rangeIdx];\n      section += `${range[0].ref.objectNumber} ${range.length}\\n`;\n      for (\n        let entryIdx = 0, entryLen = range.length;\n        entryIdx < entryLen;\n        entryIdx++\n      ) {\n        const entry = range[entryIdx];\n        section += padStart(String(entry.offset), 10, '0');\n        section += ' ';\n        section += padStart(String(entry.ref.generationNumber), 5, '0');\n        section += ' ';\n        section += entry.deleted ? 'f' : 'n';\n        section += ' \\n';\n      }\n    }\n\n    return section;\n  }\n\n  sizeInBytes(): number {\n    let size = 5;\n    for (let idx = 0, len = this.subsections.length; idx < len; idx++) {\n      const subsection = this.subsections[idx];\n      const subsectionLength = subsection.length;\n      const [firstEntry] = subsection;\n      size += 2;\n      size += String(firstEntry.ref.objectNumber).length;\n      size += String(subsectionLength).length;\n      size += 20 * subsectionLength;\n    }\n    return size;\n  }\n\n  copyBytesInto(buffer: Uint8Array, offset: number): number {\n    const initialOffset = offset;\n\n    buffer[offset++] = CharCodes.x;\n    buffer[offset++] = CharCodes.r;\n    buffer[offset++] = CharCodes.e;\n    buffer[offset++] = CharCodes.f;\n    buffer[offset++] = CharCodes.Newline;\n\n    offset += this.copySubsectionsIntoBuffer(this.subsections, buffer, offset);\n\n    return offset - initialOffset;\n  }\n\n  private copySubsectionsIntoBuffer(\n    subsections: Entry[][],\n    buffer: Uint8Array,\n    offset: number,\n  ): number {\n    const initialOffset = offset;\n    const length = subsections.length;\n\n    for (let idx = 0; idx < length; idx++) {\n      const subsection = this.subsections[idx];\n\n      const firstObjectNumber = String(subsection[0].ref.objectNumber);\n      offset += copyStringIntoBuffer(firstObjectNumber, buffer, offset);\n      buffer[offset++] = CharCodes.Space;\n\n      const rangeLength = String(subsection.length);\n      offset += copyStringIntoBuffer(rangeLength, buffer, offset);\n      buffer[offset++] = CharCodes.Newline;\n\n      offset += this.copyEntriesIntoBuffer(subsection, buffer, offset);\n    }\n\n    return offset - initialOffset;\n  }\n\n  private copyEntriesIntoBuffer(\n    entries: Entry[],\n    buffer: Uint8Array,\n    offset: number,\n  ): number {\n    const length = entries.length;\n\n    for (let idx = 0; idx < length; idx++) {\n      const entry = entries[idx];\n\n      const entryOffset = padStart(String(entry.offset), 10, '0');\n      offset += copyStringIntoBuffer(entryOffset, buffer, offset);\n      buffer[offset++] = CharCodes.Space;\n\n      const entryGen = padStart(String(entry.ref.generationNumber), 5, '0');\n      offset += copyStringIntoBuffer(entryGen, buffer, offset);\n      buffer[offset++] = CharCodes.Space;\n\n      buffer[offset++] = entry.deleted ? CharCodes.f : CharCodes.n;\n\n      buffer[offset++] = CharCodes.Space;\n      buffer[offset++] = CharCodes.Newline;\n    }\n\n    return 20 * length;\n  }\n\n  private append(currEntry: Entry): void {\n    if (this.chunkLength === 0) {\n      this.subsections.push([currEntry]);\n      this.chunkIdx = 0;\n      this.chunkLength = 1;\n      return;\n    }\n\n    const chunk = this.subsections[this.chunkIdx];\n    const prevEntry = chunk[this.chunkLength - 1];\n\n    if (currEntry.ref.objectNumber - prevEntry.ref.objectNumber > 1) {\n      this.subsections.push([currEntry]);\n      this.chunkIdx += 1;\n      this.chunkLength = 1;\n    } else {\n      chunk.push(currEntry);\n      this.chunkLength += 1;\n    }\n  }\n}\n\nexport default PDFCrossRefSection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}