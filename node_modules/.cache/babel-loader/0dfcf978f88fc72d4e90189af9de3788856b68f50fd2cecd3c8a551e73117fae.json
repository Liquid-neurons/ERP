{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar PDFHeader_1 = tslib_1.__importDefault(require(\"../document/PDFHeader\"));\nvar PDFTrailer_1 = tslib_1.__importDefault(require(\"../document/PDFTrailer\"));\nvar PDFInvalidObject_1 = tslib_1.__importDefault(require(\"../objects/PDFInvalidObject\"));\nvar PDFName_1 = tslib_1.__importDefault(require(\"../objects/PDFName\"));\nvar PDFNumber_1 = tslib_1.__importDefault(require(\"../objects/PDFNumber\"));\nvar PDFRef_1 = tslib_1.__importDefault(require(\"../objects/PDFRef\"));\nvar PDFStream_1 = tslib_1.__importDefault(require(\"../objects/PDFStream\"));\nvar PDFCrossRefStream_1 = tslib_1.__importDefault(require(\"../structures/PDFCrossRefStream\"));\nvar PDFObjectStream_1 = tslib_1.__importDefault(require(\"../structures/PDFObjectStream\"));\nvar PDFWriter_1 = tslib_1.__importDefault(require(\"./PDFWriter\"));\nvar utils_1 = require(\"../../utils\");\nvar PDFStreamWriter = /** @class */function (_super) {\n  tslib_1.__extends(PDFStreamWriter, _super);\n  function PDFStreamWriter(context, objectsPerTick, encodeStreams, objectsPerStream) {\n    var _this = _super.call(this, context, objectsPerTick) || this;\n    _this.encodeStreams = encodeStreams;\n    _this.objectsPerStream = objectsPerStream;\n    return _this;\n  }\n  PDFStreamWriter.prototype.computeBufferSize = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var objectNumber, header, size, xrefStream, uncompressedObjects, compressedObjects, objectStreamRefs, indirectObjects, idx, len, indirectObject, ref, object, shouldNotCompress, chunk, objectStreamRef, idx, len, chunk, ref, objectStream, xrefStreamRef, xrefOffset, trailer;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            objectNumber = this.context.largestObjectNumber + 1;\n            header = PDFHeader_1.default.forVersion(1, 7);\n            size = header.sizeInBytes() + 2;\n            xrefStream = PDFCrossRefStream_1.default.create(this.createTrailerDict(), this.encodeStreams);\n            uncompressedObjects = [];\n            compressedObjects = [];\n            objectStreamRefs = [];\n            indirectObjects = this.context.enumerateIndirectObjects();\n            idx = 0, len = indirectObjects.length;\n            _a.label = 1;\n          case 1:\n            if (!(idx < len)) return [3 /*break*/, 6];\n            indirectObject = indirectObjects[idx];\n            ref = indirectObject[0], object = indirectObject[1];\n            shouldNotCompress = ref === this.context.trailerInfo.Encrypt || object instanceof PDFStream_1.default || object instanceof PDFInvalidObject_1.default || ref.generationNumber !== 0;\n            if (!shouldNotCompress) return [3 /*break*/, 4];\n            uncompressedObjects.push(indirectObject);\n            xrefStream.addUncompressedEntry(ref, size);\n            size += this.computeIndirectObjectSize(indirectObject);\n            if (!this.shouldWaitForTick(1)) return [3 /*break*/, 3];\n            return [4 /*yield*/, utils_1.waitForTick()];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            return [3 /*break*/, 5];\n          case 4:\n            chunk = utils_1.last(compressedObjects);\n            objectStreamRef = utils_1.last(objectStreamRefs);\n            if (!chunk || chunk.length % this.objectsPerStream === 0) {\n              chunk = [];\n              compressedObjects.push(chunk);\n              objectStreamRef = PDFRef_1.default.of(objectNumber++);\n              objectStreamRefs.push(objectStreamRef);\n            }\n            xrefStream.addCompressedEntry(ref, objectStreamRef, chunk.length);\n            chunk.push(indirectObject);\n            _a.label = 5;\n          case 5:\n            idx++;\n            return [3 /*break*/, 1];\n          case 6:\n            idx = 0, len = compressedObjects.length;\n            _a.label = 7;\n          case 7:\n            if (!(idx < len)) return [3 /*break*/, 10];\n            chunk = compressedObjects[idx];\n            ref = objectStreamRefs[idx];\n            objectStream = PDFObjectStream_1.default.withContextAndObjects(this.context, chunk, this.encodeStreams);\n            xrefStream.addUncompressedEntry(ref, size);\n            size += this.computeIndirectObjectSize([ref, objectStream]);\n            uncompressedObjects.push([ref, objectStream]);\n            if (!this.shouldWaitForTick(chunk.length)) return [3 /*break*/, 9];\n            return [4 /*yield*/, utils_1.waitForTick()];\n          case 8:\n            _a.sent();\n            _a.label = 9;\n          case 9:\n            idx++;\n            return [3 /*break*/, 7];\n          case 10:\n            xrefStreamRef = PDFRef_1.default.of(objectNumber++);\n            xrefStream.dict.set(PDFName_1.default.of('Size'), PDFNumber_1.default.of(objectNumber));\n            xrefStream.addUncompressedEntry(xrefStreamRef, size);\n            xrefOffset = size;\n            size += this.computeIndirectObjectSize([xrefStreamRef, xrefStream]);\n            uncompressedObjects.push([xrefStreamRef, xrefStream]);\n            trailer = PDFTrailer_1.default.forLastCrossRefSectionOffset(xrefOffset);\n            size += trailer.sizeInBytes();\n            return [2 /*return*/, {\n              size: size,\n              header: header,\n              indirectObjects: uncompressedObjects,\n              trailer: trailer\n            }];\n        }\n      });\n    });\n  };\n  PDFStreamWriter.forContext = function (context, objectsPerTick, encodeStreams, objectsPerStream) {\n    if (encodeStreams === void 0) {\n      encodeStreams = true;\n    }\n    if (objectsPerStream === void 0) {\n      objectsPerStream = 50;\n    }\n    return new PDFStreamWriter(context, objectsPerTick, encodeStreams, objectsPerStream);\n  };\n  return PDFStreamWriter;\n}(PDFWriter_1.default);\nexports.default = PDFStreamWriter;","map":{"version":3,"names":["PDFHeader_1","tslib_1","__importDefault","require","PDFTrailer_1","PDFInvalidObject_1","PDFName_1","PDFNumber_1","PDFRef_1","PDFStream_1","PDFCrossRefStream_1","PDFObjectStream_1","PDFWriter_1","utils_1","PDFStreamWriter","_super","__extends","context","objectsPerTick","encodeStreams","objectsPerStream","_this","call","prototype","computeBufferSize","objectNumber","largestObjectNumber","header","default","forVersion","size","sizeInBytes","xrefStream","create","createTrailerDict","uncompressedObjects","compressedObjects","objectStreamRefs","indirectObjects","enumerateIndirectObjects","idx","len","length","indirectObject","ref","object","shouldNotCompress","trailerInfo","Encrypt","generationNumber","push","addUncompressedEntry","computeIndirectObjectSize","shouldWaitForTick","waitForTick","_a","sent","chunk","last","objectStreamRef","of","addCompressedEntry","objectStream","withContextAndObjects","xrefStreamRef","dict","set","xrefOffset","trailer","forLastCrossRefSectionOffset","forContext","exports"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/writers/PDFStreamWriter.ts"],"sourcesContent":["import PDFHeader from 'src/core/document/PDFHeader';\nimport PDFTrailer from 'src/core/document/PDFTrailer';\nimport PDFInvalidObject from 'src/core/objects/PDFInvalidObject';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFNumber from 'src/core/objects/PDFNumber';\nimport PDFObject from 'src/core/objects/PDFObject';\nimport PDFRef from 'src/core/objects/PDFRef';\nimport PDFStream from 'src/core/objects/PDFStream';\nimport PDFContext from 'src/core/PDFContext';\nimport PDFCrossRefStream from 'src/core/structures/PDFCrossRefStream';\nimport PDFObjectStream from 'src/core/structures/PDFObjectStream';\nimport PDFWriter from 'src/core/writers/PDFWriter';\nimport { last, waitForTick } from 'src/utils';\n\nclass PDFStreamWriter extends PDFWriter {\n  static forContext = (\n    context: PDFContext,\n    objectsPerTick: number,\n    encodeStreams = true,\n    objectsPerStream = 50,\n  ) =>\n    new PDFStreamWriter(\n      context,\n      objectsPerTick,\n      encodeStreams,\n      objectsPerStream,\n    );\n\n  private readonly encodeStreams: boolean;\n  private readonly objectsPerStream: number;\n\n  private constructor(\n    context: PDFContext,\n    objectsPerTick: number,\n    encodeStreams: boolean,\n    objectsPerStream: number,\n  ) {\n    super(context, objectsPerTick);\n\n    this.encodeStreams = encodeStreams;\n    this.objectsPerStream = objectsPerStream;\n  }\n\n  protected async computeBufferSize() {\n    let objectNumber = this.context.largestObjectNumber + 1;\n\n    const header = PDFHeader.forVersion(1, 7);\n\n    let size = header.sizeInBytes() + 2;\n\n    const xrefStream = PDFCrossRefStream.create(\n      this.createTrailerDict(),\n      this.encodeStreams,\n    );\n\n    const uncompressedObjects: [PDFRef, PDFObject][] = [];\n    const compressedObjects: [PDFRef, PDFObject][][] = [];\n    const objectStreamRefs: PDFRef[] = [];\n\n    const indirectObjects = this.context.enumerateIndirectObjects();\n    for (let idx = 0, len = indirectObjects.length; idx < len; idx++) {\n      const indirectObject = indirectObjects[idx];\n      const [ref, object] = indirectObject;\n\n      const shouldNotCompress =\n        ref === this.context.trailerInfo.Encrypt ||\n        object instanceof PDFStream ||\n        object instanceof PDFInvalidObject ||\n        ref.generationNumber !== 0;\n\n      if (shouldNotCompress) {\n        uncompressedObjects.push(indirectObject);\n        xrefStream.addUncompressedEntry(ref, size);\n        size += this.computeIndirectObjectSize(indirectObject);\n        if (this.shouldWaitForTick(1)) await waitForTick();\n      } else {\n        let chunk = last(compressedObjects);\n        let objectStreamRef = last(objectStreamRefs);\n        if (!chunk || chunk.length % this.objectsPerStream === 0) {\n          chunk = [];\n          compressedObjects.push(chunk);\n          objectStreamRef = PDFRef.of(objectNumber++);\n          objectStreamRefs.push(objectStreamRef);\n        }\n        xrefStream.addCompressedEntry(ref, objectStreamRef, chunk.length);\n        chunk.push(indirectObject);\n      }\n    }\n\n    for (let idx = 0, len = compressedObjects.length; idx < len; idx++) {\n      const chunk = compressedObjects[idx];\n      const ref = objectStreamRefs[idx];\n\n      const objectStream = PDFObjectStream.withContextAndObjects(\n        this.context,\n        chunk,\n        this.encodeStreams,\n      );\n\n      xrefStream.addUncompressedEntry(ref, size);\n      size += this.computeIndirectObjectSize([ref, objectStream]);\n\n      uncompressedObjects.push([ref, objectStream]);\n\n      if (this.shouldWaitForTick(chunk.length)) await waitForTick();\n    }\n\n    const xrefStreamRef = PDFRef.of(objectNumber++);\n    xrefStream.dict.set(PDFName.of('Size'), PDFNumber.of(objectNumber));\n    xrefStream.addUncompressedEntry(xrefStreamRef, size);\n    const xrefOffset = size;\n    size += this.computeIndirectObjectSize([xrefStreamRef, xrefStream]);\n\n    uncompressedObjects.push([xrefStreamRef, xrefStream]);\n\n    const trailer = PDFTrailer.forLastCrossRefSectionOffset(xrefOffset);\n    size += trailer.sizeInBytes();\n\n    return { size, header, indirectObjects: uncompressedObjects, trailer };\n  }\n}\n\nexport default PDFStreamWriter;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}