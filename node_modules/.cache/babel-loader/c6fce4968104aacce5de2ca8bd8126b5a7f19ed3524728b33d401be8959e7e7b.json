{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar PDFDocument_1 = tslib_1.__importDefault(require(\"../PDFDocument\"));\nvar PDFButton_1 = tslib_1.__importDefault(require(\"./PDFButton\"));\nvar PDFCheckBox_1 = tslib_1.__importDefault(require(\"./PDFCheckBox\"));\nvar PDFDropdown_1 = tslib_1.__importDefault(require(\"./PDFDropdown\"));\nvar PDFOptionList_1 = tslib_1.__importDefault(require(\"./PDFOptionList\"));\nvar PDFRadioGroup_1 = tslib_1.__importDefault(require(\"./PDFRadioGroup\"));\nvar PDFSignature_1 = tslib_1.__importDefault(require(\"./PDFSignature\"));\nvar PDFTextField_1 = tslib_1.__importDefault(require(\"./PDFTextField\"));\nvar errors_1 = require(\"../errors\");\nvar PDFFont_1 = tslib_1.__importDefault(require(\"../PDFFont\"));\nvar StandardFonts_1 = require(\"../StandardFonts\");\nvar operations_1 = require(\"../operations\");\nvar operators_1 = require(\"../operators\");\nvar core_1 = require(\"../../core\");\nvar utils_1 = require(\"../../utils\");\n/**\n * Represents the interactive form of a [[PDFDocument]].\n *\n * Interactive forms (sometimes called _AcroForms_) are collections of fields\n * designed to gather information from a user. A PDF document may contains any\n * number of fields that appear on various pages, all of which make up a single,\n * global interactive form spanning the entire document. This means that\n * instances of [[PDFDocument]] shall contain at most one [[PDFForm]].\n *\n * The fields of an interactive form are represented by [[PDFField]] instances.\n */\nvar PDFForm = /** @class */function () {\n  function PDFForm(acroForm, doc) {\n    var _this = this;\n    this.embedDefaultFont = function () {\n      return _this.doc.embedStandardFont(StandardFonts_1.StandardFonts.Helvetica);\n    };\n    utils_1.assertIs(acroForm, 'acroForm', [[core_1.PDFAcroForm, 'PDFAcroForm']]);\n    utils_1.assertIs(doc, 'doc', [[PDFDocument_1.default, 'PDFDocument']]);\n    this.acroForm = acroForm;\n    this.doc = doc;\n    this.dirtyFields = new Set();\n    this.defaultFontCache = utils_1.Cache.populatedBy(this.embedDefaultFont);\n  }\n  /**\n   * Returns `true` if this [[PDFForm]] has XFA data. Most PDFs with form\n   * fields do not use XFA as it is not widely supported by PDF readers.\n   *\n   * > `pdf-lib` does not support creation, modification, or reading of XFA\n   * > fields.\n   *\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * if (form.hasXFA()) console.log('PDF has XFA data')\n   * ```\n   * @returns Whether or not this form has XFA data.\n   */\n  PDFForm.prototype.hasXFA = function () {\n    return this.acroForm.dict.has(core_1.PDFName.of('XFA'));\n  };\n  /**\n   * Disconnect the XFA data from this [[PDFForm]] (if any exists). This will\n   * force readers to fallback to standard fields if the [[PDFDocument]]\n   * contains any. For example:\n   *\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * form.deleteXFA()\n   * ```\n   */\n  PDFForm.prototype.deleteXFA = function () {\n    this.acroForm.dict.delete(core_1.PDFName.of('XFA'));\n  };\n  /**\n   * Get all fields contained in this [[PDFForm]]. For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const fields = form.getFields()\n   * fields.forEach(field => {\n   *   const type = field.constructor.name\n   *   const name = field.getName()\n   *   console.log(`${type}: ${name}`)\n   * })\n   * ```\n   * @returns An array of all fields in this form.\n   */\n  PDFForm.prototype.getFields = function () {\n    var allFields = this.acroForm.getAllFields();\n    var fields = [];\n    for (var idx = 0, len = allFields.length; idx < len; idx++) {\n      var _a = allFields[idx],\n        acroField = _a[0],\n        ref = _a[1];\n      var field = convertToPDFField(acroField, ref, this.doc);\n      if (field) fields.push(field);\n    }\n    return fields;\n  };\n  /**\n   * Get the field in this [[PDFForm]] with the given name. For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const field = form.getFieldMaybe('Page1.Foo.Bar[0]')\n   * if (field) console.log('Field exists!')\n   * ```\n   * @param name A fully qualified field name.\n   * @returns The field with the specified name, if one exists.\n   */\n  PDFForm.prototype.getFieldMaybe = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var fields = this.getFields();\n    for (var idx = 0, len = fields.length; idx < len; idx++) {\n      var field = fields[idx];\n      if (field.getName() === name) return field;\n    }\n    return undefined;\n  };\n  /**\n   * Get the field in this [[PDFForm]] with the given name. For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const field = form.getField('Page1.Foo.Bar[0]')\n   * ```\n   * If no field exists with the provided name, an error will be thrown.\n   * @param name A fully qualified field name.\n   * @returns The field with the specified name.\n   */\n  PDFForm.prototype.getField = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var field = this.getFieldMaybe(name);\n    if (field) return field;\n    throw new errors_1.NoSuchFieldError(name);\n  };\n  /**\n   * Get the button field in this [[PDFForm]] with the given name. For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const button = form.getButton('Page1.Foo.Button[0]')\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not a button.\n   * @param name A fully qualified button name.\n   * @returns The button with the specified name.\n   */\n  PDFForm.prototype.getButton = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var field = this.getField(name);\n    if (field instanceof PDFButton_1.default) return field;\n    throw new errors_1.UnexpectedFieldTypeError(name, PDFButton_1.default, field);\n  };\n  /**\n   * Get the check box field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const checkBox = form.getCheckBox('Page1.Foo.CheckBox[0]')\n   * checkBox.check()\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not a check box.\n   * @param name A fully qualified check box name.\n   * @returns The check box with the specified name.\n   */\n  PDFForm.prototype.getCheckBox = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var field = this.getField(name);\n    if (field instanceof PDFCheckBox_1.default) return field;\n    throw new errors_1.UnexpectedFieldTypeError(name, PDFCheckBox_1.default, field);\n  };\n  /**\n   * Get the dropdown field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const dropdown = form.getDropdown('Page1.Foo.Dropdown[0]')\n   * const options = dropdown.getOptions()\n   * dropdown.select(options[0])\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not a dropdown.\n   * @param name A fully qualified dropdown name.\n   * @returns The dropdown with the specified name.\n   */\n  PDFForm.prototype.getDropdown = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var field = this.getField(name);\n    if (field instanceof PDFDropdown_1.default) return field;\n    throw new errors_1.UnexpectedFieldTypeError(name, PDFDropdown_1.default, field);\n  };\n  /**\n   * Get the option list field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const optionList = form.getOptionList('Page1.Foo.OptionList[0]')\n   * const options = optionList.getOptions()\n   * optionList.select(options[0])\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not an option list.\n   * @param name A fully qualified option list name.\n   * @returns The option list with the specified name.\n   */\n  PDFForm.prototype.getOptionList = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var field = this.getField(name);\n    if (field instanceof PDFOptionList_1.default) return field;\n    throw new errors_1.UnexpectedFieldTypeError(name, PDFOptionList_1.default, field);\n  };\n  /**\n   * Get the radio group field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const radioGroup = form.getRadioGroup('Page1.Foo.RadioGroup[0]')\n   * const options = radioGroup.getOptions()\n   * radioGroup.select(options[0])\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not a radio group.\n   * @param name A fully qualified radio group name.\n   * @returns The radio group with the specified name.\n   */\n  PDFForm.prototype.getRadioGroup = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var field = this.getField(name);\n    if (field instanceof PDFRadioGroup_1.default) return field;\n    throw new errors_1.UnexpectedFieldTypeError(name, PDFRadioGroup_1.default, field);\n  };\n  /**\n   * Get the signature field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const signature = form.getSignature('Page1.Foo.Signature[0]')\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not a signature.\n   * @param name A fully qualified signature name.\n   * @returns The signature with the specified name.\n   */\n  PDFForm.prototype.getSignature = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var field = this.getField(name);\n    if (field instanceof PDFSignature_1.default) return field;\n    throw new errors_1.UnexpectedFieldTypeError(name, PDFSignature_1.default, field);\n  };\n  /**\n   * Get the text field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const textField = form.getTextField('Page1.Foo.TextField[0]')\n   * textField.setText('Are you designed to act or to be acted upon?')\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not a text field.\n   * @param name A fully qualified text field name.\n   * @returns The text field with the specified name.\n   */\n  PDFForm.prototype.getTextField = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var field = this.getField(name);\n    if (field instanceof PDFTextField_1.default) return field;\n    throw new errors_1.UnexpectedFieldTypeError(name, PDFTextField_1.default, field);\n  };\n  /**\n   * Create a new button field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const button = form.createButton('cool.new.button')\n   *\n   * button.addToPage('Do Stuff', font, page)\n   * ```\n   * An error will be thrown if a field already exists with the provided name.\n   * @param name The fully qualified name for the new button.\n   * @returns The new button field.\n   */\n  PDFForm.prototype.createButton = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var nameParts = splitFieldName(name);\n    var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);\n    var button = core_1.PDFAcroPushButton.create(this.doc.context);\n    button.setPartialName(nameParts.terminal);\n    addFieldToParent(parent, [button, button.ref], nameParts.terminal);\n    return PDFButton_1.default.of(button, button.ref, this.doc);\n  };\n  /**\n   * Create a new check box field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const checkBox = form.createCheckBox('cool.new.checkBox')\n   *\n   * checkBox.addToPage(page)\n   * ```\n   * An error will be thrown if a field already exists with the provided name.\n   * @param name The fully qualified name for the new check box.\n   * @returns The new check box field.\n   */\n  PDFForm.prototype.createCheckBox = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var nameParts = splitFieldName(name);\n    var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);\n    var checkBox = core_1.PDFAcroCheckBox.create(this.doc.context);\n    checkBox.setPartialName(nameParts.terminal);\n    addFieldToParent(parent, [checkBox, checkBox.ref], nameParts.terminal);\n    return PDFCheckBox_1.default.of(checkBox, checkBox.ref, this.doc);\n  };\n  /**\n   * Create a new dropdown field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const dropdown = form.createDropdown('cool.new.dropdown')\n   *\n   * dropdown.addToPage(font, page)\n   * ```\n   * An error will be thrown if a field already exists with the provided name.\n   * @param name The fully qualified name for the new dropdown.\n   * @returns The new dropdown field.\n   */\n  PDFForm.prototype.createDropdown = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var nameParts = splitFieldName(name);\n    var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);\n    var comboBox = core_1.PDFAcroComboBox.create(this.doc.context);\n    comboBox.setPartialName(nameParts.terminal);\n    addFieldToParent(parent, [comboBox, comboBox.ref], nameParts.terminal);\n    return PDFDropdown_1.default.of(comboBox, comboBox.ref, this.doc);\n  };\n  /**\n   * Create a new option list field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const optionList = form.createOptionList('cool.new.optionList')\n   *\n   * optionList.addToPage(font, page)\n   * ```\n   * An error will be thrown if a field already exists with the provided name.\n   * @param name The fully qualified name for the new option list.\n   * @returns The new option list field.\n   */\n  PDFForm.prototype.createOptionList = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var nameParts = splitFieldName(name);\n    var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);\n    var listBox = core_1.PDFAcroListBox.create(this.doc.context);\n    listBox.setPartialName(nameParts.terminal);\n    addFieldToParent(parent, [listBox, listBox.ref], nameParts.terminal);\n    return PDFOptionList_1.default.of(listBox, listBox.ref, this.doc);\n  };\n  /**\n   * Create a new radio group field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const radioGroup = form.createRadioGroup('cool.new.radioGroup')\n   *\n   * radioGroup.addOptionToPage('is-dog', page, { y: 0 })\n   * radioGroup.addOptionToPage('is-cat', page, { y: 75 })\n   * ```\n   * An error will be thrown if a field already exists with the provided name.\n   * @param name The fully qualified name for the new radio group.\n   * @returns The new radio group field.\n   */\n  PDFForm.prototype.createRadioGroup = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var nameParts = splitFieldName(name);\n    var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);\n    var radioButton = core_1.PDFAcroRadioButton.create(this.doc.context);\n    radioButton.setPartialName(nameParts.terminal);\n    addFieldToParent(parent, [radioButton, radioButton.ref], nameParts.terminal);\n    return PDFRadioGroup_1.default.of(radioButton, radioButton.ref, this.doc);\n  };\n  /**\n   * Create a new text field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const textField = form.createTextField('cool.new.textField')\n   *\n   * textField.addToPage(font, page)\n   * ```\n   * An error will be thrown if a field already exists with the provided name.\n   * @param name The fully qualified name for the new radio group.\n   * @returns The new radio group field.\n   */\n  PDFForm.prototype.createTextField = function (name) {\n    utils_1.assertIs(name, 'name', ['string']);\n    var nameParts = splitFieldName(name);\n    var parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);\n    var text = core_1.PDFAcroText.create(this.doc.context);\n    text.setPartialName(nameParts.terminal);\n    addFieldToParent(parent, [text, text.ref], nameParts.terminal);\n    return PDFTextField_1.default.of(text, text.ref, this.doc);\n  };\n  /**\n   * Flatten all fields in this [[PDFForm]].\n   *\n   * Flattening a form field will take the current appearance for each of that\n   * field's widgets and make them part of their page's content stream. All form\n   * fields and annotations associated are then removed. Note that once a form\n   * has been flattened its fields can no longer be accessed or edited.\n   *\n   * This operation is often used after filling form fields to ensure a\n   * consistent appearance across different PDF readers and/or printers.\n   * Another common use case is to copy a template document with form fields\n   * into another document. In this scenario you would load the template\n   * document, fill its fields, flatten it, and then copy its pages into the\n   * recipient document - the filled fields will be copied over.\n   *\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm();\n   * form.flatten();\n   * ```\n   */\n  PDFForm.prototype.flatten = function (options) {\n    if (options === void 0) {\n      options = {\n        updateFieldAppearances: true\n      };\n    }\n    if (options.updateFieldAppearances) {\n      this.updateFieldAppearances();\n    }\n    var fields = this.getFields();\n    for (var i = 0, lenFields = fields.length; i < lenFields; i++) {\n      var field = fields[i];\n      var widgets = field.acroField.getWidgets();\n      for (var j = 0, lenWidgets = widgets.length; j < lenWidgets; j++) {\n        var widget = widgets[j];\n        var page = this.findWidgetPage(widget);\n        var widgetRef = this.findWidgetAppearanceRef(field, widget);\n        var xObjectKey = page.node.newXObject('FlatWidget', widgetRef);\n        var rectangle = widget.getRectangle();\n        var operators = tslib_1.__spreadArrays([operators_1.pushGraphicsState(), operators_1.translate(rectangle.x, rectangle.y)], operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), {\n          rotation: 0\n        })), [operators_1.drawObject(xObjectKey), operators_1.popGraphicsState()]).filter(Boolean);\n        page.pushOperators.apply(page, operators);\n      }\n      this.removeField(field);\n    }\n  };\n  /**\n   * Remove a field from this [[PDFForm]].\n   *\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm();\n   * const ageField = form.getFields().find(x => x.getName() === 'Age');\n   * form.removeField(ageField);\n   * ```\n   */\n  PDFForm.prototype.removeField = function (field) {\n    var widgets = field.acroField.getWidgets();\n    var pages = new Set();\n    for (var i = 0, len = widgets.length; i < len; i++) {\n      var widget = widgets[i];\n      var widgetRef = this.findWidgetAppearanceRef(field, widget);\n      var page = this.findWidgetPage(widget);\n      pages.add(page);\n      page.node.removeAnnot(widgetRef);\n    }\n    pages.forEach(function (page) {\n      return page.node.removeAnnot(field.ref);\n    });\n    this.acroForm.removeField(field.acroField);\n    var fieldKids = field.acroField.normalizedEntries().Kids;\n    var kidsCount = fieldKids.size();\n    for (var childIndex = 0; childIndex < kidsCount; childIndex++) {\n      var child = fieldKids.get(childIndex);\n      if (child instanceof core_1.PDFRef) {\n        this.doc.context.delete(child);\n      }\n    }\n    this.doc.context.delete(field.ref);\n  };\n  /**\n   * Update the appearance streams for all widgets of all fields in this\n   * [[PDFForm]]. Appearance streams will only be created for a widget if it\n   * does not have any existing appearance streams, or the field's value has\n   * changed (e.g. by calling [[PDFTextField.setText]] or\n   * [[PDFDropdown.select]]).\n   *\n   * For example:\n   * ```js\n   * const courier = await pdfDoc.embedFont(StandardFonts.Courier)\n   * const form = pdfDoc.getForm()\n   * form.updateFieldAppearances(courier)\n   * ```\n   *\n   * **IMPORTANT:** The default value for the `font` parameter is\n   * [[StandardFonts.Helvetica]]. Note that this is a WinAnsi font. This means\n   * that encoding errors will be thrown if any fields contain text with\n   * characters outside the WinAnsi character set (the latin alphabet).\n   *\n   * Embedding a custom font and passing that as the `font`\n   * parameter allows you to generate appearance streams with non WinAnsi\n   * characters (assuming your custom font supports them).\n   *\n   * > **NOTE:** The [[PDFDocument.save]] method will call this method to\n   * > update appearances automatically if a form was accessed via the\n   * > [[PDFDocument.getForm]] method prior to saving.\n   *\n   * @param font Optionally, the font to use when creating new appearances.\n   */\n  PDFForm.prototype.updateFieldAppearances = function (font) {\n    utils_1.assertOrUndefined(font, 'font', [[PDFFont_1.default, 'PDFFont']]);\n    font = font !== null && font !== void 0 ? font : this.getDefaultFont();\n    var fields = this.getFields();\n    for (var idx = 0, len = fields.length; idx < len; idx++) {\n      var field = fields[idx];\n      if (field.needsAppearancesUpdate()) {\n        field.defaultUpdateAppearances(font);\n      }\n    }\n  };\n  /**\n   * Mark a field as dirty. This will cause its appearance streams to be\n   * updated by [[PDFForm.updateFieldAppearances]].\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const field = form.getField('foo.bar')\n   * form.markFieldAsDirty(field.ref)\n   * ```\n   * @param fieldRef The reference to the field that should be marked.\n   */\n  PDFForm.prototype.markFieldAsDirty = function (fieldRef) {\n    utils_1.assertOrUndefined(fieldRef, 'fieldRef', [[core_1.PDFRef, 'PDFRef']]);\n    this.dirtyFields.add(fieldRef);\n  };\n  /**\n   * Mark a field as dirty. This will cause its appearance streams to not be\n   * updated by [[PDFForm.updateFieldAppearances]].\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const field = form.getField('foo.bar')\n   * form.markFieldAsClean(field.ref)\n   * ```\n   * @param fieldRef The reference to the field that should be marked.\n   */\n  PDFForm.prototype.markFieldAsClean = function (fieldRef) {\n    utils_1.assertOrUndefined(fieldRef, 'fieldRef', [[core_1.PDFRef, 'PDFRef']]);\n    this.dirtyFields.delete(fieldRef);\n  };\n  /**\n   * Returns `true` is the specified field has been marked as dirty.\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const field = form.getField('foo.bar')\n   * if (form.fieldIsDirty(field.ref)) console.log('Field is dirty')\n   * ```\n   * @param fieldRef The reference to the field that should be checked.\n   * @returns Whether or not the specified field is dirty.\n   */\n  PDFForm.prototype.fieldIsDirty = function (fieldRef) {\n    utils_1.assertOrUndefined(fieldRef, 'fieldRef', [[core_1.PDFRef, 'PDFRef']]);\n    return this.dirtyFields.has(fieldRef);\n  };\n  PDFForm.prototype.getDefaultFont = function () {\n    return this.defaultFontCache.access();\n  };\n  PDFForm.prototype.findWidgetPage = function (widget) {\n    var pageRef = widget.P();\n    var page = this.doc.getPages().find(function (x) {\n      return x.ref === pageRef;\n    });\n    if (page === undefined) {\n      var widgetRef = this.doc.context.getObjectRef(widget.dict);\n      if (widgetRef === undefined) {\n        throw new Error('Could not find PDFRef for PDFObject');\n      }\n      page = this.doc.findPageForAnnotationRef(widgetRef);\n      if (page === undefined) {\n        throw new Error(\"Could not find page for PDFRef \" + widgetRef);\n      }\n    }\n    return page;\n  };\n  PDFForm.prototype.findWidgetAppearanceRef = function (field, widget) {\n    var _a;\n    var refOrDict = widget.getNormalAppearance();\n    if (refOrDict instanceof core_1.PDFDict && (field instanceof PDFCheckBox_1.default || field instanceof PDFRadioGroup_1.default)) {\n      var value = field.acroField.getValue();\n      var ref = (_a = refOrDict.get(value)) !== null && _a !== void 0 ? _a : refOrDict.get(core_1.PDFName.of('Off'));\n      if (ref instanceof core_1.PDFRef) {\n        refOrDict = ref;\n      }\n    }\n    if (!(refOrDict instanceof core_1.PDFRef)) {\n      var name_1 = field.getName();\n      throw new Error(\"Failed to extract appearance ref for: \" + name_1);\n    }\n    return refOrDict;\n  };\n  PDFForm.prototype.findOrCreateNonTerminals = function (partialNames) {\n    var nonTerminal = [this.acroForm];\n    for (var idx = 0, len = partialNames.length; idx < len; idx++) {\n      var namePart = partialNames[idx];\n      if (!namePart) throw new errors_1.InvalidFieldNamePartError(namePart);\n      var parent_1 = nonTerminal[0],\n        parentRef = nonTerminal[1];\n      var res = this.findNonTerminal(namePart, parent_1);\n      if (res) {\n        nonTerminal = res;\n      } else {\n        var node = core_1.PDFAcroNonTerminal.create(this.doc.context);\n        node.setPartialName(namePart);\n        node.setParent(parentRef);\n        var nodeRef = this.doc.context.register(node.dict);\n        parent_1.addField(nodeRef);\n        nonTerminal = [node, nodeRef];\n      }\n    }\n    return nonTerminal;\n  };\n  PDFForm.prototype.findNonTerminal = function (partialName, parent) {\n    var fields = parent instanceof core_1.PDFAcroForm ? this.acroForm.getFields() : core_1.createPDFAcroFields(parent.Kids());\n    for (var idx = 0, len = fields.length; idx < len; idx++) {\n      var _a = fields[idx],\n        field = _a[0],\n        ref = _a[1];\n      if (field.getPartialName() === partialName) {\n        if (field instanceof core_1.PDFAcroNonTerminal) return [field, ref];\n        throw new errors_1.FieldAlreadyExistsError(partialName);\n      }\n    }\n    return undefined;\n  };\n  /**\n   * > **NOTE:** You probably don't want to call this method directly. Instead,\n   * > consider using the [[PDFDocument.getForm]] method, which will create an\n   * > instance of [[PDFForm]] for you.\n   *\n   * Create an instance of [[PDFForm]] from an existing acroForm and embedder\n   *\n   * @param acroForm The underlying `PDFAcroForm` for this form.\n   * @param doc The document to which the form will belong.\n   */\n  PDFForm.of = function (acroForm, doc) {\n    return new PDFForm(acroForm, doc);\n  };\n  return PDFForm;\n}();\nexports.default = PDFForm;\nvar convertToPDFField = function (field, ref, doc) {\n  if (field instanceof core_1.PDFAcroPushButton) return PDFButton_1.default.of(field, ref, doc);\n  if (field instanceof core_1.PDFAcroCheckBox) return PDFCheckBox_1.default.of(field, ref, doc);\n  if (field instanceof core_1.PDFAcroComboBox) return PDFDropdown_1.default.of(field, ref, doc);\n  if (field instanceof core_1.PDFAcroListBox) return PDFOptionList_1.default.of(field, ref, doc);\n  if (field instanceof core_1.PDFAcroText) return PDFTextField_1.default.of(field, ref, doc);\n  if (field instanceof core_1.PDFAcroRadioButton) {\n    return PDFRadioGroup_1.default.of(field, ref, doc);\n  }\n  if (field instanceof core_1.PDFAcroSignature) {\n    return PDFSignature_1.default.of(field, ref, doc);\n  }\n  return undefined;\n};\nvar splitFieldName = function (fullyQualifiedName) {\n  if (fullyQualifiedName.length === 0) {\n    throw new Error('PDF field names must not be empty strings');\n  }\n  var parts = fullyQualifiedName.split('.');\n  for (var idx = 0, len = parts.length; idx < len; idx++) {\n    if (parts[idx] === '') {\n      throw new Error(\"Periods in PDF field names must be separated by at least one character: \\\"\" + fullyQualifiedName + \"\\\"\");\n    }\n  }\n  if (parts.length === 1) return {\n    nonTerminal: [],\n    terminal: parts[0]\n  };\n  return {\n    nonTerminal: parts.slice(0, parts.length - 1),\n    terminal: parts[parts.length - 1]\n  };\n};\nvar addFieldToParent = function (_a, _b, partialName) {\n  var parent = _a[0],\n    parentRef = _a[1];\n  var field = _b[0],\n    fieldRef = _b[1];\n  var entries = parent.normalizedEntries();\n  var fields = core_1.createPDFAcroFields('Kids' in entries ? entries.Kids : entries.Fields);\n  for (var idx = 0, len = fields.length; idx < len; idx++) {\n    if (fields[idx][0].getPartialName() === partialName) {\n      throw new errors_1.FieldAlreadyExistsError(partialName);\n    }\n  }\n  parent.addField(fieldRef);\n  field.setParent(parentRef);\n};","map":{"version":3,"names":["PDFDocument_1","tslib_1","__importDefault","require","PDFButton_1","PDFCheckBox_1","PDFDropdown_1","PDFOptionList_1","PDFRadioGroup_1","PDFSignature_1","PDFTextField_1","errors_1","PDFFont_1","StandardFonts_1","operations_1","operators_1","core_1","utils_1","PDFForm","acroForm","doc","_this","embedDefaultFont","embedStandardFont","StandardFonts","Helvetica","assertIs","PDFAcroForm","default","dirtyFields","Set","defaultFontCache","Cache","populatedBy","prototype","hasXFA","dict","has","PDFName","of","deleteXFA","delete","getFields","allFields","getAllFields","fields","idx","len","length","_a","acroField","ref","field","convertToPDFField","push","getFieldMaybe","name","getName","undefined","getField","NoSuchFieldError","getButton","UnexpectedFieldTypeError","getCheckBox","getDropdown","getOptionList","getRadioGroup","getSignature","getTextField","createButton","nameParts","splitFieldName","parent","findOrCreateNonTerminals","nonTerminal","button","PDFAcroPushButton","create","context","setPartialName","terminal","addFieldToParent","createCheckBox","checkBox","PDFAcroCheckBox","createDropdown","comboBox","PDFAcroComboBox","createOptionList","listBox","PDFAcroListBox","createRadioGroup","radioButton","PDFAcroRadioButton","createTextField","text","PDFAcroText","flatten","options","updateFieldAppearances","i","lenFields","widgets","getWidgets","j","lenWidgets","widget","page","findWidgetPage","widgetRef","findWidgetAppearanceRef","xObjectKey","node","newXObject","rectangle","getRectangle","operators","__spreadArrays","pushGraphicsState","translate","x","y","rotateInPlace","__assign","rotation","drawObject","popGraphicsState","filter","Boolean","pushOperators","apply","removeField","pages","add","removeAnnot","forEach","fieldKids","normalizedEntries","Kids","kidsCount","size","childIndex","child","get","PDFRef","font","assertOrUndefined","getDefaultFont","needsAppearancesUpdate","defaultUpdateAppearances","markFieldAsDirty","fieldRef","markFieldAsClean","fieldIsDirty","access","pageRef","P","getPages","find","getObjectRef","Error","findPageForAnnotationRef","refOrDict","getNormalAppearance","PDFDict","value","getValue","name_1","partialNames","namePart","InvalidFieldNamePartError","parent_1","parentRef","res","findNonTerminal","PDFAcroNonTerminal","setParent","nodeRef","register","addField","partialName","createPDFAcroFields","getPartialName","FieldAlreadyExistsError","PDFAcroSignature","fullyQualifiedName","parts","split","slice","_b","entries","Fields"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/api/form/PDFForm.ts"],"sourcesContent":["import PDFDocument from 'src/api/PDFDocument';\nimport PDFPage from 'src/api/PDFPage';\nimport PDFField from 'src/api/form/PDFField';\nimport PDFButton from 'src/api/form/PDFButton';\nimport PDFCheckBox from 'src/api/form/PDFCheckBox';\nimport PDFDropdown from 'src/api/form/PDFDropdown';\nimport PDFOptionList from 'src/api/form/PDFOptionList';\nimport PDFRadioGroup from 'src/api/form/PDFRadioGroup';\nimport PDFSignature from 'src/api/form/PDFSignature';\nimport PDFTextField from 'src/api/form/PDFTextField';\nimport {\n  NoSuchFieldError,\n  UnexpectedFieldTypeError,\n  FieldAlreadyExistsError,\n  InvalidFieldNamePartError,\n} from 'src/api/errors';\nimport PDFFont from 'src/api/PDFFont';\nimport { StandardFonts } from 'src/api/StandardFonts';\nimport { rotateInPlace } from 'src/api/operations';\nimport {\n  drawObject,\n  popGraphicsState,\n  pushGraphicsState,\n  translate,\n} from 'src/api/operators';\nimport {\n  PDFAcroForm,\n  PDFAcroField,\n  PDFAcroCheckBox,\n  PDFAcroComboBox,\n  PDFAcroListBox,\n  PDFAcroRadioButton,\n  PDFAcroSignature,\n  PDFAcroText,\n  PDFAcroPushButton,\n  PDFAcroNonTerminal,\n  PDFDict,\n  PDFOperator,\n  PDFRef,\n  createPDFAcroFields,\n  PDFName,\n  PDFWidgetAnnotation,\n} from 'src/core';\nimport { assertIs, Cache, assertOrUndefined } from 'src/utils';\n\nexport interface FlattenOptions {\n  updateFieldAppearances: boolean;\n}\n\n/**\n * Represents the interactive form of a [[PDFDocument]].\n *\n * Interactive forms (sometimes called _AcroForms_) are collections of fields\n * designed to gather information from a user. A PDF document may contains any\n * number of fields that appear on various pages, all of which make up a single,\n * global interactive form spanning the entire document. This means that\n * instances of [[PDFDocument]] shall contain at most one [[PDFForm]].\n *\n * The fields of an interactive form are represented by [[PDFField]] instances.\n */\nexport default class PDFForm {\n  /**\n   * > **NOTE:** You probably don't want to call this method directly. Instead,\n   * > consider using the [[PDFDocument.getForm]] method, which will create an\n   * > instance of [[PDFForm]] for you.\n   *\n   * Create an instance of [[PDFForm]] from an existing acroForm and embedder\n   *\n   * @param acroForm The underlying `PDFAcroForm` for this form.\n   * @param doc The document to which the form will belong.\n   */\n  static of = (acroForm: PDFAcroForm, doc: PDFDocument) =>\n    new PDFForm(acroForm, doc);\n\n  /** The low-level PDFAcroForm wrapped by this form. */\n  readonly acroForm: PDFAcroForm;\n\n  /** The document to which this form belongs. */\n  readonly doc: PDFDocument;\n\n  private readonly dirtyFields: Set<PDFRef>;\n  private readonly defaultFontCache: Cache<PDFFont>;\n\n  private constructor(acroForm: PDFAcroForm, doc: PDFDocument) {\n    assertIs(acroForm, 'acroForm', [[PDFAcroForm, 'PDFAcroForm']]);\n    assertIs(doc, 'doc', [[PDFDocument, 'PDFDocument']]);\n\n    this.acroForm = acroForm;\n    this.doc = doc;\n\n    this.dirtyFields = new Set();\n    this.defaultFontCache = Cache.populatedBy(this.embedDefaultFont);\n  }\n\n  /**\n   * Returns `true` if this [[PDFForm]] has XFA data. Most PDFs with form\n   * fields do not use XFA as it is not widely supported by PDF readers.\n   *\n   * > `pdf-lib` does not support creation, modification, or reading of XFA\n   * > fields.\n   *\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * if (form.hasXFA()) console.log('PDF has XFA data')\n   * ```\n   * @returns Whether or not this form has XFA data.\n   */\n  hasXFA(): boolean {\n    return this.acroForm.dict.has(PDFName.of('XFA'));\n  }\n\n  /**\n   * Disconnect the XFA data from this [[PDFForm]] (if any exists). This will\n   * force readers to fallback to standard fields if the [[PDFDocument]]\n   * contains any. For example:\n   *\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * form.deleteXFA()\n   * ```\n   */\n  deleteXFA(): void {\n    this.acroForm.dict.delete(PDFName.of('XFA'));\n  }\n\n  /**\n   * Get all fields contained in this [[PDFForm]]. For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const fields = form.getFields()\n   * fields.forEach(field => {\n   *   const type = field.constructor.name\n   *   const name = field.getName()\n   *   console.log(`${type}: ${name}`)\n   * })\n   * ```\n   * @returns An array of all fields in this form.\n   */\n  getFields(): PDFField[] {\n    const allFields = this.acroForm.getAllFields();\n\n    const fields: PDFField[] = [];\n    for (let idx = 0, len = allFields.length; idx < len; idx++) {\n      const [acroField, ref] = allFields[idx];\n      const field = convertToPDFField(acroField, ref, this.doc);\n      if (field) fields.push(field);\n    }\n\n    return fields;\n  }\n\n  /**\n   * Get the field in this [[PDFForm]] with the given name. For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const field = form.getFieldMaybe('Page1.Foo.Bar[0]')\n   * if (field) console.log('Field exists!')\n   * ```\n   * @param name A fully qualified field name.\n   * @returns The field with the specified name, if one exists.\n   */\n  getFieldMaybe(name: string): PDFField | undefined {\n    assertIs(name, 'name', ['string']);\n    const fields = this.getFields();\n    for (let idx = 0, len = fields.length; idx < len; idx++) {\n      const field = fields[idx];\n      if (field.getName() === name) return field;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the field in this [[PDFForm]] with the given name. For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const field = form.getField('Page1.Foo.Bar[0]')\n   * ```\n   * If no field exists with the provided name, an error will be thrown.\n   * @param name A fully qualified field name.\n   * @returns The field with the specified name.\n   */\n  getField(name: string): PDFField {\n    assertIs(name, 'name', ['string']);\n    const field = this.getFieldMaybe(name);\n    if (field) return field;\n    throw new NoSuchFieldError(name);\n  }\n\n  /**\n   * Get the button field in this [[PDFForm]] with the given name. For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const button = form.getButton('Page1.Foo.Button[0]')\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not a button.\n   * @param name A fully qualified button name.\n   * @returns The button with the specified name.\n   */\n  getButton(name: string): PDFButton {\n    assertIs(name, 'name', ['string']);\n    const field = this.getField(name);\n    if (field instanceof PDFButton) return field;\n    throw new UnexpectedFieldTypeError(name, PDFButton, field);\n  }\n\n  /**\n   * Get the check box field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const checkBox = form.getCheckBox('Page1.Foo.CheckBox[0]')\n   * checkBox.check()\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not a check box.\n   * @param name A fully qualified check box name.\n   * @returns The check box with the specified name.\n   */\n  getCheckBox(name: string): PDFCheckBox {\n    assertIs(name, 'name', ['string']);\n    const field = this.getField(name);\n    if (field instanceof PDFCheckBox) return field;\n    throw new UnexpectedFieldTypeError(name, PDFCheckBox, field);\n  }\n\n  /**\n   * Get the dropdown field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const dropdown = form.getDropdown('Page1.Foo.Dropdown[0]')\n   * const options = dropdown.getOptions()\n   * dropdown.select(options[0])\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not a dropdown.\n   * @param name A fully qualified dropdown name.\n   * @returns The dropdown with the specified name.\n   */\n  getDropdown(name: string): PDFDropdown {\n    assertIs(name, 'name', ['string']);\n    const field = this.getField(name);\n    if (field instanceof PDFDropdown) return field;\n    throw new UnexpectedFieldTypeError(name, PDFDropdown, field);\n  }\n\n  /**\n   * Get the option list field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const optionList = form.getOptionList('Page1.Foo.OptionList[0]')\n   * const options = optionList.getOptions()\n   * optionList.select(options[0])\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not an option list.\n   * @param name A fully qualified option list name.\n   * @returns The option list with the specified name.\n   */\n  getOptionList(name: string): PDFOptionList {\n    assertIs(name, 'name', ['string']);\n    const field = this.getField(name);\n    if (field instanceof PDFOptionList) return field;\n    throw new UnexpectedFieldTypeError(name, PDFOptionList, field);\n  }\n\n  /**\n   * Get the radio group field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const radioGroup = form.getRadioGroup('Page1.Foo.RadioGroup[0]')\n   * const options = radioGroup.getOptions()\n   * radioGroup.select(options[0])\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not a radio group.\n   * @param name A fully qualified radio group name.\n   * @returns The radio group with the specified name.\n   */\n  getRadioGroup(name: string): PDFRadioGroup {\n    assertIs(name, 'name', ['string']);\n    const field = this.getField(name);\n    if (field instanceof PDFRadioGroup) return field;\n    throw new UnexpectedFieldTypeError(name, PDFRadioGroup, field);\n  }\n\n  /**\n   * Get the signature field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const signature = form.getSignature('Page1.Foo.Signature[0]')\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not a signature.\n   * @param name A fully qualified signature name.\n   * @returns The signature with the specified name.\n   */\n  getSignature(name: string): PDFSignature {\n    assertIs(name, 'name', ['string']);\n    const field = this.getField(name);\n    if (field instanceof PDFSignature) return field;\n    throw new UnexpectedFieldTypeError(name, PDFSignature, field);\n  }\n\n  /**\n   * Get the text field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const textField = form.getTextField('Page1.Foo.TextField[0]')\n   * textField.setText('Are you designed to act or to be acted upon?')\n   * ```\n   * An error will be thrown if no field exists with the provided name, or if\n   * the field exists but is not a text field.\n   * @param name A fully qualified text field name.\n   * @returns The text field with the specified name.\n   */\n  getTextField(name: string): PDFTextField {\n    assertIs(name, 'name', ['string']);\n    const field = this.getField(name);\n    if (field instanceof PDFTextField) return field;\n    throw new UnexpectedFieldTypeError(name, PDFTextField, field);\n  }\n\n  /**\n   * Create a new button field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const button = form.createButton('cool.new.button')\n   *\n   * button.addToPage('Do Stuff', font, page)\n   * ```\n   * An error will be thrown if a field already exists with the provided name.\n   * @param name The fully qualified name for the new button.\n   * @returns The new button field.\n   */\n  createButton(name: string): PDFButton {\n    assertIs(name, 'name', ['string']);\n\n    const nameParts = splitFieldName(name);\n    const parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);\n\n    const button = PDFAcroPushButton.create(this.doc.context);\n    button.setPartialName(nameParts.terminal);\n\n    addFieldToParent(parent, [button, button.ref], nameParts.terminal);\n\n    return PDFButton.of(button, button.ref, this.doc);\n  }\n\n  /**\n   * Create a new check box field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const checkBox = form.createCheckBox('cool.new.checkBox')\n   *\n   * checkBox.addToPage(page)\n   * ```\n   * An error will be thrown if a field already exists with the provided name.\n   * @param name The fully qualified name for the new check box.\n   * @returns The new check box field.\n   */\n  createCheckBox(name: string): PDFCheckBox {\n    assertIs(name, 'name', ['string']);\n\n    const nameParts = splitFieldName(name);\n    const parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);\n\n    const checkBox = PDFAcroCheckBox.create(this.doc.context);\n    checkBox.setPartialName(nameParts.terminal);\n\n    addFieldToParent(parent, [checkBox, checkBox.ref], nameParts.terminal);\n\n    return PDFCheckBox.of(checkBox, checkBox.ref, this.doc);\n  }\n\n  /**\n   * Create a new dropdown field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const dropdown = form.createDropdown('cool.new.dropdown')\n   *\n   * dropdown.addToPage(font, page)\n   * ```\n   * An error will be thrown if a field already exists with the provided name.\n   * @param name The fully qualified name for the new dropdown.\n   * @returns The new dropdown field.\n   */\n  createDropdown(name: string): PDFDropdown {\n    assertIs(name, 'name', ['string']);\n\n    const nameParts = splitFieldName(name);\n    const parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);\n\n    const comboBox = PDFAcroComboBox.create(this.doc.context);\n    comboBox.setPartialName(nameParts.terminal);\n\n    addFieldToParent(parent, [comboBox, comboBox.ref], nameParts.terminal);\n\n    return PDFDropdown.of(comboBox, comboBox.ref, this.doc);\n  }\n\n  /**\n   * Create a new option list field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const optionList = form.createOptionList('cool.new.optionList')\n   *\n   * optionList.addToPage(font, page)\n   * ```\n   * An error will be thrown if a field already exists with the provided name.\n   * @param name The fully qualified name for the new option list.\n   * @returns The new option list field.\n   */\n  createOptionList(name: string): PDFOptionList {\n    assertIs(name, 'name', ['string']);\n\n    const nameParts = splitFieldName(name);\n    const parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);\n\n    const listBox = PDFAcroListBox.create(this.doc.context);\n    listBox.setPartialName(nameParts.terminal);\n\n    addFieldToParent(parent, [listBox, listBox.ref], nameParts.terminal);\n\n    return PDFOptionList.of(listBox, listBox.ref, this.doc);\n  }\n\n  /**\n   * Create a new radio group field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const radioGroup = form.createRadioGroup('cool.new.radioGroup')\n   *\n   * radioGroup.addOptionToPage('is-dog', page, { y: 0 })\n   * radioGroup.addOptionToPage('is-cat', page, { y: 75 })\n   * ```\n   * An error will be thrown if a field already exists with the provided name.\n   * @param name The fully qualified name for the new radio group.\n   * @returns The new radio group field.\n   */\n  createRadioGroup(name: string): PDFRadioGroup {\n    assertIs(name, 'name', ['string']);\n    const nameParts = splitFieldName(name);\n\n    const parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);\n\n    const radioButton = PDFAcroRadioButton.create(this.doc.context);\n    radioButton.setPartialName(nameParts.terminal);\n\n    addFieldToParent(\n      parent,\n      [radioButton, radioButton.ref],\n      nameParts.terminal,\n    );\n\n    return PDFRadioGroup.of(radioButton, radioButton.ref, this.doc);\n  }\n\n  /**\n   * Create a new text field in this [[PDFForm]] with the given name.\n   * For example:\n   * ```js\n   * const font = await pdfDoc.embedFont(StandardFonts.Helvetica)\n   * const page = pdfDoc.addPage()\n   *\n   * const form = pdfDoc.getForm()\n   * const textField = form.createTextField('cool.new.textField')\n   *\n   * textField.addToPage(font, page)\n   * ```\n   * An error will be thrown if a field already exists with the provided name.\n   * @param name The fully qualified name for the new radio group.\n   * @returns The new radio group field.\n   */\n  createTextField(name: string): PDFTextField {\n    assertIs(name, 'name', ['string']);\n    const nameParts = splitFieldName(name);\n\n    const parent = this.findOrCreateNonTerminals(nameParts.nonTerminal);\n\n    const text = PDFAcroText.create(this.doc.context);\n    text.setPartialName(nameParts.terminal);\n\n    addFieldToParent(parent, [text, text.ref], nameParts.terminal);\n\n    return PDFTextField.of(text, text.ref, this.doc);\n  }\n\n  /**\n   * Flatten all fields in this [[PDFForm]].\n   *\n   * Flattening a form field will take the current appearance for each of that\n   * field's widgets and make them part of their page's content stream. All form\n   * fields and annotations associated are then removed. Note that once a form\n   * has been flattened its fields can no longer be accessed or edited.\n   *\n   * This operation is often used after filling form fields to ensure a\n   * consistent appearance across different PDF readers and/or printers.\n   * Another common use case is to copy a template document with form fields\n   * into another document. In this scenario you would load the template\n   * document, fill its fields, flatten it, and then copy its pages into the\n   * recipient document - the filled fields will be copied over.\n   *\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm();\n   * form.flatten();\n   * ```\n   */\n  flatten(options: FlattenOptions = { updateFieldAppearances: true }) {\n    if (options.updateFieldAppearances) {\n      this.updateFieldAppearances();\n    }\n\n    const fields = this.getFields();\n\n    for (let i = 0, lenFields = fields.length; i < lenFields; i++) {\n      const field = fields[i];\n      const widgets = field.acroField.getWidgets();\n\n      for (let j = 0, lenWidgets = widgets.length; j < lenWidgets; j++) {\n        const widget = widgets[j];\n        const page = this.findWidgetPage(widget);\n        const widgetRef = this.findWidgetAppearanceRef(field, widget);\n\n        const xObjectKey = page.node.newXObject('FlatWidget', widgetRef);\n\n        const rectangle = widget.getRectangle();\n        const operators = [\n          pushGraphicsState(),\n          translate(rectangle.x, rectangle.y),\n          ...rotateInPlace({ ...rectangle, rotation: 0 }),\n          drawObject(xObjectKey),\n          popGraphicsState(),\n        ].filter(Boolean) as PDFOperator[];\n\n        page.pushOperators(...operators);\n      }\n\n      this.removeField(field);\n    }\n  }\n\n  /**\n   * Remove a field from this [[PDFForm]].\n   *\n   * For example:\n   * ```js\n   * const form = pdfDoc.getForm();\n   * const ageField = form.getFields().find(x => x.getName() === 'Age');\n   * form.removeField(ageField);\n   * ```\n   */\n  removeField(field: PDFField) {\n    const widgets = field.acroField.getWidgets();\n    const pages: Set<PDFPage> = new Set();\n\n    for (let i = 0, len = widgets.length; i < len; i++) {\n      const widget = widgets[i];\n      const widgetRef = this.findWidgetAppearanceRef(field, widget);\n\n      const page = this.findWidgetPage(widget);\n      pages.add(page);\n\n      page.node.removeAnnot(widgetRef);\n    }\n\n    pages.forEach((page) => page.node.removeAnnot(field.ref));\n    this.acroForm.removeField(field.acroField);\n    const fieldKids = field.acroField.normalizedEntries().Kids;\n    const kidsCount = fieldKids.size();\n    for (let childIndex = 0; childIndex < kidsCount; childIndex++) {\n      const child = fieldKids.get(childIndex);\n      if (child instanceof PDFRef) {\n        this.doc.context.delete(child);\n      }\n    }\n    this.doc.context.delete(field.ref);\n  }\n\n  /**\n   * Update the appearance streams for all widgets of all fields in this\n   * [[PDFForm]]. Appearance streams will only be created for a widget if it\n   * does not have any existing appearance streams, or the field's value has\n   * changed (e.g. by calling [[PDFTextField.setText]] or\n   * [[PDFDropdown.select]]).\n   *\n   * For example:\n   * ```js\n   * const courier = await pdfDoc.embedFont(StandardFonts.Courier)\n   * const form = pdfDoc.getForm()\n   * form.updateFieldAppearances(courier)\n   * ```\n   *\n   * **IMPORTANT:** The default value for the `font` parameter is\n   * [[StandardFonts.Helvetica]]. Note that this is a WinAnsi font. This means\n   * that encoding errors will be thrown if any fields contain text with\n   * characters outside the WinAnsi character set (the latin alphabet).\n   *\n   * Embedding a custom font and passing that as the `font`\n   * parameter allows you to generate appearance streams with non WinAnsi\n   * characters (assuming your custom font supports them).\n   *\n   * > **NOTE:** The [[PDFDocument.save]] method will call this method to\n   * > update appearances automatically if a form was accessed via the\n   * > [[PDFDocument.getForm]] method prior to saving.\n   *\n   * @param font Optionally, the font to use when creating new appearances.\n   */\n  updateFieldAppearances(font?: PDFFont) {\n    assertOrUndefined(font, 'font', [[PDFFont, 'PDFFont']]);\n\n    font = font ?? this.getDefaultFont();\n\n    const fields = this.getFields();\n\n    for (let idx = 0, len = fields.length; idx < len; idx++) {\n      const field = fields[idx];\n      if (field.needsAppearancesUpdate()) {\n        field.defaultUpdateAppearances(font);\n      }\n    }\n  }\n\n  /**\n   * Mark a field as dirty. This will cause its appearance streams to be\n   * updated by [[PDFForm.updateFieldAppearances]].\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const field = form.getField('foo.bar')\n   * form.markFieldAsDirty(field.ref)\n   * ```\n   * @param fieldRef The reference to the field that should be marked.\n   */\n  markFieldAsDirty(fieldRef: PDFRef) {\n    assertOrUndefined(fieldRef, 'fieldRef', [[PDFRef, 'PDFRef']]);\n    this.dirtyFields.add(fieldRef);\n  }\n\n  /**\n   * Mark a field as dirty. This will cause its appearance streams to not be\n   * updated by [[PDFForm.updateFieldAppearances]].\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const field = form.getField('foo.bar')\n   * form.markFieldAsClean(field.ref)\n   * ```\n   * @param fieldRef The reference to the field that should be marked.\n   */\n  markFieldAsClean(fieldRef: PDFRef) {\n    assertOrUndefined(fieldRef, 'fieldRef', [[PDFRef, 'PDFRef']]);\n    this.dirtyFields.delete(fieldRef);\n  }\n\n  /**\n   * Returns `true` is the specified field has been marked as dirty.\n   * ```js\n   * const form = pdfDoc.getForm()\n   * const field = form.getField('foo.bar')\n   * if (form.fieldIsDirty(field.ref)) console.log('Field is dirty')\n   * ```\n   * @param fieldRef The reference to the field that should be checked.\n   * @returns Whether or not the specified field is dirty.\n   */\n  fieldIsDirty(fieldRef: PDFRef): boolean {\n    assertOrUndefined(fieldRef, 'fieldRef', [[PDFRef, 'PDFRef']]);\n    return this.dirtyFields.has(fieldRef);\n  }\n\n  getDefaultFont() {\n    return this.defaultFontCache.access();\n  }\n\n  private findWidgetPage(widget: PDFWidgetAnnotation): PDFPage {\n    const pageRef = widget.P();\n    let page = this.doc.getPages().find((x) => x.ref === pageRef);\n    if (page === undefined) {\n      const widgetRef = this.doc.context.getObjectRef(widget.dict);\n      if (widgetRef === undefined) {\n        throw new Error('Could not find PDFRef for PDFObject');\n      }\n\n      page = this.doc.findPageForAnnotationRef(widgetRef);\n\n      if (page === undefined) {\n        throw new Error(`Could not find page for PDFRef ${widgetRef}`);\n      }\n    }\n\n    return page;\n  }\n\n  private findWidgetAppearanceRef(\n    field: PDFField,\n    widget: PDFWidgetAnnotation,\n  ): PDFRef {\n    let refOrDict = widget.getNormalAppearance();\n\n    if (\n      refOrDict instanceof PDFDict &&\n      (field instanceof PDFCheckBox || field instanceof PDFRadioGroup)\n    ) {\n      const value = field.acroField.getValue();\n      const ref = refOrDict.get(value) ?? refOrDict.get(PDFName.of('Off'));\n\n      if (ref instanceof PDFRef) {\n        refOrDict = ref;\n      }\n    }\n\n    if (!(refOrDict instanceof PDFRef)) {\n      const name = field.getName();\n      throw new Error(`Failed to extract appearance ref for: ${name}`);\n    }\n\n    return refOrDict;\n  }\n\n  private findOrCreateNonTerminals(partialNames: string[]) {\n    let nonTerminal: [PDFAcroForm] | [PDFAcroNonTerminal, PDFRef] = [\n      this.acroForm,\n    ];\n    for (let idx = 0, len = partialNames.length; idx < len; idx++) {\n      const namePart = partialNames[idx];\n      if (!namePart) throw new InvalidFieldNamePartError(namePart);\n      const [parent, parentRef] = nonTerminal;\n      const res = this.findNonTerminal(namePart, parent);\n\n      if (res) {\n        nonTerminal = res;\n      } else {\n        const node = PDFAcroNonTerminal.create(this.doc.context);\n        node.setPartialName(namePart);\n        node.setParent(parentRef);\n        const nodeRef = this.doc.context.register(node.dict);\n        parent.addField(nodeRef);\n        nonTerminal = [node, nodeRef];\n      }\n    }\n    return nonTerminal;\n  }\n\n  private findNonTerminal(\n    partialName: string,\n    parent: PDFAcroForm | PDFAcroNonTerminal,\n  ): [PDFAcroNonTerminal, PDFRef] | undefined {\n    const fields =\n      parent instanceof PDFAcroForm\n        ? this.acroForm.getFields()\n        : createPDFAcroFields(parent.Kids());\n\n    for (let idx = 0, len = fields.length; idx < len; idx++) {\n      const [field, ref] = fields[idx];\n      if (field.getPartialName() === partialName) {\n        if (field instanceof PDFAcroNonTerminal) return [field, ref];\n        throw new FieldAlreadyExistsError(partialName);\n      }\n    }\n\n    return undefined;\n  }\n\n  private embedDefaultFont = (): PDFFont =>\n    this.doc.embedStandardFont(StandardFonts.Helvetica);\n}\n\nconst convertToPDFField = (\n  field: PDFAcroField,\n  ref: PDFRef,\n  doc: PDFDocument,\n): PDFField | undefined => {\n  if (field instanceof PDFAcroPushButton) return PDFButton.of(field, ref, doc);\n  if (field instanceof PDFAcroCheckBox) return PDFCheckBox.of(field, ref, doc);\n  if (field instanceof PDFAcroComboBox) return PDFDropdown.of(field, ref, doc);\n  if (field instanceof PDFAcroListBox) return PDFOptionList.of(field, ref, doc);\n  if (field instanceof PDFAcroText) return PDFTextField.of(field, ref, doc);\n  if (field instanceof PDFAcroRadioButton) {\n    return PDFRadioGroup.of(field, ref, doc);\n  }\n  if (field instanceof PDFAcroSignature) {\n    return PDFSignature.of(field, ref, doc);\n  }\n  return undefined;\n};\n\nconst splitFieldName = (fullyQualifiedName: string) => {\n  if (fullyQualifiedName.length === 0) {\n    throw new Error('PDF field names must not be empty strings');\n  }\n\n  const parts = fullyQualifiedName.split('.');\n\n  for (let idx = 0, len = parts.length; idx < len; idx++) {\n    if (parts[idx] === '') {\n      throw new Error(\n        `Periods in PDF field names must be separated by at least one character: \"${fullyQualifiedName}\"`,\n      );\n    }\n  }\n\n  if (parts.length === 1) return { nonTerminal: [], terminal: parts[0] };\n\n  return {\n    nonTerminal: parts.slice(0, parts.length - 1),\n    terminal: parts[parts.length - 1],\n  };\n};\n\nconst addFieldToParent = (\n  [parent, parentRef]: [PDFAcroForm] | [PDFAcroNonTerminal, PDFRef],\n  [field, fieldRef]: [PDFAcroField, PDFRef],\n  partialName: string,\n) => {\n  const entries = parent.normalizedEntries();\n  const fields = createPDFAcroFields(\n    'Kids' in entries ? entries.Kids : entries.Fields,\n  );\n  for (let idx = 0, len = fields.length; idx < len; idx++) {\n    if (fields[idx][0].getPartialName() === partialName) {\n      throw new FieldAlreadyExistsError(partialName);\n    }\n  }\n  parent.addField(fieldRef);\n  field.setParent(parentRef);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}