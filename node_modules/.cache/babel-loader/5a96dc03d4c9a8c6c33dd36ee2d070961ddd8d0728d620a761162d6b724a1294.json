{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.layoutSinglelineText = exports.layoutCombedText = exports.layoutMultilineText = void 0;\nvar errors_1 = require(\"../errors\");\nvar alignment_1 = require(\"./alignment\");\nvar utils_1 = require(\"../../utils\");\nvar MIN_FONT_SIZE = 4;\nvar MAX_FONT_SIZE = 500;\nvar computeFontSize = function (lines, font, bounds, multiline) {\n  if (multiline === void 0) {\n    multiline = false;\n  }\n  var fontSize = MIN_FONT_SIZE;\n  while (fontSize < MAX_FONT_SIZE) {\n    var linesUsed = 0;\n    for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {\n      linesUsed += 1;\n      var line = lines[lineIdx];\n      var words = line.split(' ');\n      // Layout the words using the current `fontSize`, line wrapping\n      // whenever we reach the end of the current line.\n      var spaceInLineRemaining = bounds.width;\n      for (var idx = 0, len = words.length; idx < len; idx++) {\n        var isLastWord = idx === len - 1;\n        var word = isLastWord ? words[idx] : words[idx] + ' ';\n        var widthOfWord = font.widthOfTextAtSize(word, fontSize);\n        spaceInLineRemaining -= widthOfWord;\n        if (spaceInLineRemaining <= 0) {\n          linesUsed += 1;\n          spaceInLineRemaining = bounds.width - widthOfWord;\n        }\n      }\n    }\n    // Return if we exceeded the allowed width\n    if (!multiline && linesUsed > lines.length) return fontSize - 1;\n    var height = font.heightAtSize(fontSize);\n    var lineHeight = height + height * 0.2;\n    var totalHeight = lineHeight * linesUsed;\n    // Return if we exceeded the allowed height\n    if (totalHeight > Math.abs(bounds.height)) return fontSize - 1;\n    fontSize += 1;\n  }\n  return fontSize;\n};\nvar computeCombedFontSize = function (line, font, bounds, cellCount) {\n  var cellWidth = bounds.width / cellCount;\n  var cellHeight = bounds.height;\n  var fontSize = MIN_FONT_SIZE;\n  var chars = utils_1.charSplit(line);\n  while (fontSize < MAX_FONT_SIZE) {\n    for (var idx = 0, len = chars.length; idx < len; idx++) {\n      var c = chars[idx];\n      var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\n      if (tooLong) return fontSize - 1;\n    }\n    var height = font.heightAtSize(fontSize, {\n      descender: false\n    });\n    if (height > cellHeight) return fontSize - 1;\n    fontSize += 1;\n  }\n  return fontSize;\n};\nvar lastIndexOfWhitespace = function (line) {\n  for (var idx = line.length; idx > 0; idx--) {\n    if (/\\s/.test(line[idx])) return idx;\n  }\n  return undefined;\n};\nvar splitOutLines = function (input, maxWidth, font, fontSize) {\n  var _a;\n  var lastWhitespaceIdx = input.length;\n  while (lastWhitespaceIdx > 0) {\n    var line = input.substring(0, lastWhitespaceIdx);\n    var encoded = font.encodeText(line);\n    var width = font.widthOfTextAtSize(line, fontSize);\n    if (width < maxWidth) {\n      var remainder = input.substring(lastWhitespaceIdx) || undefined;\n      return {\n        line: line,\n        encoded: encoded,\n        width: width,\n        remainder: remainder\n      };\n    }\n    lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;\n  }\n  // We were unable to split the input enough to get a chunk that would fit\n  // within the specified `maxWidth` so we'll just return everything\n  return {\n    line: input,\n    encoded: font.encodeText(input),\n    width: font.widthOfTextAtSize(input, fontSize),\n    remainder: undefined\n  };\n};\nexports.layoutMultilineText = function (text, _a) {\n  var alignment = _a.alignment,\n    fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds;\n  var lines = utils_1.lineSplit(utils_1.cleanText(text));\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize(lines, font, bounds, true);\n  }\n  var height = font.heightAtSize(fontSize);\n  var lineHeight = height + height * 0.2;\n  var textLines = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var y = bounds.y + bounds.height;\n  for (var idx = 0, len = lines.length; idx < len; idx++) {\n    var prevRemainder = lines[idx];\n    while (prevRemainder !== undefined) {\n      var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize),\n        line = _b.line,\n        encoded = _b.encoded,\n        width = _b.width,\n        remainder = _b.remainder;\n      // prettier-ignore\n      var x = alignment === alignment_1.TextAlignment.Left ? bounds.x : alignment === alignment_1.TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === alignment_1.TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n      y -= lineHeight;\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x + width > maxX) maxX = x + width;\n      if (y + height > maxY) maxY = y + height;\n      textLines.push({\n        text: line,\n        encoded: encoded,\n        width: width,\n        height: height,\n        x: x,\n        y: y\n      });\n      // Only trim lines that we had to split ourselves. So we won't trim lines\n      // that the user provided themselves with whitespace.\n      prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();\n    }\n  }\n  return {\n    fontSize: fontSize,\n    lineHeight: lineHeight,\n    lines: textLines,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexports.layoutCombedText = function (text, _a) {\n  var fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds,\n    cellCount = _a.cellCount;\n  var line = utils_1.mergeLines(utils_1.cleanText(text));\n  if (line.length > cellCount) {\n    throw new errors_1.CombedTextLayoutError(line.length, cellCount);\n  }\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeCombedFontSize(line, font, bounds, cellCount);\n  }\n  var cellWidth = bounds.width / cellCount;\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  });\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  var cells = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var cellOffset = 0;\n  var charOffset = 0;\n  while (cellOffset < cellCount) {\n    var _b = utils_1.charAtIndex(line, charOffset),\n      char = _b[0],\n      charLength = _b[1];\n    var encoded = font.encodeText(char);\n    var width = font.widthOfTextAtSize(char, fontSize);\n    var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\n    var x = cellCenter - width / 2;\n    if (x < minX) minX = x;\n    if (y < minY) minY = y;\n    if (x + width > maxX) maxX = x + width;\n    if (y + height > maxY) maxY = y + height;\n    cells.push({\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    });\n    cellOffset += 1;\n    charOffset += charLength;\n  }\n  return {\n    fontSize: fontSize,\n    cells: cells,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexports.layoutSinglelineText = function (text, _a) {\n  var alignment = _a.alignment,\n    fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds;\n  var line = utils_1.mergeLines(utils_1.cleanText(text));\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize([line], font, bounds);\n  }\n  var encoded = font.encodeText(line);\n  var width = font.widthOfTextAtSize(line, fontSize);\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  });\n  // prettier-ignore\n  var x = alignment === alignment_1.TextAlignment.Left ? bounds.x : alignment === alignment_1.TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === alignment_1.TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  return {\n    fontSize: fontSize,\n    line: {\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    },\n    bounds: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  };\n};","map":{"version":3,"names":["errors_1","require","alignment_1","utils_1","MIN_FONT_SIZE","MAX_FONT_SIZE","computeFontSize","lines","font","bounds","multiline","fontSize","linesUsed","lineIdx","lineLen","length","line","words","split","spaceInLineRemaining","width","idx","len","isLastWord","word","widthOfWord","widthOfTextAtSize","height","heightAtSize","lineHeight","totalHeight","Math","abs","computeCombedFontSize","cellCount","cellWidth","cellHeight","chars","charSplit","c","tooLong","descender","lastIndexOfWhitespace","test","undefined","splitOutLines","input","maxWidth","lastWhitespaceIdx","substring","encoded","encodeText","remainder","_a","exports","layoutMultilineText","text","alignment","lineSplit","cleanText","textLines","minX","x","minY","y","maxX","maxY","prevRemainder","_b","TextAlignment","Left","Center","Right","push","trim","layoutCombedText","mergeLines","CombedTextLayoutError","cells","cellOffset","charOffset","charAtIndex","char","charLength","cellCenter","layoutSinglelineText"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/api/text/layout.ts"],"sourcesContent":["import PDFFont from 'src/api/PDFFont';\nimport { CombedTextLayoutError } from 'src/api/errors';\nimport { TextAlignment } from 'src/api/text/alignment';\n\nimport { PDFHexString } from 'src/core';\nimport {\n  cleanText,\n  lineSplit,\n  mergeLines,\n  charAtIndex,\n  charSplit,\n} from 'src/utils';\n\nexport interface TextPosition {\n  text: string;\n  encoded: PDFHexString;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nexport interface LayoutBounds {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nconst MIN_FONT_SIZE = 4;\nconst MAX_FONT_SIZE = 500;\n\nconst computeFontSize = (\n  lines: string[],\n  font: PDFFont,\n  bounds: LayoutBounds,\n  multiline: boolean = false,\n) => {\n  let fontSize = MIN_FONT_SIZE;\n\n  while (fontSize < MAX_FONT_SIZE) {\n    let linesUsed = 0;\n\n    for (\n      let lineIdx = 0, lineLen = lines.length;\n      lineIdx < lineLen;\n      lineIdx++\n    ) {\n      linesUsed += 1;\n\n      const line = lines[lineIdx];\n      const words = line.split(' ');\n\n      // Layout the words using the current `fontSize`, line wrapping\n      // whenever we reach the end of the current line.\n      let spaceInLineRemaining = bounds.width;\n      for (let idx = 0, len = words.length; idx < len; idx++) {\n        const isLastWord = idx === len - 1;\n        const word = isLastWord ? words[idx] : words[idx] + ' ';\n        const widthOfWord = font.widthOfTextAtSize(word, fontSize);\n        spaceInLineRemaining -= widthOfWord;\n        if (spaceInLineRemaining <= 0) {\n          linesUsed += 1;\n          spaceInLineRemaining = bounds.width - widthOfWord;\n        }\n      }\n    }\n\n    // Return if we exceeded the allowed width\n    if (!multiline && linesUsed > lines.length) return fontSize - 1;\n\n    const height = font.heightAtSize(fontSize);\n    const lineHeight = height + height * 0.2;\n    const totalHeight = lineHeight * linesUsed;\n\n    // Return if we exceeded the allowed height\n    if (totalHeight > Math.abs(bounds.height)) return fontSize - 1;\n\n    fontSize += 1;\n  }\n\n  return fontSize;\n};\n\nconst computeCombedFontSize = (\n  line: string,\n  font: PDFFont,\n  bounds: LayoutBounds,\n  cellCount: number,\n) => {\n  const cellWidth = bounds.width / cellCount;\n  const cellHeight = bounds.height;\n\n  let fontSize = MIN_FONT_SIZE;\n\n  const chars = charSplit(line);\n  while (fontSize < MAX_FONT_SIZE) {\n    for (let idx = 0, len = chars.length; idx < len; idx++) {\n      const c = chars[idx];\n      const tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\n      if (tooLong) return fontSize - 1;\n    }\n\n    const height = font.heightAtSize(fontSize, { descender: false });\n    if (height > cellHeight) return fontSize - 1;\n\n    fontSize += 1;\n  }\n\n  return fontSize;\n};\n\nexport interface LayoutTextOptions {\n  alignment: TextAlignment;\n  fontSize?: number;\n  font: PDFFont;\n  bounds: LayoutBounds;\n}\n\nexport interface MultilineTextLayout {\n  bounds: LayoutBounds;\n  lines: TextPosition[];\n  fontSize: number;\n  lineHeight: number;\n}\n\nconst lastIndexOfWhitespace = (line: string) => {\n  for (let idx = line.length; idx > 0; idx--) {\n    if (/\\s/.test(line[idx])) return idx;\n  }\n  return undefined;\n};\n\nconst splitOutLines = (\n  input: string,\n  maxWidth: number,\n  font: PDFFont,\n  fontSize: number,\n) => {\n  let lastWhitespaceIdx = input.length;\n  while (lastWhitespaceIdx > 0) {\n    const line = input.substring(0, lastWhitespaceIdx);\n    const encoded = font.encodeText(line);\n    const width = font.widthOfTextAtSize(line, fontSize);\n    if (width < maxWidth) {\n      const remainder = input.substring(lastWhitespaceIdx) || undefined;\n      return { line, encoded, width, remainder };\n    }\n    lastWhitespaceIdx = lastIndexOfWhitespace(line) ?? 0;\n  }\n\n  // We were unable to split the input enough to get a chunk that would fit\n  // within the specified `maxWidth` so we'll just return everything\n  return {\n    line: input,\n    encoded: font.encodeText(input),\n    width: font.widthOfTextAtSize(input, fontSize),\n    remainder: undefined,\n  };\n};\n\nexport const layoutMultilineText = (\n  text: string,\n  { alignment, fontSize, font, bounds }: LayoutTextOptions,\n): MultilineTextLayout => {\n  const lines = lineSplit(cleanText(text));\n\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize(lines, font, bounds, true);\n  }\n  const height = font.heightAtSize(fontSize);\n  const lineHeight = height + height * 0.2;\n\n  const textLines: TextPosition[] = [];\n\n  let minX = bounds.x;\n  let minY = bounds.y;\n  let maxX = bounds.x + bounds.width;\n  let maxY = bounds.y + bounds.height;\n\n  let y = bounds.y + bounds.height;\n  for (let idx = 0, len = lines.length; idx < len; idx++) {\n    let prevRemainder: string | undefined = lines[idx];\n    while (prevRemainder !== undefined) {\n      const { line, encoded, width, remainder } = splitOutLines(\n        prevRemainder,\n        bounds.width,\n        font,\n        fontSize,\n      );\n\n      // prettier-ignore\n      const x = (\n          alignment === TextAlignment.Left   ? bounds.x\n        : alignment === TextAlignment.Center ? bounds.x + (bounds.width / 2) - (width / 2)\n        : alignment === TextAlignment.Right  ? bounds.x + bounds.width - width\n        : bounds.x\n      );\n\n      y -= lineHeight;\n\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x + width > maxX) maxX = x + width;\n      if (y + height > maxY) maxY = y + height;\n\n      textLines.push({ text: line, encoded, width, height, x, y });\n\n      // Only trim lines that we had to split ourselves. So we won't trim lines\n      // that the user provided themselves with whitespace.\n      prevRemainder = remainder?.trim();\n    }\n  }\n\n  return {\n    fontSize,\n    lineHeight,\n    lines: textLines,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    },\n  };\n};\n\nexport interface LayoutCombedTextOptions {\n  fontSize?: number;\n  font: PDFFont;\n  bounds: LayoutBounds;\n  cellCount: number;\n}\n\nexport interface CombedTextLayout {\n  bounds: LayoutBounds;\n  cells: TextPosition[];\n  fontSize: number;\n}\n\nexport const layoutCombedText = (\n  text: string,\n  { fontSize, font, bounds, cellCount }: LayoutCombedTextOptions,\n): CombedTextLayout => {\n  const line = mergeLines(cleanText(text));\n\n  if (line.length > cellCount) {\n    throw new CombedTextLayoutError(line.length, cellCount);\n  }\n\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeCombedFontSize(line, font, bounds, cellCount);\n  }\n\n  const cellWidth = bounds.width / cellCount;\n\n  const height = font.heightAtSize(fontSize, { descender: false });\n  const y = bounds.y + (bounds.height / 2 - height / 2);\n\n  const cells: TextPosition[] = [];\n\n  let minX = bounds.x;\n  let minY = bounds.y;\n  let maxX = bounds.x + bounds.width;\n  let maxY = bounds.y + bounds.height;\n\n  let cellOffset = 0;\n  let charOffset = 0;\n  while (cellOffset < cellCount) {\n    const [char, charLength] = charAtIndex(line, charOffset);\n\n    const encoded = font.encodeText(char);\n    const width = font.widthOfTextAtSize(char, fontSize);\n\n    const cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\n    const x = cellCenter - width / 2;\n\n    if (x < minX) minX = x;\n    if (y < minY) minY = y;\n    if (x + width > maxX) maxX = x + width;\n    if (y + height > maxY) maxY = y + height;\n\n    cells.push({ text: line, encoded, width, height, x, y });\n\n    cellOffset += 1;\n    charOffset += charLength;\n  }\n\n  return {\n    fontSize,\n    cells,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    },\n  };\n};\n\nexport interface LayoutSinglelineTextOptions {\n  alignment: TextAlignment;\n  fontSize?: number;\n  font: PDFFont;\n  bounds: LayoutBounds;\n}\n\nexport interface SinglelineTextLayout {\n  bounds: LayoutBounds;\n  line: TextPosition;\n  fontSize: number;\n}\n\nexport const layoutSinglelineText = (\n  text: string,\n  { alignment, fontSize, font, bounds }: LayoutSinglelineTextOptions,\n): SinglelineTextLayout => {\n  const line = mergeLines(cleanText(text));\n\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize([line], font, bounds);\n  }\n\n  const encoded = font.encodeText(line);\n  const width = font.widthOfTextAtSize(line, fontSize);\n  const height = font.heightAtSize(fontSize, { descender: false });\n\n  // prettier-ignore\n  const x = (\n      alignment === TextAlignment.Left   ? bounds.x\n    : alignment === TextAlignment.Center ? bounds.x + (bounds.width / 2) - (width / 2)\n    : alignment === TextAlignment.Right  ? bounds.x + bounds.width - width\n    : bounds.x\n  );\n\n  const y = bounds.y + (bounds.height / 2 - height / 2);\n\n  return {\n    fontSize,\n    line: { text: line, encoded, width, height, x, y },\n    bounds: { x, y, width, height },\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}