{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar errors_1 = require(\"../errors\");\nvar PDFArray_1 = tslib_1.__importDefault(require(\"../objects/PDFArray\"));\nvar PDFBool_1 = tslib_1.__importDefault(require(\"../objects/PDFBool\"));\nvar PDFDict_1 = tslib_1.__importDefault(require(\"../objects/PDFDict\"));\nvar PDFHexString_1 = tslib_1.__importDefault(require(\"../objects/PDFHexString\"));\nvar PDFName_1 = tslib_1.__importDefault(require(\"../objects/PDFName\"));\nvar PDFNull_1 = tslib_1.__importDefault(require(\"../objects/PDFNull\"));\nvar PDFNumber_1 = tslib_1.__importDefault(require(\"../objects/PDFNumber\"));\nvar PDFRawStream_1 = tslib_1.__importDefault(require(\"../objects/PDFRawStream\"));\nvar PDFRef_1 = tslib_1.__importDefault(require(\"../objects/PDFRef\"));\nvar PDFString_1 = tslib_1.__importDefault(require(\"../objects/PDFString\"));\nvar BaseParser_1 = tslib_1.__importDefault(require(\"./BaseParser\"));\nvar ByteStream_1 = tslib_1.__importDefault(require(\"./ByteStream\"));\nvar PDFCatalog_1 = tslib_1.__importDefault(require(\"../structures/PDFCatalog\"));\nvar PDFPageLeaf_1 = tslib_1.__importDefault(require(\"../structures/PDFPageLeaf\"));\nvar PDFPageTree_1 = tslib_1.__importDefault(require(\"../structures/PDFPageTree\"));\nvar CharCodes_1 = tslib_1.__importDefault(require(\"../syntax/CharCodes\"));\nvar Delimiters_1 = require(\"../syntax/Delimiters\");\nvar Keywords_1 = require(\"../syntax/Keywords\");\nvar Numeric_1 = require(\"../syntax/Numeric\");\nvar Whitespace_1 = require(\"../syntax/Whitespace\");\nvar utils_1 = require(\"../../utils\");\n// TODO: Throw error if eof is reached before finishing object parse...\nvar PDFObjectParser = /** @class */function (_super) {\n  tslib_1.__extends(PDFObjectParser, _super);\n  function PDFObjectParser(byteStream, context, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    var _this = _super.call(this, byteStream, capNumbers) || this;\n    _this.context = context;\n    return _this;\n  }\n  // TODO: Is it possible to reduce duplicate parsing for ref lookaheads?\n  PDFObjectParser.prototype.parseObject = function () {\n    this.skipWhitespaceAndComments();\n    if (this.matchKeyword(Keywords_1.Keywords.true)) return PDFBool_1.default.True;\n    if (this.matchKeyword(Keywords_1.Keywords.false)) return PDFBool_1.default.False;\n    if (this.matchKeyword(Keywords_1.Keywords.null)) return PDFNull_1.default;\n    var byte = this.bytes.peek();\n    if (byte === CharCodes_1.default.LessThan && this.bytes.peekAhead(1) === CharCodes_1.default.LessThan) {\n      return this.parseDictOrStream();\n    }\n    if (byte === CharCodes_1.default.LessThan) return this.parseHexString();\n    if (byte === CharCodes_1.default.LeftParen) return this.parseString();\n    if (byte === CharCodes_1.default.ForwardSlash) return this.parseName();\n    if (byte === CharCodes_1.default.LeftSquareBracket) return this.parseArray();\n    if (Numeric_1.IsNumeric[byte]) return this.parseNumberOrRef();\n    throw new errors_1.PDFObjectParsingError(this.bytes.position(), byte);\n  };\n  PDFObjectParser.prototype.parseNumberOrRef = function () {\n    var firstNum = this.parseRawNumber();\n    this.skipWhitespaceAndComments();\n    var lookaheadStart = this.bytes.offset();\n    if (Numeric_1.IsDigit[this.bytes.peek()]) {\n      var secondNum = this.parseRawNumber();\n      this.skipWhitespaceAndComments();\n      if (this.bytes.peek() === CharCodes_1.default.R) {\n        this.bytes.assertNext(CharCodes_1.default.R);\n        return PDFRef_1.default.of(firstNum, secondNum);\n      }\n    }\n    this.bytes.moveTo(lookaheadStart);\n    return PDFNumber_1.default.of(firstNum);\n  };\n  // TODO: Maybe update PDFHexString.of() logic to remove whitespace and validate input?\n  PDFObjectParser.prototype.parseHexString = function () {\n    var value = '';\n    this.bytes.assertNext(CharCodes_1.default.LessThan);\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes_1.default.GreaterThan) {\n      value += utils_1.charFromCode(this.bytes.next());\n    }\n    this.bytes.assertNext(CharCodes_1.default.GreaterThan);\n    return PDFHexString_1.default.of(value);\n  };\n  PDFObjectParser.prototype.parseString = function () {\n    var nestingLvl = 0;\n    var isEscaped = false;\n    var value = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.next();\n      value += utils_1.charFromCode(byte);\n      // Check for unescaped parenthesis\n      if (!isEscaped) {\n        if (byte === CharCodes_1.default.LeftParen) nestingLvl += 1;\n        if (byte === CharCodes_1.default.RightParen) nestingLvl -= 1;\n      }\n      // Track whether current character is being escaped or not\n      if (byte === CharCodes_1.default.BackSlash) {\n        isEscaped = !isEscaped;\n      } else if (isEscaped) {\n        isEscaped = false;\n      }\n      // Once (if) the unescaped parenthesis balance out, return their contents\n      if (nestingLvl === 0) {\n        // Remove the outer parens so they aren't part of the contents\n        return PDFString_1.default.of(value.substring(1, value.length - 1));\n      }\n    }\n    throw new errors_1.UnbalancedParenthesisError(this.bytes.position());\n  };\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  // TODO: Maybe preallocate small Uint8Array if can use charFromCode?\n  PDFObjectParser.prototype.parseName = function () {\n    this.bytes.assertNext(CharCodes_1.default.ForwardSlash);\n    var name = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (Whitespace_1.IsWhitespace[byte] || Delimiters_1.IsDelimiter[byte]) break;\n      name += utils_1.charFromCode(byte);\n      this.bytes.next();\n    }\n    return PDFName_1.default.of(name);\n  };\n  PDFObjectParser.prototype.parseArray = function () {\n    this.bytes.assertNext(CharCodes_1.default.LeftSquareBracket);\n    this.skipWhitespaceAndComments();\n    var pdfArray = PDFArray_1.default.withContext(this.context);\n    while (this.bytes.peek() !== CharCodes_1.default.RightSquareBracket) {\n      var element = this.parseObject();\n      pdfArray.push(element);\n      this.skipWhitespaceAndComments();\n    }\n    this.bytes.assertNext(CharCodes_1.default.RightSquareBracket);\n    return pdfArray;\n  };\n  PDFObjectParser.prototype.parseDict = function () {\n    this.bytes.assertNext(CharCodes_1.default.LessThan);\n    this.bytes.assertNext(CharCodes_1.default.LessThan);\n    this.skipWhitespaceAndComments();\n    var dict = new Map();\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes_1.default.GreaterThan && this.bytes.peekAhead(1) !== CharCodes_1.default.GreaterThan) {\n      var key = this.parseName();\n      var value = this.parseObject();\n      dict.set(key, value);\n      this.skipWhitespaceAndComments();\n    }\n    this.skipWhitespaceAndComments();\n    this.bytes.assertNext(CharCodes_1.default.GreaterThan);\n    this.bytes.assertNext(CharCodes_1.default.GreaterThan);\n    var Type = dict.get(PDFName_1.default.of('Type'));\n    if (Type === PDFName_1.default.of('Catalog')) {\n      return PDFCatalog_1.default.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName_1.default.of('Pages')) {\n      return PDFPageTree_1.default.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName_1.default.of('Page')) {\n      return PDFPageLeaf_1.default.fromMapWithContext(dict, this.context);\n    } else {\n      return PDFDict_1.default.fromMapWithContext(dict, this.context);\n    }\n  };\n  PDFObjectParser.prototype.parseDictOrStream = function () {\n    var startPos = this.bytes.position();\n    var dict = this.parseDict();\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords_1.Keywords.streamEOF1) && !this.matchKeyword(Keywords_1.Keywords.streamEOF2) && !this.matchKeyword(Keywords_1.Keywords.streamEOF3) && !this.matchKeyword(Keywords_1.Keywords.streamEOF4) && !this.matchKeyword(Keywords_1.Keywords.stream)) {\n      return dict;\n    }\n    var start = this.bytes.offset();\n    var end;\n    var Length = dict.get(PDFName_1.default.of('Length'));\n    if (Length instanceof PDFNumber_1.default) {\n      end = start + Length.asNumber();\n      this.bytes.moveTo(end);\n      this.skipWhitespaceAndComments();\n      if (!this.matchKeyword(Keywords_1.Keywords.endstream)) {\n        this.bytes.moveTo(start);\n        end = this.findEndOfStreamFallback(startPos);\n      }\n    } else {\n      end = this.findEndOfStreamFallback(startPos);\n    }\n    var contents = this.bytes.slice(start, end);\n    return PDFRawStream_1.default.of(dict, contents);\n  };\n  PDFObjectParser.prototype.findEndOfStreamFallback = function (startPos) {\n    // Move to end of stream, while handling nested streams\n    var nestingLvl = 1;\n    var end = this.bytes.offset();\n    while (!this.bytes.done()) {\n      end = this.bytes.offset();\n      if (this.matchKeyword(Keywords_1.Keywords.stream)) {\n        nestingLvl += 1;\n      } else if (this.matchKeyword(Keywords_1.Keywords.EOF1endstream) || this.matchKeyword(Keywords_1.Keywords.EOF2endstream) || this.matchKeyword(Keywords_1.Keywords.EOF3endstream) || this.matchKeyword(Keywords_1.Keywords.endstream)) {\n        nestingLvl -= 1;\n      } else {\n        this.bytes.next();\n      }\n      if (nestingLvl === 0) break;\n    }\n    if (nestingLvl !== 0) throw new errors_1.PDFStreamParsingError(startPos);\n    return end;\n  };\n  PDFObjectParser.forBytes = function (bytes, context, capNumbers) {\n    return new PDFObjectParser(ByteStream_1.default.of(bytes), context, capNumbers);\n  };\n  PDFObjectParser.forByteStream = function (byteStream, context, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    return new PDFObjectParser(byteStream, context, capNumbers);\n  };\n  return PDFObjectParser;\n}(BaseParser_1.default);\nexports.default = PDFObjectParser;","map":{"version":3,"names":["errors_1","require","PDFArray_1","tslib_1","__importDefault","PDFBool_1","PDFDict_1","PDFHexString_1","PDFName_1","PDFNull_1","PDFNumber_1","PDFRawStream_1","PDFRef_1","PDFString_1","BaseParser_1","ByteStream_1","PDFCatalog_1","PDFPageLeaf_1","PDFPageTree_1","CharCodes_1","Delimiters_1","Keywords_1","Numeric_1","Whitespace_1","utils_1","PDFObjectParser","_super","__extends","byteStream","context","capNumbers","_this","call","prototype","parseObject","skipWhitespaceAndComments","matchKeyword","Keywords","true","default","True","false","False","null","byte","bytes","peek","LessThan","peekAhead","parseDictOrStream","parseHexString","LeftParen","parseString","ForwardSlash","parseName","LeftSquareBracket","parseArray","IsNumeric","parseNumberOrRef","PDFObjectParsingError","position","firstNum","parseRawNumber","lookaheadStart","offset","IsDigit","secondNum","R","assertNext","of","moveTo","value","done","GreaterThan","charFromCode","next","nestingLvl","isEscaped","RightParen","BackSlash","substring","length","UnbalancedParenthesisError","name","IsWhitespace","IsDelimiter","pdfArray","withContext","RightSquareBracket","element","push","parseDict","dict","Map","key","set","Type","get","fromMapWithContext","startPos","streamEOF1","streamEOF2","streamEOF3","streamEOF4","stream","start","end","Length","asNumber","endstream","findEndOfStreamFallback","contents","slice","EOF1endstream","EOF2endstream","EOF3endstream","PDFStreamParsingError","forBytes","forByteStream","exports"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/parser/PDFObjectParser.ts"],"sourcesContent":["import {\n  PDFObjectParsingError,\n  PDFStreamParsingError,\n  Position,\n  UnbalancedParenthesisError,\n} from 'src/core/errors';\nimport PDFArray from 'src/core/objects/PDFArray';\nimport PDFBool from 'src/core/objects/PDFBool';\nimport PDFDict, { DictMap } from 'src/core/objects/PDFDict';\nimport PDFHexString from 'src/core/objects/PDFHexString';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFNull from 'src/core/objects/PDFNull';\nimport PDFNumber from 'src/core/objects/PDFNumber';\nimport PDFObject from 'src/core/objects/PDFObject';\nimport PDFRawStream from 'src/core/objects/PDFRawStream';\nimport PDFRef from 'src/core/objects/PDFRef';\nimport PDFStream from 'src/core/objects/PDFStream';\nimport PDFString from 'src/core/objects/PDFString';\nimport BaseParser from 'src/core/parser/BaseParser';\nimport ByteStream from 'src/core/parser/ByteStream';\nimport PDFContext from 'src/core/PDFContext';\nimport PDFCatalog from 'src/core/structures/PDFCatalog';\nimport PDFPageLeaf from 'src/core/structures/PDFPageLeaf';\nimport PDFPageTree from 'src/core/structures/PDFPageTree';\nimport CharCodes from 'src/core/syntax/CharCodes';\nimport { IsDelimiter } from 'src/core/syntax/Delimiters';\nimport { Keywords } from 'src/core/syntax/Keywords';\nimport { IsDigit, IsNumeric } from 'src/core/syntax/Numeric';\nimport { IsWhitespace } from 'src/core/syntax/Whitespace';\nimport { charFromCode } from 'src/utils';\n\n// TODO: Throw error if eof is reached before finishing object parse...\nclass PDFObjectParser extends BaseParser {\n  static forBytes = (\n    bytes: Uint8Array,\n    context: PDFContext,\n    capNumbers?: boolean,\n  ) => new PDFObjectParser(ByteStream.of(bytes), context, capNumbers);\n\n  static forByteStream = (\n    byteStream: ByteStream,\n    context: PDFContext,\n    capNumbers = false,\n  ) => new PDFObjectParser(byteStream, context, capNumbers);\n\n  protected readonly context: PDFContext;\n\n  constructor(byteStream: ByteStream, context: PDFContext, capNumbers = false) {\n    super(byteStream, capNumbers);\n    this.context = context;\n  }\n\n  // TODO: Is it possible to reduce duplicate parsing for ref lookaheads?\n  parseObject(): PDFObject {\n    this.skipWhitespaceAndComments();\n\n    if (this.matchKeyword(Keywords.true)) return PDFBool.True;\n    if (this.matchKeyword(Keywords.false)) return PDFBool.False;\n    if (this.matchKeyword(Keywords.null)) return PDFNull;\n\n    const byte = this.bytes.peek();\n\n    if (\n      byte === CharCodes.LessThan &&\n      this.bytes.peekAhead(1) === CharCodes.LessThan\n    ) {\n      return this.parseDictOrStream();\n    }\n    if (byte === CharCodes.LessThan) return this.parseHexString();\n    if (byte === CharCodes.LeftParen) return this.parseString();\n    if (byte === CharCodes.ForwardSlash) return this.parseName();\n    if (byte === CharCodes.LeftSquareBracket) return this.parseArray();\n    if (IsNumeric[byte]) return this.parseNumberOrRef();\n\n    throw new PDFObjectParsingError(this.bytes.position(), byte);\n  }\n\n  protected parseNumberOrRef(): PDFNumber | PDFRef {\n    const firstNum = this.parseRawNumber();\n    this.skipWhitespaceAndComments();\n\n    const lookaheadStart = this.bytes.offset();\n    if (IsDigit[this.bytes.peek()]) {\n      const secondNum = this.parseRawNumber();\n      this.skipWhitespaceAndComments();\n      if (this.bytes.peek() === CharCodes.R) {\n        this.bytes.assertNext(CharCodes.R);\n        return PDFRef.of(firstNum, secondNum);\n      }\n    }\n\n    this.bytes.moveTo(lookaheadStart);\n    return PDFNumber.of(firstNum);\n  }\n\n  // TODO: Maybe update PDFHexString.of() logic to remove whitespace and validate input?\n  protected parseHexString(): PDFHexString {\n    let value = '';\n\n    this.bytes.assertNext(CharCodes.LessThan);\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan) {\n      value += charFromCode(this.bytes.next());\n    }\n    this.bytes.assertNext(CharCodes.GreaterThan);\n\n    return PDFHexString.of(value);\n  }\n\n  protected parseString(): PDFString {\n    let nestingLvl = 0;\n    let isEscaped = false;\n    let value = '';\n\n    while (!this.bytes.done()) {\n      const byte = this.bytes.next();\n      value += charFromCode(byte);\n\n      // Check for unescaped parenthesis\n      if (!isEscaped) {\n        if (byte === CharCodes.LeftParen) nestingLvl += 1;\n        if (byte === CharCodes.RightParen) nestingLvl -= 1;\n      }\n\n      // Track whether current character is being escaped or not\n      if (byte === CharCodes.BackSlash) {\n        isEscaped = !isEscaped;\n      } else if (isEscaped) {\n        isEscaped = false;\n      }\n\n      // Once (if) the unescaped parenthesis balance out, return their contents\n      if (nestingLvl === 0) {\n        // Remove the outer parens so they aren't part of the contents\n        return PDFString.of(value.substring(1, value.length - 1));\n      }\n    }\n\n    throw new UnbalancedParenthesisError(this.bytes.position());\n  }\n\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  // TODO: Maybe preallocate small Uint8Array if can use charFromCode?\n  protected parseName(): PDFName {\n    this.bytes.assertNext(CharCodes.ForwardSlash);\n\n    let name = '';\n    while (!this.bytes.done()) {\n      const byte = this.bytes.peek();\n      if (IsWhitespace[byte] || IsDelimiter[byte]) break;\n      name += charFromCode(byte);\n      this.bytes.next();\n    }\n\n    return PDFName.of(name);\n  }\n\n  protected parseArray(): PDFArray {\n    this.bytes.assertNext(CharCodes.LeftSquareBracket);\n    this.skipWhitespaceAndComments();\n\n    const pdfArray = PDFArray.withContext(this.context);\n    while (this.bytes.peek() !== CharCodes.RightSquareBracket) {\n      const element = this.parseObject();\n      pdfArray.push(element);\n      this.skipWhitespaceAndComments();\n    }\n    this.bytes.assertNext(CharCodes.RightSquareBracket);\n    return pdfArray;\n  }\n\n  protected parseDict(): PDFDict {\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.skipWhitespaceAndComments();\n\n    const dict: DictMap = new Map();\n\n    while (\n      !this.bytes.done() &&\n      this.bytes.peek() !== CharCodes.GreaterThan &&\n      this.bytes.peekAhead(1) !== CharCodes.GreaterThan\n    ) {\n      const key = this.parseName();\n      const value = this.parseObject();\n      dict.set(key, value);\n      this.skipWhitespaceAndComments();\n    }\n\n    this.skipWhitespaceAndComments();\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    this.bytes.assertNext(CharCodes.GreaterThan);\n\n    const Type = dict.get(PDFName.of('Type'));\n\n    if (Type === PDFName.of('Catalog')) {\n      return PDFCatalog.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Pages')) {\n      return PDFPageTree.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Page')) {\n      return PDFPageLeaf.fromMapWithContext(dict, this.context);\n    } else {\n      return PDFDict.fromMapWithContext(dict, this.context);\n    }\n  }\n\n  protected parseDictOrStream(): PDFDict | PDFStream {\n    const startPos = this.bytes.position();\n\n    const dict = this.parseDict();\n\n    this.skipWhitespaceAndComments();\n\n    if (\n      !this.matchKeyword(Keywords.streamEOF1) &&\n      !this.matchKeyword(Keywords.streamEOF2) &&\n      !this.matchKeyword(Keywords.streamEOF3) &&\n      !this.matchKeyword(Keywords.streamEOF4) &&\n      !this.matchKeyword(Keywords.stream)\n    ) {\n      return dict;\n    }\n\n    const start = this.bytes.offset();\n    let end: number;\n\n    const Length = dict.get(PDFName.of('Length'));\n    if (Length instanceof PDFNumber) {\n      end = start + Length.asNumber();\n      this.bytes.moveTo(end);\n      this.skipWhitespaceAndComments();\n      if (!this.matchKeyword(Keywords.endstream)) {\n        this.bytes.moveTo(start);\n        end = this.findEndOfStreamFallback(startPos);\n      }\n    } else {\n      end = this.findEndOfStreamFallback(startPos);\n    }\n\n    const contents = this.bytes.slice(start, end);\n\n    return PDFRawStream.of(dict, contents);\n  }\n\n  protected findEndOfStreamFallback(startPos: Position) {\n    // Move to end of stream, while handling nested streams\n    let nestingLvl = 1;\n    let end = this.bytes.offset();\n\n    while (!this.bytes.done()) {\n      end = this.bytes.offset();\n\n      if (this.matchKeyword(Keywords.stream)) {\n        nestingLvl += 1;\n      } else if (\n        this.matchKeyword(Keywords.EOF1endstream) ||\n        this.matchKeyword(Keywords.EOF2endstream) ||\n        this.matchKeyword(Keywords.EOF3endstream) ||\n        this.matchKeyword(Keywords.endstream)\n      ) {\n        nestingLvl -= 1;\n      } else {\n        this.bytes.next();\n      }\n\n      if (nestingLvl === 0) break;\n    }\n\n    if (nestingLvl !== 0) throw new PDFStreamParsingError(startPos);\n\n    return end;\n  }\n}\n\nexport default PDFObjectParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}