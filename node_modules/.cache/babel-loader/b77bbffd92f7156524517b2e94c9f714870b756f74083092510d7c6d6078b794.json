{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar PDFDict_1 = tslib_1.__importDefault(require(\"../objects/PDFDict\"));\nvar PDFName_1 = tslib_1.__importDefault(require(\"../objects/PDFName\"));\nvar PDFAcroField_1 = tslib_1.__importDefault(require(\"./PDFAcroField\"));\nvar PDFWidgetAnnotation_1 = tslib_1.__importDefault(require(\"../annotation/PDFWidgetAnnotation\"));\nvar errors_1 = require(\"../errors\");\nvar PDFAcroTerminal = /** @class */function (_super) {\n  tslib_1.__extends(PDFAcroTerminal, _super);\n  function PDFAcroTerminal() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  PDFAcroTerminal.prototype.FT = function () {\n    var nameOrRef = this.getInheritableAttribute(PDFName_1.default.of('FT'));\n    return this.dict.context.lookup(nameOrRef, PDFName_1.default);\n  };\n  PDFAcroTerminal.prototype.getWidgets = function () {\n    var kidDicts = this.Kids();\n    // This field is itself a widget\n    if (!kidDicts) return [PDFWidgetAnnotation_1.default.fromDict(this.dict)];\n    // This field's kids are its widgets\n    var widgets = new Array(kidDicts.size());\n    for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {\n      var dict = kidDicts.lookup(idx, PDFDict_1.default);\n      widgets[idx] = PDFWidgetAnnotation_1.default.fromDict(dict);\n    }\n    return widgets;\n  };\n  PDFAcroTerminal.prototype.addWidget = function (ref) {\n    var Kids = this.normalizedEntries().Kids;\n    Kids.push(ref);\n  };\n  PDFAcroTerminal.prototype.removeWidget = function (idx) {\n    var kidDicts = this.Kids();\n    if (!kidDicts) {\n      // This field is itself a widget\n      if (idx !== 0) throw new errors_1.IndexOutOfBoundsError(idx, 0, 0);\n      this.setKids([]);\n    } else {\n      // This field's kids are its widgets\n      if (idx < 0 || idx > kidDicts.size()) {\n        throw new errors_1.IndexOutOfBoundsError(idx, 0, kidDicts.size());\n      }\n      kidDicts.remove(idx);\n    }\n  };\n  PDFAcroTerminal.prototype.normalizedEntries = function () {\n    var Kids = this.Kids();\n    // If this field is itself a widget (because it was only rendered once in\n    // the document, so the field and widget properties were merged) then we\n    // add itself to the `Kids` array. The alternative would be to try\n    // splitting apart the widget properties and creating a separate object\n    // for them.\n    if (!Kids) {\n      Kids = this.dict.context.obj([this.ref]);\n      this.dict.set(PDFName_1.default.of('Kids'), Kids);\n    }\n    return {\n      Kids: Kids\n    };\n  };\n  PDFAcroTerminal.fromDict = function (dict, ref) {\n    return new PDFAcroTerminal(dict, ref);\n  };\n  return PDFAcroTerminal;\n}(PDFAcroField_1.default);\nexports.default = PDFAcroTerminal;","map":{"version":3,"names":["PDFDict_1","tslib_1","__importDefault","require","PDFName_1","PDFAcroField_1","PDFWidgetAnnotation_1","errors_1","PDFAcroTerminal","_super","__extends","prototype","FT","nameOrRef","getInheritableAttribute","default","of","dict","context","lookup","getWidgets","kidDicts","Kids","fromDict","widgets","Array","size","idx","len","addWidget","ref","normalizedEntries","push","removeWidget","IndexOutOfBoundsError","setKids","remove","obj","set","exports"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/acroform/PDFAcroTerminal.ts"],"sourcesContent":["import PDFDict from 'src/core/objects/PDFDict';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFRef from 'src/core/objects/PDFRef';\nimport PDFAcroField from 'src/core/acroform/PDFAcroField';\nimport PDFWidgetAnnotation from 'src/core/annotation/PDFWidgetAnnotation';\nimport { IndexOutOfBoundsError } from 'src/core/errors';\n\nclass PDFAcroTerminal extends PDFAcroField {\n  static fromDict = (dict: PDFDict, ref: PDFRef) =>\n    new PDFAcroTerminal(dict, ref);\n\n  FT(): PDFName {\n    const nameOrRef = this.getInheritableAttribute(PDFName.of('FT'));\n    return this.dict.context.lookup(nameOrRef, PDFName);\n  }\n\n  getWidgets(): PDFWidgetAnnotation[] {\n    const kidDicts = this.Kids();\n\n    // This field is itself a widget\n    if (!kidDicts) return [PDFWidgetAnnotation.fromDict(this.dict)];\n\n    // This field's kids are its widgets\n    const widgets = new Array<PDFWidgetAnnotation>(kidDicts.size());\n    for (let idx = 0, len = kidDicts.size(); idx < len; idx++) {\n      const dict = kidDicts.lookup(idx, PDFDict);\n      widgets[idx] = PDFWidgetAnnotation.fromDict(dict);\n    }\n\n    return widgets;\n  }\n\n  addWidget(ref: PDFRef) {\n    const { Kids } = this.normalizedEntries();\n    Kids.push(ref);\n  }\n\n  removeWidget(idx: number) {\n    const kidDicts = this.Kids();\n\n    if (!kidDicts) {\n      // This field is itself a widget\n      if (idx !== 0) throw new IndexOutOfBoundsError(idx, 0, 0);\n      this.setKids([]);\n    } else {\n      // This field's kids are its widgets\n      if (idx < 0 || idx > kidDicts.size()) {\n        throw new IndexOutOfBoundsError(idx, 0, kidDicts.size());\n      }\n      kidDicts.remove(idx);\n    }\n  }\n\n  normalizedEntries() {\n    let Kids = this.Kids();\n\n    // If this field is itself a widget (because it was only rendered once in\n    // the document, so the field and widget properties were merged) then we\n    // add itself to the `Kids` array. The alternative would be to try\n    // splitting apart the widget properties and creating a separate object\n    // for them.\n    if (!Kids) {\n      Kids = this.dict.context.obj([this.ref]);\n      this.dict.set(PDFName.of('Kids'), Kids);\n    }\n\n    return { Kids };\n  }\n}\n\nexport default PDFAcroTerminal;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}