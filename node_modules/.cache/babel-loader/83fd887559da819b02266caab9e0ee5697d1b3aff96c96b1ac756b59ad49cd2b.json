{"ast":null,"code":"/*\n * Copyright 2012 Mozilla Foundation\n *\n * The Stream class contained in this file is a TypeScript port of the\n * JavaScript Stream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\nvar Stream = /** @class */function () {\n  function Stream(buffer, start, length) {\n    this.bytes = buffer;\n    this.start = start || 0;\n    this.pos = this.start;\n    this.end = !!start && !!length ? start + length : this.bytes.length;\n  }\n  Object.defineProperty(Stream.prototype, \"length\", {\n    get: function () {\n      return this.end - this.start;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Stream.prototype, \"isEmpty\", {\n    get: function () {\n      return this.length === 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Stream.prototype.getByte = function () {\n    if (this.pos >= this.end) {\n      return -1;\n    }\n    return this.bytes[this.pos++];\n  };\n  Stream.prototype.getUint16 = function () {\n    var b0 = this.getByte();\n    var b1 = this.getByte();\n    if (b0 === -1 || b1 === -1) {\n      return -1;\n    }\n    return (b0 << 8) + b1;\n  };\n  Stream.prototype.getInt32 = function () {\n    var b0 = this.getByte();\n    var b1 = this.getByte();\n    var b2 = this.getByte();\n    var b3 = this.getByte();\n    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\n  };\n  // Returns subarray of original buffer, should only be read.\n  Stream.prototype.getBytes = function (length, forceClamped) {\n    if (forceClamped === void 0) {\n      forceClamped = false;\n    }\n    var bytes = this.bytes;\n    var pos = this.pos;\n    var strEnd = this.end;\n    if (!length) {\n      var subarray = bytes.subarray(pos, strEnd);\n      // `this.bytes` is always a `Uint8Array` here.\n      return forceClamped ? new Uint8ClampedArray(subarray) : subarray;\n    } else {\n      var end = pos + length;\n      if (end > strEnd) {\n        end = strEnd;\n      }\n      this.pos = end;\n      var subarray = bytes.subarray(pos, end);\n      // `this.bytes` is always a `Uint8Array` here.\n      return forceClamped ? new Uint8ClampedArray(subarray) : subarray;\n    }\n  };\n  Stream.prototype.peekByte = function () {\n    var peekedByte = this.getByte();\n    this.pos--;\n    return peekedByte;\n  };\n  Stream.prototype.peekBytes = function (length, forceClamped) {\n    if (forceClamped === void 0) {\n      forceClamped = false;\n    }\n    var bytes = this.getBytes(length, forceClamped);\n    this.pos -= bytes.length;\n    return bytes;\n  };\n  Stream.prototype.skip = function (n) {\n    if (!n) {\n      n = 1;\n    }\n    this.pos += n;\n  };\n  Stream.prototype.reset = function () {\n    this.pos = this.start;\n  };\n  Stream.prototype.moveStart = function () {\n    this.start = this.pos;\n  };\n  Stream.prototype.makeSubStream = function (start, length) {\n    return new Stream(this.bytes, start, length);\n  };\n  Stream.prototype.decode = function () {\n    return this.bytes;\n  };\n  return Stream;\n}();\nexport default Stream;","map":{"version":3,"names":["Stream","buffer","start","length","bytes","pos","end","Object","defineProperty","prototype","get","getByte","getUint16","b0","b1","getInt32","b2","b3","getBytes","forceClamped","strEnd","subarray","Uint8ClampedArray","peekByte","peekedByte","peekBytes","skip","n","reset","moveStart","makeSubStream","decode"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/streams/Stream.ts"],"sourcesContent":["/*\n * Copyright 2012 Mozilla Foundation\n *\n * The Stream class contained in this file is a TypeScript port of the\n * JavaScript Stream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\n\nexport interface StreamType {\n  isEmpty: boolean;\n  getByte(): number;\n  getUint16(): number;\n  getInt32(): number;\n  getBytes(\n    length: number,\n    forceClamped?: boolean,\n  ): Uint8Array | Uint8ClampedArray;\n  peekByte(): number;\n  peekBytes(\n    length: number,\n    forceClamped?: boolean,\n  ): Uint8Array | Uint8ClampedArray;\n  skip(n: number): void;\n  reset(): void;\n  makeSubStream(start: number, length: number): StreamType;\n  decode(): Uint8Array;\n}\n\nclass Stream implements StreamType {\n  private bytes: Uint8Array;\n  private start: number;\n  private pos: number;\n  private end: number;\n\n  constructor(buffer: Uint8Array, start?: number, length?: number) {\n    this.bytes = buffer;\n    this.start = start || 0;\n    this.pos = this.start;\n    this.end = !!start && !!length ? start + length : this.bytes.length;\n  }\n\n  get length() {\n    return this.end - this.start;\n  }\n\n  get isEmpty() {\n    return this.length === 0;\n  }\n\n  getByte() {\n    if (this.pos >= this.end) {\n      return -1;\n    }\n    return this.bytes[this.pos++];\n  }\n\n  getUint16() {\n    const b0 = this.getByte();\n    const b1 = this.getByte();\n    if (b0 === -1 || b1 === -1) {\n      return -1;\n    }\n    return (b0 << 8) + b1;\n  }\n\n  getInt32() {\n    const b0 = this.getByte();\n    const b1 = this.getByte();\n    const b2 = this.getByte();\n    const b3 = this.getByte();\n    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\n  }\n\n  // Returns subarray of original buffer, should only be read.\n  getBytes(length: number, forceClamped = false) {\n    const bytes = this.bytes;\n    const pos = this.pos;\n    const strEnd = this.end;\n\n    if (!length) {\n      const subarray = bytes.subarray(pos, strEnd);\n      // `this.bytes` is always a `Uint8Array` here.\n      return forceClamped ? new Uint8ClampedArray(subarray) : subarray;\n    } else {\n      let end = pos + length;\n      if (end > strEnd) {\n        end = strEnd;\n      }\n      this.pos = end;\n      const subarray = bytes.subarray(pos, end);\n      // `this.bytes` is always a `Uint8Array` here.\n      return forceClamped ? new Uint8ClampedArray(subarray) : subarray;\n    }\n  }\n\n  peekByte() {\n    const peekedByte = this.getByte();\n    this.pos--;\n    return peekedByte;\n  }\n\n  peekBytes(length: number, forceClamped = false) {\n    const bytes = this.getBytes(length, forceClamped);\n    this.pos -= bytes.length;\n    return bytes;\n  }\n\n  skip(n: number) {\n    if (!n) {\n      n = 1;\n    }\n    this.pos += n;\n  }\n\n  reset() {\n    this.pos = this.start;\n  }\n\n  moveStart() {\n    this.start = this.pos;\n  }\n\n  makeSubStream(start: number, length: number) {\n    return new Stream(this.bytes, start, length);\n  }\n\n  decode(): Uint8Array {\n    return this.bytes;\n  }\n}\n\nexport default Stream;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}