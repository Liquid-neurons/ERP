{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar PDFCrossRefSection_1 = tslib_1.__importDefault(require(\"../document/PDFCrossRefSection\"));\nvar PDFHeader_1 = tslib_1.__importDefault(require(\"../document/PDFHeader\"));\nvar PDFTrailer_1 = tslib_1.__importDefault(require(\"../document/PDFTrailer\"));\nvar errors_1 = require(\"../errors\");\nvar PDFDict_1 = tslib_1.__importDefault(require(\"../objects/PDFDict\"));\nvar PDFInvalidObject_1 = tslib_1.__importDefault(require(\"../objects/PDFInvalidObject\"));\nvar PDFName_1 = tslib_1.__importDefault(require(\"../objects/PDFName\"));\nvar PDFRawStream_1 = tslib_1.__importDefault(require(\"../objects/PDFRawStream\"));\nvar PDFRef_1 = tslib_1.__importDefault(require(\"../objects/PDFRef\"));\nvar ByteStream_1 = tslib_1.__importDefault(require(\"./ByteStream\"));\nvar PDFObjectParser_1 = tslib_1.__importDefault(require(\"./PDFObjectParser\"));\nvar PDFObjectStreamParser_1 = tslib_1.__importDefault(require(\"./PDFObjectStreamParser\"));\nvar PDFXRefStreamParser_1 = tslib_1.__importDefault(require(\"./PDFXRefStreamParser\"));\nvar PDFContext_1 = tslib_1.__importDefault(require(\"../PDFContext\"));\nvar CharCodes_1 = tslib_1.__importDefault(require(\"../syntax/CharCodes\"));\nvar Keywords_1 = require(\"../syntax/Keywords\");\nvar Numeric_1 = require(\"../syntax/Numeric\");\nvar utils_1 = require(\"../../utils\");\nvar PDFParser = /** @class */function (_super) {\n  tslib_1.__extends(PDFParser, _super);\n  function PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    if (objectsPerTick === void 0) {\n      objectsPerTick = Infinity;\n    }\n    if (throwOnInvalidObject === void 0) {\n      throwOnInvalidObject = false;\n    }\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    var _this = _super.call(this, ByteStream_1.default.of(pdfBytes), PDFContext_1.default.create(), capNumbers) || this;\n    _this.alreadyParsed = false;\n    _this.parsedObjects = 0;\n    _this.shouldWaitForTick = function () {\n      _this.parsedObjects += 1;\n      return _this.parsedObjects % _this.objectsPerTick === 0;\n    };\n    _this.objectsPerTick = objectsPerTick;\n    _this.throwOnInvalidObject = throwOnInvalidObject;\n    return _this;\n  }\n  PDFParser.prototype.parseDocument = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var prevOffset, offset;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.alreadyParsed) {\n              throw new errors_1.ReparseError('PDFParser', 'parseDocument');\n            }\n            this.alreadyParsed = true;\n            this.context.header = this.parseHeader();\n            _a.label = 1;\n          case 1:\n            if (!!this.bytes.done()) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.parseDocumentSection()];\n          case 2:\n            _a.sent();\n            offset = this.bytes.offset();\n            if (offset === prevOffset) {\n              throw new errors_1.StalledParserError(this.bytes.position());\n            }\n            prevOffset = offset;\n            return [3 /*break*/, 1];\n          case 3:\n            this.maybeRecoverRoot();\n            if (this.context.lookup(PDFRef_1.default.of(0))) {\n              console.warn('Removing parsed object: 0 0 R');\n              this.context.delete(PDFRef_1.default.of(0));\n            }\n            return [2 /*return*/, this.context];\n        }\n      });\n    });\n  };\n  PDFParser.prototype.maybeRecoverRoot = function () {\n    var isValidCatalog = function (obj) {\n      return obj instanceof PDFDict_1.default && obj.lookup(PDFName_1.default.of('Type')) === PDFName_1.default.of('Catalog');\n    };\n    var catalog = this.context.lookup(this.context.trailerInfo.Root);\n    if (!isValidCatalog(catalog)) {\n      var indirectObjects = this.context.enumerateIndirectObjects();\n      for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {\n        var _a = indirectObjects[idx],\n          ref = _a[0],\n          object = _a[1];\n        if (isValidCatalog(object)) {\n          this.context.trailerInfo.Root = ref;\n        }\n      }\n    }\n  };\n  PDFParser.prototype.parseHeader = function () {\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords_1.Keywords.header)) {\n        var major = this.parseRawInt();\n        this.bytes.assertNext(CharCodes_1.default.Period);\n        var minor = this.parseRawInt();\n        var header = PDFHeader_1.default.forVersion(major, minor);\n        this.skipBinaryHeaderComment();\n        return header;\n      }\n      this.bytes.next();\n    }\n    throw new errors_1.MissingPDFHeaderError(this.bytes.position());\n  };\n  PDFParser.prototype.parseIndirectObjectHeader = function () {\n    this.skipWhitespaceAndComments();\n    var objectNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    var generationNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords_1.Keywords.obj)) {\n      throw new errors_1.MissingKeywordError(this.bytes.position(), Keywords_1.Keywords.obj);\n    }\n    return PDFRef_1.default.of(objectNumber, generationNumber);\n  };\n  PDFParser.prototype.matchIndirectObjectHeader = function () {\n    var initialOffset = this.bytes.offset();\n    try {\n      this.parseIndirectObjectHeader();\n      return true;\n    } catch (e) {\n      this.bytes.moveTo(initialOffset);\n      return false;\n    }\n  };\n  PDFParser.prototype.parseIndirectObject = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var ref, object;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ref = this.parseIndirectObjectHeader();\n            this.skipWhitespaceAndComments();\n            object = this.parseObject();\n            this.skipWhitespaceAndComments();\n            // if (!this.matchKeyword(Keywords.endobj)) {\n            // throw new MissingKeywordError(this.bytes.position(), Keywords.endobj);\n            // }\n            // TODO: Log a warning if this fails...\n            this.matchKeyword(Keywords_1.Keywords.endobj);\n            if (!(object instanceof PDFRawStream_1.default && object.dict.lookup(PDFName_1.default.of('Type')) === PDFName_1.default.of('ObjStm'))) return [3 /*break*/, 2];\n            return [4 /*yield*/, PDFObjectStreamParser_1.default.forStream(object, this.shouldWaitForTick).parseIntoContext()];\n          case 1:\n            _a.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            if (object instanceof PDFRawStream_1.default && object.dict.lookup(PDFName_1.default.of('Type')) === PDFName_1.default.of('XRef')) {\n              PDFXRefStreamParser_1.default.forStream(object).parseIntoContext();\n            } else {\n              this.context.assign(ref, object);\n            }\n            _a.label = 3;\n          case 3:\n            return [2 /*return*/, ref];\n        }\n      });\n    });\n  };\n  // TODO: Improve and clean this up\n  PDFParser.prototype.tryToParseInvalidIndirectObject = function () {\n    var startPos = this.bytes.position();\n    var msg = \"Trying to parse invalid object: \" + JSON.stringify(startPos) + \")\";\n    if (this.throwOnInvalidObject) throw new Error(msg);\n    console.warn(msg);\n    var ref = this.parseIndirectObjectHeader();\n    console.warn(\"Invalid object ref: \" + ref);\n    this.skipWhitespaceAndComments();\n    var start = this.bytes.offset();\n    var failed = true;\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords_1.Keywords.endobj)) {\n        failed = false;\n      }\n      if (!failed) break;\n      this.bytes.next();\n    }\n    if (failed) throw new errors_1.PDFInvalidObjectParsingError(startPos);\n    var end = this.bytes.offset() - Keywords_1.Keywords.endobj.length;\n    var object = PDFInvalidObject_1.default.of(this.bytes.slice(start, end));\n    this.context.assign(ref, object);\n    return ref;\n  };\n  PDFParser.prototype.parseIndirectObjects = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var initialOffset, e_1;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.skipWhitespaceAndComments();\n            _a.label = 1;\n          case 1:\n            if (!(!this.bytes.done() && Numeric_1.IsDigit[this.bytes.peek()])) return [3 /*break*/, 8];\n            initialOffset = this.bytes.offset();\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.parseIndirectObject()];\n          case 3:\n            _a.sent();\n            return [3 /*break*/, 5];\n          case 4:\n            e_1 = _a.sent();\n            // TODO: Add tracing/logging mechanism to track when this happens!\n            this.bytes.moveTo(initialOffset);\n            this.tryToParseInvalidIndirectObject();\n            return [3 /*break*/, 5];\n          case 5:\n            this.skipWhitespaceAndComments();\n            // TODO: Can this be done only when needed, to avoid harming performance?\n            this.skipJibberish();\n            if (!this.shouldWaitForTick()) return [3 /*break*/, 7];\n            return [4 /*yield*/, utils_1.waitForTick()];\n          case 6:\n            _a.sent();\n            _a.label = 7;\n          case 7:\n            return [3 /*break*/, 1];\n          case 8:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  PDFParser.prototype.maybeParseCrossRefSection = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords_1.Keywords.xref)) return;\n    this.skipWhitespaceAndComments();\n    var objectNumber = -1;\n    var xref = PDFCrossRefSection_1.default.createEmpty();\n    while (!this.bytes.done() && Numeric_1.IsDigit[this.bytes.peek()]) {\n      var firstInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var secondInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var byte = this.bytes.peek();\n      if (byte === CharCodes_1.default.n || byte === CharCodes_1.default.f) {\n        var ref = PDFRef_1.default.of(objectNumber, secondInt);\n        if (this.bytes.next() === CharCodes_1.default.n) {\n          xref.addEntry(ref, firstInt);\n        } else {\n          // this.context.delete(ref);\n          xref.addDeletedEntry(ref, firstInt);\n        }\n        objectNumber += 1;\n      } else {\n        objectNumber = firstInt;\n      }\n      this.skipWhitespaceAndComments();\n    }\n    return xref;\n  };\n  PDFParser.prototype.maybeParseTrailerDict = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords_1.Keywords.trailer)) return;\n    this.skipWhitespaceAndComments();\n    var dict = this.parseDict();\n    var context = this.context;\n    context.trailerInfo = {\n      Root: dict.get(PDFName_1.default.of('Root')) || context.trailerInfo.Root,\n      Encrypt: dict.get(PDFName_1.default.of('Encrypt')) || context.trailerInfo.Encrypt,\n      Info: dict.get(PDFName_1.default.of('Info')) || context.trailerInfo.Info,\n      ID: dict.get(PDFName_1.default.of('ID')) || context.trailerInfo.ID\n    };\n  };\n  PDFParser.prototype.maybeParseTrailer = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords_1.Keywords.startxref)) return;\n    this.skipWhitespaceAndComments();\n    var offset = this.parseRawInt();\n    this.skipWhitespace();\n    this.matchKeyword(Keywords_1.Keywords.eof);\n    this.skipWhitespaceAndComments();\n    this.matchKeyword(Keywords_1.Keywords.eof);\n    this.skipWhitespaceAndComments();\n    return PDFTrailer_1.default.forLastCrossRefSectionOffset(offset);\n  };\n  PDFParser.prototype.parseDocumentSection = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.parseIndirectObjects()];\n          case 1:\n            _a.sent();\n            this.maybeParseCrossRefSection();\n            this.maybeParseTrailerDict();\n            this.maybeParseTrailer();\n            // TODO: Can this be done only when needed, to avoid harming performance?\n            this.skipJibberish();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * This operation is not necessary for valid PDF files. But some invalid PDFs\n   * contain jibberish in between indirect objects. This method is designed to\n   * skip past that jibberish, should it exist, until it reaches the next\n   * indirect object header, an xref table section, or the file trailer.\n   */\n  PDFParser.prototype.skipJibberish = function () {\n    this.skipWhitespaceAndComments();\n    while (!this.bytes.done()) {\n      var initialOffset = this.bytes.offset();\n      var byte = this.bytes.peek();\n      var isAlphaNumeric = byte >= CharCodes_1.default.Space && byte <= CharCodes_1.default.Tilde;\n      if (isAlphaNumeric) {\n        if (this.matchKeyword(Keywords_1.Keywords.xref) || this.matchKeyword(Keywords_1.Keywords.trailer) || this.matchKeyword(Keywords_1.Keywords.startxref) || this.matchIndirectObjectHeader()) {\n          this.bytes.moveTo(initialOffset);\n          break;\n        }\n      }\n      this.bytes.next();\n    }\n  };\n  /**\n   * Skips the binary comment following a PDF header. The specification\n   * defines this binary comment (section 7.5.2 File Header) as a sequence of 4\n   * or more bytes that are 128 or greater, and which are preceded by a \"%\".\n   *\n   * This would imply that to strip out this binary comment, we could check for\n   * a sequence of bytes starting with \"%\", and remove all subsequent bytes that\n   * are 128 or greater. This works for many documents that properly comply with\n   * the spec. But in the wild, there are PDFs that omit the leading \"%\", and\n   * include bytes that are less than 128 (e.g. 0 or 1). So in order to parse\n   * these headers correctly, we just throw out all bytes leading up to the\n   * first indirect object header.\n   */\n  PDFParser.prototype.skipBinaryHeaderComment = function () {\n    this.skipWhitespaceAndComments();\n    try {\n      var initialOffset = this.bytes.offset();\n      this.parseIndirectObjectHeader();\n      this.bytes.moveTo(initialOffset);\n    } catch (e) {\n      this.bytes.next();\n      this.skipWhitespaceAndComments();\n    }\n  };\n  PDFParser.forBytesWithOptions = function (pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    return new PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);\n  };\n  return PDFParser;\n}(PDFObjectParser_1.default);\nexports.default = PDFParser;","map":{"version":3,"names":["PDFCrossRefSection_1","tslib_1","__importDefault","require","PDFHeader_1","PDFTrailer_1","errors_1","PDFDict_1","PDFInvalidObject_1","PDFName_1","PDFRawStream_1","PDFRef_1","ByteStream_1","PDFObjectParser_1","PDFObjectStreamParser_1","PDFXRefStreamParser_1","PDFContext_1","CharCodes_1","Keywords_1","Numeric_1","utils_1","PDFParser","_super","__extends","pdfBytes","objectsPerTick","throwOnInvalidObject","capNumbers","Infinity","_this","call","default","of","create","alreadyParsed","parsedObjects","shouldWaitForTick","prototype","parseDocument","ReparseError","context","header","parseHeader","bytes","done","parseDocumentSection","_a","sent","offset","prevOffset","StalledParserError","position","maybeRecoverRoot","lookup","console","warn","delete","isValidCatalog","obj","catalog","trailerInfo","Root","indirectObjects","enumerateIndirectObjects","idx","len","length","ref","object","matchKeyword","Keywords","major","parseRawInt","assertNext","Period","minor","forVersion","skipBinaryHeaderComment","next","MissingPDFHeaderError","parseIndirectObjectHeader","skipWhitespaceAndComments","objectNumber","generationNumber","MissingKeywordError","matchIndirectObjectHeader","initialOffset","e","moveTo","parseIndirectObject","parseObject","endobj","dict","forStream","parseIntoContext","assign","tryToParseInvalidIndirectObject","startPos","msg","JSON","stringify","Error","start","failed","PDFInvalidObjectParsingError","end","slice","parseIndirectObjects","IsDigit","peek","skipJibberish","waitForTick","maybeParseCrossRefSection","xref","createEmpty","firstInt","secondInt","byte","n","f","addEntry","addDeletedEntry","maybeParseTrailerDict","trailer","parseDict","get","Encrypt","Info","ID","maybeParseTrailer","startxref","skipWhitespace","eof","forLastCrossRefSectionOffset","isAlphaNumeric","Space","Tilde","forBytesWithOptions","exports"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/parser/PDFParser.ts"],"sourcesContent":["import PDFCrossRefSection from 'src/core/document/PDFCrossRefSection';\nimport PDFHeader from 'src/core/document/PDFHeader';\nimport PDFTrailer from 'src/core/document/PDFTrailer';\nimport {\n  MissingKeywordError,\n  MissingPDFHeaderError,\n  PDFInvalidObjectParsingError,\n  ReparseError,\n  StalledParserError,\n} from 'src/core/errors';\nimport PDFDict from 'src/core/objects/PDFDict';\nimport PDFInvalidObject from 'src/core/objects/PDFInvalidObject';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFObject from 'src/core/objects/PDFObject';\nimport PDFRawStream from 'src/core/objects/PDFRawStream';\nimport PDFRef from 'src/core/objects/PDFRef';\nimport ByteStream from 'src/core/parser/ByteStream';\nimport PDFObjectParser from 'src/core/parser/PDFObjectParser';\nimport PDFObjectStreamParser from 'src/core/parser/PDFObjectStreamParser';\nimport PDFXRefStreamParser from 'src/core/parser/PDFXRefStreamParser';\nimport PDFContext from 'src/core/PDFContext';\nimport CharCodes from 'src/core/syntax/CharCodes';\nimport { Keywords } from 'src/core/syntax/Keywords';\nimport { IsDigit } from 'src/core/syntax/Numeric';\nimport { waitForTick } from 'src/utils';\n\nclass PDFParser extends PDFObjectParser {\n  static forBytesWithOptions = (\n    pdfBytes: Uint8Array,\n    objectsPerTick?: number,\n    throwOnInvalidObject?: boolean,\n    capNumbers?: boolean,\n  ) =>\n    new PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);\n\n  private readonly objectsPerTick: number;\n  private readonly throwOnInvalidObject: boolean;\n  private alreadyParsed = false;\n  private parsedObjects = 0;\n\n  constructor(\n    pdfBytes: Uint8Array,\n    objectsPerTick = Infinity,\n    throwOnInvalidObject = false,\n    capNumbers = false,\n  ) {\n    super(ByteStream.of(pdfBytes), PDFContext.create(), capNumbers);\n    this.objectsPerTick = objectsPerTick;\n    this.throwOnInvalidObject = throwOnInvalidObject;\n  }\n\n  async parseDocument(): Promise<PDFContext> {\n    if (this.alreadyParsed) {\n      throw new ReparseError('PDFParser', 'parseDocument');\n    }\n    this.alreadyParsed = true;\n\n    this.context.header = this.parseHeader();\n\n    let prevOffset;\n    while (!this.bytes.done()) {\n      await this.parseDocumentSection();\n      const offset = this.bytes.offset();\n      if (offset === prevOffset) {\n        throw new StalledParserError(this.bytes.position());\n      }\n      prevOffset = offset;\n    }\n\n    this.maybeRecoverRoot();\n\n    if (this.context.lookup(PDFRef.of(0))) {\n      console.warn('Removing parsed object: 0 0 R');\n      this.context.delete(PDFRef.of(0));\n    }\n\n    return this.context;\n  }\n\n  private maybeRecoverRoot(): void {\n    const isValidCatalog = (obj?: PDFObject) =>\n      obj instanceof PDFDict &&\n      obj.lookup(PDFName.of('Type')) === PDFName.of('Catalog');\n\n    const catalog = this.context.lookup(this.context.trailerInfo.Root);\n\n    if (!isValidCatalog(catalog)) {\n      const indirectObjects = this.context.enumerateIndirectObjects();\n      for (let idx = 0, len = indirectObjects.length; idx < len; idx++) {\n        const [ref, object] = indirectObjects[idx];\n        if (isValidCatalog(object)) {\n          this.context.trailerInfo.Root = ref;\n        }\n      }\n    }\n  }\n\n  private parseHeader(): PDFHeader {\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.header)) {\n        const major = this.parseRawInt();\n        this.bytes.assertNext(CharCodes.Period);\n        const minor = this.parseRawInt();\n        const header = PDFHeader.forVersion(major, minor);\n        this.skipBinaryHeaderComment();\n        return header;\n      }\n      this.bytes.next();\n    }\n\n    throw new MissingPDFHeaderError(this.bytes.position());\n  }\n\n  private parseIndirectObjectHeader(): PDFRef {\n    this.skipWhitespaceAndComments();\n    const objectNumber = this.parseRawInt();\n\n    this.skipWhitespaceAndComments();\n    const generationNumber = this.parseRawInt();\n\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.obj)) {\n      throw new MissingKeywordError(this.bytes.position(), Keywords.obj);\n    }\n\n    return PDFRef.of(objectNumber, generationNumber);\n  }\n\n  private matchIndirectObjectHeader(): boolean {\n    const initialOffset = this.bytes.offset();\n    try {\n      this.parseIndirectObjectHeader();\n      return true;\n    } catch (e) {\n      this.bytes.moveTo(initialOffset);\n      return false;\n    }\n  }\n\n  private shouldWaitForTick = () => {\n    this.parsedObjects += 1;\n    return this.parsedObjects % this.objectsPerTick === 0;\n  };\n\n  private async parseIndirectObject(): Promise<PDFRef> {\n    const ref = this.parseIndirectObjectHeader();\n\n    this.skipWhitespaceAndComments();\n    const object = this.parseObject();\n\n    this.skipWhitespaceAndComments();\n    // if (!this.matchKeyword(Keywords.endobj)) {\n    // throw new MissingKeywordError(this.bytes.position(), Keywords.endobj);\n    // }\n\n    // TODO: Log a warning if this fails...\n    this.matchKeyword(Keywords.endobj);\n\n    if (\n      object instanceof PDFRawStream &&\n      object.dict.lookup(PDFName.of('Type')) === PDFName.of('ObjStm')\n    ) {\n      await PDFObjectStreamParser.forStream(\n        object,\n        this.shouldWaitForTick,\n      ).parseIntoContext();\n    } else if (\n      object instanceof PDFRawStream &&\n      object.dict.lookup(PDFName.of('Type')) === PDFName.of('XRef')\n    ) {\n      PDFXRefStreamParser.forStream(object).parseIntoContext();\n    } else {\n      this.context.assign(ref, object);\n    }\n\n    return ref;\n  }\n\n  // TODO: Improve and clean this up\n  private tryToParseInvalidIndirectObject() {\n    const startPos = this.bytes.position();\n\n    const msg = `Trying to parse invalid object: ${JSON.stringify(startPos)})`;\n    if (this.throwOnInvalidObject) throw new Error(msg);\n    console.warn(msg);\n\n    const ref = this.parseIndirectObjectHeader();\n\n    console.warn(`Invalid object ref: ${ref}`);\n\n    this.skipWhitespaceAndComments();\n    const start = this.bytes.offset();\n\n    let failed = true;\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.endobj)) {\n        failed = false;\n      }\n      if (!failed) break;\n      this.bytes.next();\n    }\n\n    if (failed) throw new PDFInvalidObjectParsingError(startPos);\n\n    const end = this.bytes.offset() - Keywords.endobj.length;\n\n    const object = PDFInvalidObject.of(this.bytes.slice(start, end));\n    this.context.assign(ref, object);\n\n    return ref;\n  }\n\n  private async parseIndirectObjects(): Promise<void> {\n    this.skipWhitespaceAndComments();\n\n    while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\n      const initialOffset = this.bytes.offset();\n\n      try {\n        await this.parseIndirectObject();\n      } catch (e) {\n        // TODO: Add tracing/logging mechanism to track when this happens!\n        this.bytes.moveTo(initialOffset);\n        this.tryToParseInvalidIndirectObject();\n      }\n      this.skipWhitespaceAndComments();\n\n      // TODO: Can this be done only when needed, to avoid harming performance?\n      this.skipJibberish();\n\n      if (this.shouldWaitForTick()) await waitForTick();\n    }\n  }\n\n  private maybeParseCrossRefSection(): PDFCrossRefSection | void {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.xref)) return;\n    this.skipWhitespaceAndComments();\n\n    let objectNumber = -1;\n    const xref = PDFCrossRefSection.createEmpty();\n\n    while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\n      const firstInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n\n      const secondInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n\n      const byte = this.bytes.peek();\n      if (byte === CharCodes.n || byte === CharCodes.f) {\n        const ref = PDFRef.of(objectNumber, secondInt);\n        if (this.bytes.next() === CharCodes.n) {\n          xref.addEntry(ref, firstInt);\n        } else {\n          // this.context.delete(ref);\n          xref.addDeletedEntry(ref, firstInt);\n        }\n        objectNumber += 1;\n      } else {\n        objectNumber = firstInt;\n      }\n      this.skipWhitespaceAndComments();\n    }\n\n    return xref;\n  }\n\n  private maybeParseTrailerDict(): void {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.trailer)) return;\n    this.skipWhitespaceAndComments();\n\n    const dict = this.parseDict();\n\n    const { context } = this;\n    context.trailerInfo = {\n      Root: dict.get(PDFName.of('Root')) || context.trailerInfo.Root,\n      Encrypt: dict.get(PDFName.of('Encrypt')) || context.trailerInfo.Encrypt,\n      Info: dict.get(PDFName.of('Info')) || context.trailerInfo.Info,\n      ID: dict.get(PDFName.of('ID')) || context.trailerInfo.ID,\n    };\n  }\n\n  private maybeParseTrailer(): PDFTrailer | void {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.startxref)) return;\n    this.skipWhitespaceAndComments();\n\n    const offset = this.parseRawInt();\n\n    this.skipWhitespace();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n\n    return PDFTrailer.forLastCrossRefSectionOffset(offset);\n  }\n\n  private async parseDocumentSection(): Promise<void> {\n    await this.parseIndirectObjects();\n    this.maybeParseCrossRefSection();\n    this.maybeParseTrailerDict();\n    this.maybeParseTrailer();\n\n    // TODO: Can this be done only when needed, to avoid harming performance?\n    this.skipJibberish();\n  }\n\n  /**\n   * This operation is not necessary for valid PDF files. But some invalid PDFs\n   * contain jibberish in between indirect objects. This method is designed to\n   * skip past that jibberish, should it exist, until it reaches the next\n   * indirect object header, an xref table section, or the file trailer.\n   */\n  private skipJibberish(): void {\n    this.skipWhitespaceAndComments();\n    while (!this.bytes.done()) {\n      const initialOffset = this.bytes.offset();\n      const byte = this.bytes.peek();\n      const isAlphaNumeric = byte >= CharCodes.Space && byte <= CharCodes.Tilde;\n      if (isAlphaNumeric) {\n        if (\n          this.matchKeyword(Keywords.xref) ||\n          this.matchKeyword(Keywords.trailer) ||\n          this.matchKeyword(Keywords.startxref) ||\n          this.matchIndirectObjectHeader()\n        ) {\n          this.bytes.moveTo(initialOffset);\n          break;\n        }\n      }\n      this.bytes.next();\n    }\n  }\n\n  /**\n   * Skips the binary comment following a PDF header. The specification\n   * defines this binary comment (section 7.5.2 File Header) as a sequence of 4\n   * or more bytes that are 128 or greater, and which are preceded by a \"%\".\n   *\n   * This would imply that to strip out this binary comment, we could check for\n   * a sequence of bytes starting with \"%\", and remove all subsequent bytes that\n   * are 128 or greater. This works for many documents that properly comply with\n   * the spec. But in the wild, there are PDFs that omit the leading \"%\", and\n   * include bytes that are less than 128 (e.g. 0 or 1). So in order to parse\n   * these headers correctly, we just throw out all bytes leading up to the\n   * first indirect object header.\n   */\n  private skipBinaryHeaderComment(): void {\n    this.skipWhitespaceAndComments();\n    try {\n      const initialOffset = this.bytes.offset();\n      this.parseIndirectObjectHeader();\n      this.bytes.moveTo(initialOffset);\n    } catch (e) {\n      this.bytes.next();\n      this.skipWhitespaceAndComments();\n    }\n  }\n}\n\nexport default PDFParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}