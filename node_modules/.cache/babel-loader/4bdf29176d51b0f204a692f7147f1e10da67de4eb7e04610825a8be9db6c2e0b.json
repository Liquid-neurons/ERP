{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar PDFDocument_1 = tslib_1.__importDefault(require(\"./PDFDocument\"));\nvar core_1 = require(\"../core\");\nvar utils_1 = require(\"../utils\");\n/**\n * Represents a font that has been embedded in a [[PDFDocument]].\n */\nvar PDFFont = /** @class */function () {\n  function PDFFont(ref, doc, embedder) {\n    this.modified = true;\n    utils_1.assertIs(ref, 'ref', [[core_1.PDFRef, 'PDFRef']]);\n    utils_1.assertIs(doc, 'doc', [[PDFDocument_1.default, 'PDFDocument']]);\n    utils_1.assertIs(embedder, 'embedder', [[core_1.CustomFontEmbedder, 'CustomFontEmbedder'], [core_1.StandardFontEmbedder, 'StandardFontEmbedder']]);\n    this.ref = ref;\n    this.doc = doc;\n    this.name = embedder.fontName;\n    this.embedder = embedder;\n  }\n  /**\n   * > **NOTE:** You probably don't need to call this method directly. The\n   * > [[PDFPage.drawText]] method will automatically encode the text it is\n   * > given.\n   *\n   * Encodes a string of text in this font.\n   *\n   * @param text The text to be encoded.\n   * @returns The encoded text as a hex string.\n   */\n  PDFFont.prototype.encodeText = function (text) {\n    utils_1.assertIs(text, 'text', ['string']);\n    this.modified = true;\n    return this.embedder.encodeText(text);\n  };\n  /**\n   * Measure the width of a string of text drawn in this font at a given size.\n   * For example:\n   * ```js\n   * const width = font.widthOfTextAtSize('Foo Bar Qux Baz', 36)\n   * ```\n   * @param text The string of text to be measured.\n   * @param size The font size to be used for this measurement.\n   * @returns The width of the string of text when drawn in this font at the\n   *          given size.\n   */\n  PDFFont.prototype.widthOfTextAtSize = function (text, size) {\n    utils_1.assertIs(text, 'text', ['string']);\n    utils_1.assertIs(size, 'size', ['number']);\n    return this.embedder.widthOfTextAtSize(text, size);\n  };\n  /**\n   * Measure the height of this font at a given size. For example:\n   * ```js\n   * const height = font.heightAtSize(24)\n   * ```\n   *\n   * The `options.descender` value controls whether or not the font's\n   * descender is included in the height calculation.\n   *\n   * @param size The font size to be used for this measurement.\n   * @param options The options to be used when computing this measurement.\n   * @returns The height of this font at the given size.\n   */\n  PDFFont.prototype.heightAtSize = function (size, options) {\n    var _a;\n    utils_1.assertIs(size, 'size', ['number']);\n    utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.descender, 'options.descender', ['boolean']);\n    return this.embedder.heightOfFontAtSize(size, {\n      descender: (_a = options === null || options === void 0 ? void 0 : options.descender) !== null && _a !== void 0 ? _a : true\n    });\n  };\n  /**\n   * Compute the font size at which this font is a given height. For example:\n   * ```js\n   * const fontSize = font.sizeAtHeight(12)\n   * ```\n   * @param height The height to be used for this calculation.\n   * @returns The font size at which this font is the given height.\n   */\n  PDFFont.prototype.sizeAtHeight = function (height) {\n    utils_1.assertIs(height, 'height', ['number']);\n    return this.embedder.sizeOfFontAtHeight(height);\n  };\n  /**\n   * Get the set of unicode code points that can be represented by this font.\n   * @returns The set of unicode code points supported by this font.\n   */\n  PDFFont.prototype.getCharacterSet = function () {\n    if (this.embedder instanceof core_1.StandardFontEmbedder) {\n      return this.embedder.encoding.supportedCodePoints;\n    } else {\n      return this.embedder.font.characterSet;\n    }\n  };\n  /**\n   * > **NOTE:** You probably don't need to call this method directly. The\n   * > [[PDFDocument.save]] and [[PDFDocument.saveAsBase64]] methods will\n   * > automatically ensure all fonts get embedded.\n   *\n   * Embed this font in its document.\n   *\n   * @returns Resolves when the embedding is complete.\n   */\n  PDFFont.prototype.embed = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.modified) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.embedder.embedIntoContext(this.doc.context, this.ref)];\n          case 1:\n            _a.sent();\n            this.modified = false;\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * > **NOTE:** You probably don't want to call this method directly. Instead,\n   * > consider using the [[PDFDocument.embedFont]] and\n   * > [[PDFDocument.embedStandardFont]] methods, which will create instances\n   * > of [[PDFFont]] for you.\n   *\n   * Create an instance of [[PDFFont]] from an existing ref and embedder\n   *\n   * @param ref The unique reference for this font.\n   * @param doc The document to which the font will belong.\n   * @param embedder The embedder that will be used to embed the font.\n   */\n  PDFFont.of = function (ref, doc, embedder) {\n    return new PDFFont(ref, doc, embedder);\n  };\n  return PDFFont;\n}();\nexports.default = PDFFont;","map":{"version":3,"names":["PDFDocument_1","tslib_1","__importDefault","require","core_1","utils_1","PDFFont","ref","doc","embedder","modified","assertIs","PDFRef","default","CustomFontEmbedder","StandardFontEmbedder","name","fontName","prototype","encodeText","text","widthOfTextAtSize","size","heightAtSize","options","assertOrUndefined","descender","heightOfFontAtSize","_a","sizeAtHeight","height","sizeOfFontAtHeight","getCharacterSet","encoding","supportedCodePoints","font","characterSet","embed","embedIntoContext","context","sent","of"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/api/PDFFont.ts"],"sourcesContent":["import Embeddable from 'src/api//Embeddable';\nimport PDFDocument from 'src/api/PDFDocument';\nimport {\n  CustomFontEmbedder,\n  PDFHexString,\n  PDFRef,\n  StandardFontEmbedder,\n} from 'src/core';\nimport { assertIs, assertOrUndefined } from 'src/utils';\n\nexport type FontEmbedder = CustomFontEmbedder | StandardFontEmbedder;\n\n/**\n * Represents a font that has been embedded in a [[PDFDocument]].\n */\nexport default class PDFFont implements Embeddable {\n  /**\n   * > **NOTE:** You probably don't want to call this method directly. Instead,\n   * > consider using the [[PDFDocument.embedFont]] and\n   * > [[PDFDocument.embedStandardFont]] methods, which will create instances\n   * > of [[PDFFont]] for you.\n   *\n   * Create an instance of [[PDFFont]] from an existing ref and embedder\n   *\n   * @param ref The unique reference for this font.\n   * @param doc The document to which the font will belong.\n   * @param embedder The embedder that will be used to embed the font.\n   */\n  static of = (ref: PDFRef, doc: PDFDocument, embedder: FontEmbedder) =>\n    new PDFFont(ref, doc, embedder);\n\n  /** The unique reference assigned to this font within the document. */\n  readonly ref: PDFRef;\n\n  /** The document to which this font belongs. */\n  readonly doc: PDFDocument;\n\n  /** The name of this font. */\n  readonly name: string;\n\n  private modified = true;\n  private readonly embedder: FontEmbedder;\n\n  private constructor(ref: PDFRef, doc: PDFDocument, embedder: FontEmbedder) {\n    assertIs(ref, 'ref', [[PDFRef, 'PDFRef']]);\n    assertIs(doc, 'doc', [[PDFDocument, 'PDFDocument']]);\n    assertIs(embedder, 'embedder', [\n      [CustomFontEmbedder, 'CustomFontEmbedder'],\n      [StandardFontEmbedder, 'StandardFontEmbedder'],\n    ]);\n\n    this.ref = ref;\n    this.doc = doc;\n    this.name = embedder.fontName;\n\n    this.embedder = embedder;\n  }\n\n  /**\n   * > **NOTE:** You probably don't need to call this method directly. The\n   * > [[PDFPage.drawText]] method will automatically encode the text it is\n   * > given.\n   *\n   * Encodes a string of text in this font.\n   *\n   * @param text The text to be encoded.\n   * @returns The encoded text as a hex string.\n   */\n  encodeText(text: string): PDFHexString {\n    assertIs(text, 'text', ['string']);\n    this.modified = true;\n    return this.embedder.encodeText(text);\n  }\n\n  /**\n   * Measure the width of a string of text drawn in this font at a given size.\n   * For example:\n   * ```js\n   * const width = font.widthOfTextAtSize('Foo Bar Qux Baz', 36)\n   * ```\n   * @param text The string of text to be measured.\n   * @param size The font size to be used for this measurement.\n   * @returns The width of the string of text when drawn in this font at the\n   *          given size.\n   */\n  widthOfTextAtSize(text: string, size: number): number {\n    assertIs(text, 'text', ['string']);\n    assertIs(size, 'size', ['number']);\n    return this.embedder.widthOfTextAtSize(text, size);\n  }\n\n  /**\n   * Measure the height of this font at a given size. For example:\n   * ```js\n   * const height = font.heightAtSize(24)\n   * ```\n   *\n   * The `options.descender` value controls whether or not the font's\n   * descender is included in the height calculation.\n   *\n   * @param size The font size to be used for this measurement.\n   * @param options The options to be used when computing this measurement.\n   * @returns The height of this font at the given size.\n   */\n  heightAtSize(size: number, options?: { descender?: boolean }): number {\n    assertIs(size, 'size', ['number']);\n    assertOrUndefined(options?.descender, 'options.descender', ['boolean']);\n    return this.embedder.heightOfFontAtSize(size, {\n      descender: options?.descender ?? true,\n    });\n  }\n\n  /**\n   * Compute the font size at which this font is a given height. For example:\n   * ```js\n   * const fontSize = font.sizeAtHeight(12)\n   * ```\n   * @param height The height to be used for this calculation.\n   * @returns The font size at which this font is the given height.\n   */\n  sizeAtHeight(height: number): number {\n    assertIs(height, 'height', ['number']);\n    return this.embedder.sizeOfFontAtHeight(height);\n  }\n\n  /**\n   * Get the set of unicode code points that can be represented by this font.\n   * @returns The set of unicode code points supported by this font.\n   */\n  getCharacterSet(): number[] {\n    if (this.embedder instanceof StandardFontEmbedder) {\n      return this.embedder.encoding.supportedCodePoints;\n    } else {\n      return this.embedder.font.characterSet;\n    }\n  }\n\n  /**\n   * > **NOTE:** You probably don't need to call this method directly. The\n   * > [[PDFDocument.save]] and [[PDFDocument.saveAsBase64]] methods will\n   * > automatically ensure all fonts get embedded.\n   *\n   * Embed this font in its document.\n   *\n   * @returns Resolves when the embedding is complete.\n   */\n  async embed(): Promise<void> {\n    // TODO: Cleanup orphan embedded objects if a font is embedded multiple times...\n    if (this.modified) {\n      await this.embedder.embedIntoContext(this.doc.context, this.ref);\n      this.modified = false;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}