{"ast":null,"code":"import { MethodNotImplementedError } from \"../errors\";\nimport Stream from \"./Stream\";\n/*\n * Copyright 2012 Mozilla Foundation\n *\n * The DecodeStream class contained in this file is a TypeScript port of the\n * JavaScript DecodeStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\n// Lots of DecodeStreams are created whose buffers are never used.  For these\n// we share a single empty buffer. This is (a) space-efficient and (b) avoids\n// having special cases that would be required if we used |null| for an empty\n// buffer.\nvar emptyBuffer = new Uint8Array(0);\n/**\n * Super class for the decoding streams\n */\nvar DecodeStream = /** @class */function () {\n  function DecodeStream(maybeMinBufferLength) {\n    this.pos = 0;\n    this.bufferLength = 0;\n    this.eof = false;\n    this.buffer = emptyBuffer;\n    this.minBufferLength = 512;\n    if (maybeMinBufferLength) {\n      // Compute the first power of two that is as big as maybeMinBufferLength.\n      while (this.minBufferLength < maybeMinBufferLength) {\n        this.minBufferLength *= 2;\n      }\n    }\n  }\n  Object.defineProperty(DecodeStream.prototype, \"isEmpty\", {\n    get: function () {\n      while (!this.eof && this.bufferLength === 0) {\n        this.readBlock();\n      }\n      return this.bufferLength === 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  DecodeStream.prototype.getByte = function () {\n    var pos = this.pos;\n    while (this.bufferLength <= pos) {\n      if (this.eof) {\n        return -1;\n      }\n      this.readBlock();\n    }\n    return this.buffer[this.pos++];\n  };\n  DecodeStream.prototype.getUint16 = function () {\n    var b0 = this.getByte();\n    var b1 = this.getByte();\n    if (b0 === -1 || b1 === -1) {\n      return -1;\n    }\n    return (b0 << 8) + b1;\n  };\n  DecodeStream.prototype.getInt32 = function () {\n    var b0 = this.getByte();\n    var b1 = this.getByte();\n    var b2 = this.getByte();\n    var b3 = this.getByte();\n    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\n  };\n  DecodeStream.prototype.getBytes = function (length, forceClamped) {\n    if (forceClamped === void 0) {\n      forceClamped = false;\n    }\n    var end;\n    var pos = this.pos;\n    if (length) {\n      this.ensureBuffer(pos + length);\n      end = pos + length;\n      while (!this.eof && this.bufferLength < end) {\n        this.readBlock();\n      }\n      var bufEnd = this.bufferLength;\n      if (end > bufEnd) {\n        end = bufEnd;\n      }\n    } else {\n      while (!this.eof) {\n        this.readBlock();\n      }\n      end = this.bufferLength;\n    }\n    this.pos = end;\n    var subarray = this.buffer.subarray(pos, end);\n    // `this.buffer` is either a `Uint8Array` or `Uint8ClampedArray` here.\n    return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;\n  };\n  DecodeStream.prototype.peekByte = function () {\n    var peekedByte = this.getByte();\n    this.pos--;\n    return peekedByte;\n  };\n  DecodeStream.prototype.peekBytes = function (length, forceClamped) {\n    if (forceClamped === void 0) {\n      forceClamped = false;\n    }\n    var bytes = this.getBytes(length, forceClamped);\n    this.pos -= bytes.length;\n    return bytes;\n  };\n  DecodeStream.prototype.skip = function (n) {\n    if (!n) {\n      n = 1;\n    }\n    this.pos += n;\n  };\n  DecodeStream.prototype.reset = function () {\n    this.pos = 0;\n  };\n  DecodeStream.prototype.makeSubStream = function (start, length /* dict */) {\n    var end = start + length;\n    while (this.bufferLength <= end && !this.eof) {\n      this.readBlock();\n    }\n    return new Stream(this.buffer, start, length /* dict */);\n  };\n  DecodeStream.prototype.decode = function () {\n    while (!this.eof) this.readBlock();\n    return this.buffer.subarray(0, this.bufferLength);\n  };\n  DecodeStream.prototype.readBlock = function () {\n    throw new MethodNotImplementedError(this.constructor.name, 'readBlock');\n  };\n  DecodeStream.prototype.ensureBuffer = function (requested) {\n    var buffer = this.buffer;\n    if (requested <= buffer.byteLength) {\n      return buffer;\n    }\n    var size = this.minBufferLength;\n    while (size < requested) {\n      size *= 2;\n    }\n    var buffer2 = new Uint8Array(size);\n    buffer2.set(buffer);\n    return this.buffer = buffer2;\n  };\n  return DecodeStream;\n}();\nexport default DecodeStream;","map":{"version":3,"names":["MethodNotImplementedError","Stream","emptyBuffer","Uint8Array","DecodeStream","maybeMinBufferLength","pos","bufferLength","eof","buffer","minBufferLength","Object","defineProperty","prototype","get","readBlock","getByte","getUint16","b0","b1","getInt32","b2","b3","getBytes","length","forceClamped","end","ensureBuffer","bufEnd","subarray","Uint8ClampedArray","peekByte","peekedByte","peekBytes","bytes","skip","n","reset","makeSubStream","start","decode","constructor","name","requested","byteLength","size","buffer2","set"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/streams/DecodeStream.ts"],"sourcesContent":["import { MethodNotImplementedError } from 'src/core/errors';\nimport Stream, { StreamType } from 'src/core/streams/Stream';\n\n/*\n * Copyright 2012 Mozilla Foundation\n *\n * The DecodeStream class contained in this file is a TypeScript port of the\n * JavaScript DecodeStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\n\n// Lots of DecodeStreams are created whose buffers are never used.  For these\n// we share a single empty buffer. This is (a) space-efficient and (b) avoids\n// having special cases that would be required if we used |null| for an empty\n// buffer.\nconst emptyBuffer = new Uint8Array(0);\n\n/**\n * Super class for the decoding streams\n */\nclass DecodeStream implements StreamType {\n  protected bufferLength: number;\n  protected buffer: Uint8Array;\n  protected eof: boolean;\n\n  private pos: number;\n  private minBufferLength: number;\n\n  constructor(maybeMinBufferLength?: number) {\n    this.pos = 0;\n    this.bufferLength = 0;\n    this.eof = false;\n    this.buffer = emptyBuffer;\n    this.minBufferLength = 512;\n    if (maybeMinBufferLength) {\n      // Compute the first power of two that is as big as maybeMinBufferLength.\n      while (this.minBufferLength < maybeMinBufferLength) {\n        this.minBufferLength *= 2;\n      }\n    }\n  }\n\n  get isEmpty() {\n    while (!this.eof && this.bufferLength === 0) {\n      this.readBlock();\n    }\n    return this.bufferLength === 0;\n  }\n\n  getByte() {\n    const pos = this.pos;\n    while (this.bufferLength <= pos) {\n      if (this.eof) {\n        return -1;\n      }\n      this.readBlock();\n    }\n    return this.buffer[this.pos++];\n  }\n\n  getUint16() {\n    const b0 = this.getByte();\n    const b1 = this.getByte();\n    if (b0 === -1 || b1 === -1) {\n      return -1;\n    }\n    return (b0 << 8) + b1;\n  }\n\n  getInt32() {\n    const b0 = this.getByte();\n    const b1 = this.getByte();\n    const b2 = this.getByte();\n    const b3 = this.getByte();\n    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\n  }\n\n  getBytes(length: number, forceClamped = false) {\n    let end;\n    const pos = this.pos;\n\n    if (length) {\n      this.ensureBuffer(pos + length);\n      end = pos + length;\n\n      while (!this.eof && this.bufferLength < end) {\n        this.readBlock();\n      }\n      const bufEnd = this.bufferLength;\n      if (end > bufEnd) {\n        end = bufEnd;\n      }\n    } else {\n      while (!this.eof) {\n        this.readBlock();\n      }\n      end = this.bufferLength;\n    }\n\n    this.pos = end;\n    const subarray = this.buffer.subarray(pos, end);\n    // `this.buffer` is either a `Uint8Array` or `Uint8ClampedArray` here.\n    return forceClamped && !(subarray instanceof Uint8ClampedArray)\n      ? new Uint8ClampedArray(subarray)\n      : subarray;\n  }\n\n  peekByte() {\n    const peekedByte = this.getByte();\n    this.pos--;\n    return peekedByte;\n  }\n\n  peekBytes(length: number, forceClamped = false) {\n    const bytes = this.getBytes(length, forceClamped);\n    this.pos -= bytes.length;\n    return bytes;\n  }\n\n  skip(n: number) {\n    if (!n) {\n      n = 1;\n    }\n    this.pos += n;\n  }\n\n  reset() {\n    this.pos = 0;\n  }\n\n  makeSubStream(start: number, length: number /* dict */) {\n    const end = start + length;\n    while (this.bufferLength <= end && !this.eof) {\n      this.readBlock();\n    }\n    return new Stream(this.buffer, start, length /* dict */);\n  }\n\n  decode(): Uint8Array {\n    while (!this.eof) this.readBlock();\n    return this.buffer.subarray(0, this.bufferLength);\n  }\n\n  protected readBlock(): void {\n    throw new MethodNotImplementedError(this.constructor.name, 'readBlock');\n  }\n\n  protected ensureBuffer(requested: number) {\n    const buffer = this.buffer;\n    if (requested <= buffer.byteLength) {\n      return buffer;\n    }\n    let size = this.minBufferLength;\n    while (size < requested) {\n      size *= 2;\n    }\n    const buffer2 = new Uint8Array(size);\n    buffer2.set(buffer);\n    return (this.buffer = buffer2);\n  }\n\n  // getBaseStreams() {\n  //   if (this.str && this.str.getBaseStreams) {\n  //     return this.str.getBaseStreams();\n  //   }\n  //   return [];\n  // }\n}\n\nexport default DecodeStream;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}