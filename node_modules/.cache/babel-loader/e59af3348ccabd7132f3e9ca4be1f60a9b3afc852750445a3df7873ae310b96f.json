{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar errors_1 = require(\"../errors\");\nvar CharCodes_1 = tslib_1.__importDefault(require(\"../syntax/CharCodes\"));\nvar Numeric_1 = require(\"../syntax/Numeric\");\nvar Whitespace_1 = require(\"../syntax/Whitespace\");\nvar utils_1 = require(\"../../utils\");\nvar Newline = CharCodes_1.default.Newline,\n  CarriageReturn = CharCodes_1.default.CarriageReturn;\n// TODO: Throw error if eof is reached before finishing object parse...\nvar BaseParser = /** @class */function () {\n  function BaseParser(bytes, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    this.bytes = bytes;\n    this.capNumbers = capNumbers;\n  }\n  BaseParser.prototype.parseRawInt = function () {\n    var value = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!Numeric_1.IsDigit[byte]) break;\n      value += utils_1.charFromCode(this.bytes.next());\n    }\n    var numberValue = Number(value);\n    if (!value || !isFinite(numberValue)) {\n      throw new errors_1.NumberParsingError(this.bytes.position(), value);\n    }\n    return numberValue;\n  };\n  // TODO: Maybe handle exponential format?\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  BaseParser.prototype.parseRawNumber = function () {\n    var value = '';\n    // Parse integer-part, the leading (+ | - | . | 0-9)\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!Numeric_1.IsNumeric[byte]) break;\n      value += utils_1.charFromCode(this.bytes.next());\n      if (byte === CharCodes_1.default.Period) break;\n    }\n    // Parse decimal-part, the trailing (0-9)\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!Numeric_1.IsDigit[byte]) break;\n      value += utils_1.charFromCode(this.bytes.next());\n    }\n    var numberValue = Number(value);\n    if (!value || !isFinite(numberValue)) {\n      throw new errors_1.NumberParsingError(this.bytes.position(), value);\n    }\n    if (numberValue > Number.MAX_SAFE_INTEGER) {\n      if (this.capNumbers) {\n        var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", using Number.MAX_SAFE_INTEGER instead.\";\n        console.warn(msg);\n        return Number.MAX_SAFE_INTEGER;\n      } else {\n        var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", not capping.\";\n        console.warn(msg);\n      }\n    }\n    return numberValue;\n  };\n  BaseParser.prototype.skipWhitespace = function () {\n    while (!this.bytes.done() && Whitespace_1.IsWhitespace[this.bytes.peek()]) {\n      this.bytes.next();\n    }\n  };\n  BaseParser.prototype.skipLine = function () {\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (byte === Newline || byte === CarriageReturn) return;\n      this.bytes.next();\n    }\n  };\n  BaseParser.prototype.skipComment = function () {\n    if (this.bytes.peek() !== CharCodes_1.default.Percent) return false;\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (byte === Newline || byte === CarriageReturn) return true;\n      this.bytes.next();\n    }\n    return true;\n  };\n  BaseParser.prototype.skipWhitespaceAndComments = function () {\n    this.skipWhitespace();\n    while (this.skipComment()) this.skipWhitespace();\n  };\n  BaseParser.prototype.matchKeyword = function (keyword) {\n    var initialOffset = this.bytes.offset();\n    for (var idx = 0, len = keyword.length; idx < len; idx++) {\n      if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {\n        this.bytes.moveTo(initialOffset);\n        return false;\n      }\n    }\n    return true;\n  };\n  return BaseParser;\n}();\nexports.default = BaseParser;","map":{"version":3,"names":["errors_1","require","CharCodes_1","tslib_1","__importDefault","Numeric_1","Whitespace_1","utils_1","Newline","default","CarriageReturn","BaseParser","bytes","capNumbers","prototype","parseRawInt","value","done","byte","peek","IsDigit","charFromCode","next","numberValue","Number","isFinite","NumberParsingError","position","parseRawNumber","IsNumeric","Period","MAX_SAFE_INTEGER","msg","console","warn","skipWhitespace","IsWhitespace","skipLine","skipComment","Percent","skipWhitespaceAndComments","matchKeyword","keyword","initialOffset","offset","idx","len","length","moveTo","exports"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/parser/BaseParser.ts"],"sourcesContent":["import { NumberParsingError } from 'src/core/errors';\nimport ByteStream from 'src/core/parser/ByteStream';\nimport CharCodes from 'src/core/syntax/CharCodes';\nimport { IsDigit, IsNumeric } from 'src/core/syntax/Numeric';\nimport { IsWhitespace } from 'src/core/syntax/Whitespace';\nimport { charFromCode } from 'src/utils';\n\nconst { Newline, CarriageReturn } = CharCodes;\n\n// TODO: Throw error if eof is reached before finishing object parse...\nclass BaseParser {\n  protected readonly bytes: ByteStream;\n  protected readonly capNumbers: boolean;\n\n  constructor(bytes: ByteStream, capNumbers = false) {\n    this.bytes = bytes;\n    this.capNumbers = capNumbers;\n  }\n\n  protected parseRawInt(): number {\n    let value = '';\n\n    while (!this.bytes.done()) {\n      const byte = this.bytes.peek();\n      if (!IsDigit[byte]) break;\n      value += charFromCode(this.bytes.next());\n    }\n\n    const numberValue = Number(value);\n\n    if (!value || !isFinite(numberValue)) {\n      throw new NumberParsingError(this.bytes.position(), value);\n    }\n\n    return numberValue;\n  }\n\n  // TODO: Maybe handle exponential format?\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  protected parseRawNumber(): number {\n    let value = '';\n\n    // Parse integer-part, the leading (+ | - | . | 0-9)\n    while (!this.bytes.done()) {\n      const byte = this.bytes.peek();\n      if (!IsNumeric[byte]) break;\n      value += charFromCode(this.bytes.next());\n      if (byte === CharCodes.Period) break;\n    }\n\n    // Parse decimal-part, the trailing (0-9)\n    while (!this.bytes.done()) {\n      const byte = this.bytes.peek();\n      if (!IsDigit[byte]) break;\n      value += charFromCode(this.bytes.next());\n    }\n\n    const numberValue = Number(value);\n\n    if (!value || !isFinite(numberValue)) {\n      throw new NumberParsingError(this.bytes.position(), value);\n    }\n\n    if (numberValue > Number.MAX_SAFE_INTEGER) {\n      if (this.capNumbers) {\n        const msg = `Parsed number that is too large for some PDF readers: ${value}, using Number.MAX_SAFE_INTEGER instead.`;\n        console.warn(msg);\n        return Number.MAX_SAFE_INTEGER;\n      } else {\n        const msg = `Parsed number that is too large for some PDF readers: ${value}, not capping.`;\n        console.warn(msg);\n      }\n    }\n\n    return numberValue;\n  }\n\n  protected skipWhitespace(): void {\n    while (!this.bytes.done() && IsWhitespace[this.bytes.peek()]) {\n      this.bytes.next();\n    }\n  }\n\n  protected skipLine(): void {\n    while (!this.bytes.done()) {\n      const byte = this.bytes.peek();\n      if (byte === Newline || byte === CarriageReturn) return;\n      this.bytes.next();\n    }\n  }\n\n  protected skipComment(): boolean {\n    if (this.bytes.peek() !== CharCodes.Percent) return false;\n    while (!this.bytes.done()) {\n      const byte = this.bytes.peek();\n      if (byte === Newline || byte === CarriageReturn) return true;\n      this.bytes.next();\n    }\n    return true;\n  }\n\n  protected skipWhitespaceAndComments(): void {\n    this.skipWhitespace();\n    while (this.skipComment()) this.skipWhitespace();\n  }\n\n  protected matchKeyword(keyword: number[]): boolean {\n    const initialOffset = this.bytes.offset();\n    for (let idx = 0, len = keyword.length; idx < len; idx++) {\n      if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {\n        this.bytes.moveTo(initialOffset);\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nexport default BaseParser;\n"],"mappings":";;;;;;AAAA,IAAAA,QAAA,GAAAC,OAAA;AAEA,IAAAC,WAAA,GAAAC,OAAA,CAAAC,eAAA,CAAAH,OAAA;AACA,IAAAI,SAAA,GAAAJ,OAAA;AACA,IAAAK,YAAA,GAAAL,OAAA;AACA,IAAAM,OAAA,GAAAN,OAAA;AAEQ,IAAAO,OAAO,GAAqBN,WAAA,CAAAO,OAAS,CAAAD,OAA9B;EAAEE,cAAc,GAAKR,WAAA,CAAAO,OAAS,CAAAC,cAAd;AAE/B;AACA,IAAAC,UAAA;EAIE,SAAAA,WAAYC,KAAiB,EAAEC,UAAkB;IAAlB,IAAAA,UAAA;MAAAA,UAAA,QAAkB;IAAA;IAC/C,IAAI,CAACD,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,UAAU,GAAGA,UAAU;EAC9B;EAEUF,UAAA,CAAAG,SAAA,CAAAC,WAAW,GAArB;IACE,IAAIC,KAAK,GAAG,EAAE;IAEd,OAAO,CAAC,IAAI,CAACJ,KAAK,CAACK,IAAI,EAAE,EAAE;MACzB,IAAMC,IAAI,GAAG,IAAI,CAACN,KAAK,CAACO,IAAI,EAAE;MAC9B,IAAI,CAACd,SAAA,CAAAe,OAAO,CAACF,IAAI,CAAC,EAAE;MACpBF,KAAK,IAAIT,OAAA,CAAAc,YAAY,CAAC,IAAI,CAACT,KAAK,CAACU,IAAI,EAAE,CAAC;;IAG1C,IAAMC,WAAW,GAAGC,MAAM,CAACR,KAAK,CAAC;IAEjC,IAAI,CAACA,KAAK,IAAI,CAACS,QAAQ,CAACF,WAAW,CAAC,EAAE;MACpC,MAAM,IAAIvB,QAAA,CAAA0B,kBAAkB,CAAC,IAAI,CAACd,KAAK,CAACe,QAAQ,EAAE,EAAEX,KAAK,CAAC;;IAG5D,OAAOO,WAAW;EACpB,CAAC;EAED;EACA;EACUZ,UAAA,CAAAG,SAAA,CAAAc,cAAc,GAAxB;IACE,IAAIZ,KAAK,GAAG,EAAE;IAEd;IACA,OAAO,CAAC,IAAI,CAACJ,KAAK,CAACK,IAAI,EAAE,EAAE;MACzB,IAAMC,IAAI,GAAG,IAAI,CAACN,KAAK,CAACO,IAAI,EAAE;MAC9B,IAAI,CAACd,SAAA,CAAAwB,SAAS,CAACX,IAAI,CAAC,EAAE;MACtBF,KAAK,IAAIT,OAAA,CAAAc,YAAY,CAAC,IAAI,CAACT,KAAK,CAACU,IAAI,EAAE,CAAC;MACxC,IAAIJ,IAAI,KAAKhB,WAAA,CAAAO,OAAS,CAACqB,MAAM,EAAE;;IAGjC;IACA,OAAO,CAAC,IAAI,CAAClB,KAAK,CAACK,IAAI,EAAE,EAAE;MACzB,IAAMC,IAAI,GAAG,IAAI,CAACN,KAAK,CAACO,IAAI,EAAE;MAC9B,IAAI,CAACd,SAAA,CAAAe,OAAO,CAACF,IAAI,CAAC,EAAE;MACpBF,KAAK,IAAIT,OAAA,CAAAc,YAAY,CAAC,IAAI,CAACT,KAAK,CAACU,IAAI,EAAE,CAAC;;IAG1C,IAAMC,WAAW,GAAGC,MAAM,CAACR,KAAK,CAAC;IAEjC,IAAI,CAACA,KAAK,IAAI,CAACS,QAAQ,CAACF,WAAW,CAAC,EAAE;MACpC,MAAM,IAAIvB,QAAA,CAAA0B,kBAAkB,CAAC,IAAI,CAACd,KAAK,CAACe,QAAQ,EAAE,EAAEX,KAAK,CAAC;;IAG5D,IAAIO,WAAW,GAAGC,MAAM,CAACO,gBAAgB,EAAE;MACzC,IAAI,IAAI,CAAClB,UAAU,EAAE;QACnB,IAAMmB,GAAG,GAAG,2DAAyDhB,KAAK,6CAA0C;QACpHiB,OAAO,CAACC,IAAI,CAACF,GAAG,CAAC;QACjB,OAAOR,MAAM,CAACO,gBAAgB;OAC/B,MAAM;QACL,IAAMC,GAAG,GAAG,2DAAyDhB,KAAK,mBAAgB;QAC1FiB,OAAO,CAACC,IAAI,CAACF,GAAG,CAAC;;;IAIrB,OAAOT,WAAW;EACpB,CAAC;EAESZ,UAAA,CAAAG,SAAA,CAAAqB,cAAc,GAAxB;IACE,OAAO,CAAC,IAAI,CAACvB,KAAK,CAACK,IAAI,EAAE,IAAIX,YAAA,CAAA8B,YAAY,CAAC,IAAI,CAACxB,KAAK,CAACO,IAAI,EAAE,CAAC,EAAE;MAC5D,IAAI,CAACP,KAAK,CAACU,IAAI,EAAE;;EAErB,CAAC;EAESX,UAAA,CAAAG,SAAA,CAAAuB,QAAQ,GAAlB;IACE,OAAO,CAAC,IAAI,CAACzB,KAAK,CAACK,IAAI,EAAE,EAAE;MACzB,IAAMC,IAAI,GAAG,IAAI,CAACN,KAAK,CAACO,IAAI,EAAE;MAC9B,IAAID,IAAI,KAAKV,OAAO,IAAIU,IAAI,KAAKR,cAAc,EAAE;MACjD,IAAI,CAACE,KAAK,CAACU,IAAI,EAAE;;EAErB,CAAC;EAESX,UAAA,CAAAG,SAAA,CAAAwB,WAAW,GAArB;IACE,IAAI,IAAI,CAAC1B,KAAK,CAACO,IAAI,EAAE,KAAKjB,WAAA,CAAAO,OAAS,CAAC8B,OAAO,EAAE,OAAO,KAAK;IACzD,OAAO,CAAC,IAAI,CAAC3B,KAAK,CAACK,IAAI,EAAE,EAAE;MACzB,IAAMC,IAAI,GAAG,IAAI,CAACN,KAAK,CAACO,IAAI,EAAE;MAC9B,IAAID,IAAI,KAAKV,OAAO,IAAIU,IAAI,KAAKR,cAAc,EAAE,OAAO,IAAI;MAC5D,IAAI,CAACE,KAAK,CAACU,IAAI,EAAE;;IAEnB,OAAO,IAAI;EACb,CAAC;EAESX,UAAA,CAAAG,SAAA,CAAA0B,yBAAyB,GAAnC;IACE,IAAI,CAACL,cAAc,EAAE;IACrB,OAAO,IAAI,CAACG,WAAW,EAAE,EAAE,IAAI,CAACH,cAAc,EAAE;EAClD,CAAC;EAESxB,UAAA,CAAAG,SAAA,CAAA2B,YAAY,GAAtB,UAAuBC,OAAiB;IACtC,IAAMC,aAAa,GAAG,IAAI,CAAC/B,KAAK,CAACgC,MAAM,EAAE;IACzC,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEC,GAAG,GAAGJ,OAAO,CAACK,MAAM,EAAEF,GAAG,GAAGC,GAAG,EAAED,GAAG,EAAE,EAAE;MACxD,IAAI,IAAI,CAACjC,KAAK,CAACK,IAAI,EAAE,IAAI,IAAI,CAACL,KAAK,CAACU,IAAI,EAAE,KAAKoB,OAAO,CAACG,GAAG,CAAC,EAAE;QAC3D,IAAI,CAACjC,KAAK,CAACoC,MAAM,CAACL,aAAa,CAAC;QAChC,OAAO,KAAK;;;IAGhB,OAAO,IAAI;EACb,CAAC;EACH,OAAAhC,UAAC;AAAD,CAAC,CA1GD;AA4GAsC,OAAA,CAAAxC,OAAA,GAAeE,UAAU","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}