{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar PDFArray_1 = tslib_1.__importDefault(require(\"../objects/PDFArray\"));\nvar PDFDict_1 = tslib_1.__importDefault(require(\"../objects/PDFDict\"));\nvar PDFName_1 = tslib_1.__importDefault(require(\"../objects/PDFName\"));\nvar PDFNumber_1 = tslib_1.__importDefault(require(\"../objects/PDFNumber\"));\nvar PDFPageLeaf_1 = tslib_1.__importDefault(require(\"./PDFPageLeaf\"));\nvar errors_1 = require(\"../errors\");\nvar PDFPageTree = /** @class */function (_super) {\n  tslib_1.__extends(PDFPageTree, _super);\n  function PDFPageTree() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  PDFPageTree.prototype.Parent = function () {\n    return this.lookup(PDFName_1.default.of('Parent'));\n  };\n  PDFPageTree.prototype.Kids = function () {\n    return this.lookup(PDFName_1.default.of('Kids'), PDFArray_1.default);\n  };\n  PDFPageTree.prototype.Count = function () {\n    return this.lookup(PDFName_1.default.of('Count'), PDFNumber_1.default);\n  };\n  PDFPageTree.prototype.pushTreeNode = function (treeRef) {\n    var Kids = this.Kids();\n    Kids.push(treeRef);\n  };\n  PDFPageTree.prototype.pushLeafNode = function (leafRef) {\n    var Kids = this.Kids();\n    this.insertLeafKid(Kids.size(), leafRef);\n  };\n  /**\n   * Inserts the given ref as a leaf node of this page tree at the specified\n   * index (zero-based). Also increments the `Count` of each page tree in the\n   * hierarchy to accomodate the new page.\n   *\n   * Returns the ref of the PDFPageTree node into which `leafRef` was inserted,\n   * or `undefined` if it was inserted into the root node (the PDFPageTree upon\n   * which the method was first called).\n   */\n  PDFPageTree.prototype.insertLeafNode = function (leafRef, targetIndex) {\n    var Kids = this.Kids();\n    var Count = this.Count().asNumber();\n    if (targetIndex > Count) {\n      throw new errors_1.InvalidTargetIndexError(targetIndex, Count);\n    }\n    var leafsRemainingUntilTarget = targetIndex;\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      if (leafsRemainingUntilTarget === 0) {\n        // Insert page and return\n        this.insertLeafKid(idx, leafRef);\n        return undefined;\n      }\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          return kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n      if (kid instanceof PDFPageLeaf_1.default) {\n        // Move on\n        leafsRemainingUntilTarget -= 1;\n      }\n    }\n    if (leafsRemainingUntilTarget === 0) {\n      // Insert page at the end and return\n      this.insertLeafKid(Kids.size(), leafRef);\n      return undefined;\n    }\n    // Should never get here if `targetIndex` is valid\n    throw new errors_1.CorruptPageTreeError(targetIndex, 'insertLeafNode');\n  };\n  /**\n   * Removes the leaf node at the specified index (zero-based) from this page\n   * tree. Also decrements the `Count` of each page tree in the hierarchy to\n   * account for the removed page.\n   *\n   * If `prune` is true, then intermediate tree nodes will be removed from the\n   * tree if they contain 0 children after the leaf node is removed.\n   */\n  PDFPageTree.prototype.removeLeafNode = function (targetIndex, prune) {\n    if (prune === void 0) {\n      prune = true;\n    }\n    var Kids = this.Kids();\n    var Count = this.Count().asNumber();\n    if (targetIndex >= Count) {\n      throw new errors_1.InvalidTargetIndexError(targetIndex, Count);\n    }\n    var leafsRemainingUntilTarget = targetIndex;\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          kid.removeLeafNode(leafsRemainingUntilTarget, prune);\n          if (prune && kid.Kids().size() === 0) Kids.remove(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n      if (kid instanceof PDFPageLeaf_1.default) {\n        if (leafsRemainingUntilTarget === 0) {\n          // Remove page and return\n          this.removeKid(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= 1;\n        }\n      }\n    }\n    // Should never get here if `targetIndex` is valid\n    throw new errors_1.CorruptPageTreeError(targetIndex, 'removeLeafNode');\n  };\n  PDFPageTree.prototype.ascend = function (visitor) {\n    visitor(this);\n    var Parent = this.Parent();\n    if (Parent) Parent.ascend(visitor);\n  };\n  /** Performs a Post-Order traversal of this page tree */\n  PDFPageTree.prototype.traverse = function (visitor) {\n    var Kids = this.Kids();\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) kid.traverse(visitor);\n      visitor(kid, kidRef);\n    }\n  };\n  PDFPageTree.prototype.insertLeafKid = function (kidIdx, leafRef) {\n    var Kids = this.Kids();\n    this.ascend(function (node) {\n      var newCount = node.Count().asNumber() + 1;\n      node.set(PDFName_1.default.of('Count'), PDFNumber_1.default.of(newCount));\n    });\n    Kids.insert(kidIdx, leafRef);\n  };\n  PDFPageTree.prototype.removeKid = function (kidIdx) {\n    var Kids = this.Kids();\n    var kid = Kids.lookup(kidIdx);\n    if (kid instanceof PDFPageLeaf_1.default) {\n      this.ascend(function (node) {\n        var newCount = node.Count().asNumber() - 1;\n        node.set(PDFName_1.default.of('Count'), PDFNumber_1.default.of(newCount));\n      });\n    }\n    Kids.remove(kidIdx);\n  };\n  PDFPageTree.withContext = function (context, parent) {\n    var dict = new Map();\n    dict.set(PDFName_1.default.of('Type'), PDFName_1.default.of('Pages'));\n    dict.set(PDFName_1.default.of('Kids'), context.obj([]));\n    dict.set(PDFName_1.default.of('Count'), context.obj(0));\n    if (parent) dict.set(PDFName_1.default.of('Parent'), parent);\n    return new PDFPageTree(dict, context);\n  };\n  PDFPageTree.fromMapWithContext = function (map, context) {\n    return new PDFPageTree(map, context);\n  };\n  return PDFPageTree;\n}(PDFDict_1.default);\nexports.default = PDFPageTree;","map":{"version":3,"names":["PDFArray_1","tslib_1","__importDefault","require","PDFDict_1","PDFName_1","PDFNumber_1","PDFPageLeaf_1","errors_1","PDFPageTree","_super","__extends","prototype","Parent","lookup","default","of","Kids","Count","pushTreeNode","treeRef","push","pushLeafNode","leafRef","insertLeafKid","size","insertLeafNode","targetIndex","asNumber","InvalidTargetIndexError","leafsRemainingUntilTarget","idx","len","undefined","kidRef","get","kid","context","CorruptPageTreeError","removeLeafNode","prune","remove","removeKid","ascend","visitor","traverse","kidIdx","node","newCount","set","insert","withContext","parent","dict","Map","obj","fromMapWithContext","map","exports"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/structures/PDFPageTree.ts"],"sourcesContent":["import PDFArray from 'src/core/objects/PDFArray';\nimport PDFDict, { DictMap } from 'src/core/objects/PDFDict';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFNumber from 'src/core/objects/PDFNumber';\nimport PDFRef from 'src/core/objects/PDFRef';\nimport PDFContext from 'src/core/PDFContext';\nimport PDFPageLeaf from 'src/core/structures/PDFPageLeaf';\nimport { InvalidTargetIndexError, CorruptPageTreeError } from 'src/core/errors';\n\nexport type TreeNode = PDFPageTree | PDFPageLeaf;\n\nclass PDFPageTree extends PDFDict {\n  static withContext = (context: PDFContext, parent?: PDFRef) => {\n    const dict = new Map();\n    dict.set(PDFName.of('Type'), PDFName.of('Pages'));\n    dict.set(PDFName.of('Kids'), context.obj([]));\n    dict.set(PDFName.of('Count'), context.obj(0));\n    if (parent) dict.set(PDFName.of('Parent'), parent);\n    return new PDFPageTree(dict, context);\n  };\n\n  static fromMapWithContext = (map: DictMap, context: PDFContext) =>\n    new PDFPageTree(map, context);\n\n  Parent(): PDFPageTree | undefined {\n    return this.lookup(PDFName.of('Parent')) as PDFPageTree | undefined;\n  }\n\n  Kids(): PDFArray {\n    return this.lookup(PDFName.of('Kids'), PDFArray);\n  }\n\n  Count(): PDFNumber {\n    return this.lookup(PDFName.of('Count'), PDFNumber);\n  }\n\n  pushTreeNode(treeRef: PDFRef): void {\n    const Kids = this.Kids();\n    Kids.push(treeRef);\n  }\n\n  pushLeafNode(leafRef: PDFRef): void {\n    const Kids = this.Kids();\n    this.insertLeafKid(Kids.size(), leafRef);\n  }\n\n  /**\n   * Inserts the given ref as a leaf node of this page tree at the specified\n   * index (zero-based). Also increments the `Count` of each page tree in the\n   * hierarchy to accomodate the new page.\n   *\n   * Returns the ref of the PDFPageTree node into which `leafRef` was inserted,\n   * or `undefined` if it was inserted into the root node (the PDFPageTree upon\n   * which the method was first called).\n   */\n  insertLeafNode(leafRef: PDFRef, targetIndex: number): PDFRef | undefined {\n    const Kids = this.Kids();\n    const Count = this.Count().asNumber();\n\n    if (targetIndex > Count) {\n      throw new InvalidTargetIndexError(targetIndex, Count);\n    }\n\n    let leafsRemainingUntilTarget = targetIndex;\n    for (let idx = 0, len = Kids.size(); idx < len; idx++) {\n      if (leafsRemainingUntilTarget === 0) {\n        // Insert page and return\n        this.insertLeafKid(idx, leafRef);\n        return undefined;\n      }\n\n      const kidRef = Kids.get(idx) as PDFRef;\n      const kid = this.context.lookup(kidRef);\n\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          return (\n            kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef\n          );\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n\n      if (kid instanceof PDFPageLeaf) {\n        // Move on\n        leafsRemainingUntilTarget -= 1;\n      }\n    }\n\n    if (leafsRemainingUntilTarget === 0) {\n      // Insert page at the end and return\n      this.insertLeafKid(Kids.size(), leafRef);\n      return undefined;\n    }\n\n    // Should never get here if `targetIndex` is valid\n    throw new CorruptPageTreeError(targetIndex, 'insertLeafNode');\n  }\n\n  /**\n   * Removes the leaf node at the specified index (zero-based) from this page\n   * tree. Also decrements the `Count` of each page tree in the hierarchy to\n   * account for the removed page.\n   *\n   * If `prune` is true, then intermediate tree nodes will be removed from the\n   * tree if they contain 0 children after the leaf node is removed.\n   */\n  removeLeafNode(targetIndex: number, prune = true): void {\n    const Kids = this.Kids();\n    const Count = this.Count().asNumber();\n\n    if (targetIndex >= Count) {\n      throw new InvalidTargetIndexError(targetIndex, Count);\n    }\n\n    let leafsRemainingUntilTarget = targetIndex;\n    for (let idx = 0, len = Kids.size(); idx < len; idx++) {\n      const kidRef = Kids.get(idx) as PDFRef;\n      const kid = this.context.lookup(kidRef);\n\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          kid.removeLeafNode(leafsRemainingUntilTarget, prune);\n          if (prune && kid.Kids().size() === 0) Kids.remove(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n\n      if (kid instanceof PDFPageLeaf) {\n        if (leafsRemainingUntilTarget === 0) {\n          // Remove page and return\n          this.removeKid(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= 1;\n        }\n      }\n    }\n\n    // Should never get here if `targetIndex` is valid\n    throw new CorruptPageTreeError(targetIndex, 'removeLeafNode');\n  }\n\n  ascend(visitor: (node: PDFPageTree) => any): void {\n    visitor(this);\n    const Parent = this.Parent();\n    if (Parent) Parent.ascend(visitor);\n  }\n\n  /** Performs a Post-Order traversal of this page tree */\n  traverse(visitor: (node: TreeNode, ref: PDFRef) => any): void {\n    const Kids = this.Kids();\n    for (let idx = 0, len = Kids.size(); idx < len; idx++) {\n      const kidRef = Kids.get(idx) as PDFRef;\n      const kid = this.context.lookup(kidRef) as TreeNode;\n      if (kid instanceof PDFPageTree) kid.traverse(visitor);\n      visitor(kid, kidRef);\n    }\n  }\n\n  private insertLeafKid(kidIdx: number, leafRef: PDFRef): void {\n    const Kids = this.Kids();\n\n    this.ascend((node) => {\n      const newCount = node.Count().asNumber() + 1;\n      node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n    });\n\n    Kids.insert(kidIdx, leafRef);\n  }\n\n  private removeKid(kidIdx: number): void {\n    const Kids = this.Kids();\n\n    const kid = Kids.lookup(kidIdx);\n    if (kid instanceof PDFPageLeaf) {\n      this.ascend((node) => {\n        const newCount = node.Count().asNumber() - 1;\n        node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n      });\n    }\n\n    Kids.remove(kidIdx);\n  }\n}\n\nexport default PDFPageTree;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}