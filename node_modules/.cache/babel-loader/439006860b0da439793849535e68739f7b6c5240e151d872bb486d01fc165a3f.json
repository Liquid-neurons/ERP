{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertFieldAppearanceOptions = void 0;\nvar tslib_1 = require(\"tslib\");\nvar PDFDocument_1 = tslib_1.__importDefault(require(\"../PDFDocument\"));\nvar colors_1 = require(\"../colors\");\nvar rotations_1 = require(\"../rotations\");\nvar core_1 = require(\"../../core\");\nvar utils_1 = require(\"../../utils\");\nvar image_1 = require(\"../image\");\nvar operations_1 = require(\"../operations\");\nexports.assertFieldAppearanceOptions = function (options) {\n  utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.x, 'options.x', ['number']);\n  utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.y, 'options.y', ['number']);\n  utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.width, 'options.width', ['number']);\n  utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.height, 'options.height', ['number']);\n  utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.textColor, 'options.textColor', [[Object, 'Color']]);\n  utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.backgroundColor, 'options.backgroundColor', [[Object, 'Color']]);\n  utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderColor, 'options.borderColor', [[Object, 'Color']]);\n  utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.borderWidth, 'options.borderWidth', ['number']);\n  utils_1.assertOrUndefined(options === null || options === void 0 ? void 0 : options.rotate, 'options.rotate', [[Object, 'Rotation']]);\n};\n/**\n * Represents a field of a [[PDFForm]].\n *\n * This class is effectively abstract. All fields in a [[PDFForm]] will\n * actually be an instance of a subclass of this class.\n *\n * Note that each field in a PDF is represented by a single field object.\n * However, a given field object may be rendered at multiple locations within\n * the document (across one or more pages). The rendering of a field is\n * controlled by its widgets. Each widget causes its field to be displayed at a\n * particular location in the document.\n *\n * Most of the time each field in a PDF has only a single widget, and thus is\n * only rendered once. However, if a field is rendered multiple times, it will\n * have multiple widgets - one for each location it is rendered.\n *\n * This abstraction of field objects and widgets is defined in the PDF\n * specification and dictates how PDF files store fields and where they are\n * to be rendered.\n */\nvar PDFField = /** @class */function () {\n  function PDFField(acroField, ref, doc) {\n    utils_1.assertIs(acroField, 'acroField', [[core_1.PDFAcroTerminal, 'PDFAcroTerminal']]);\n    utils_1.assertIs(ref, 'ref', [[core_1.PDFRef, 'PDFRef']]);\n    utils_1.assertIs(doc, 'doc', [[PDFDocument_1.default, 'PDFDocument']]);\n    this.acroField = acroField;\n    this.ref = ref;\n    this.doc = doc;\n  }\n  /**\n   * Get the fully qualified name of this field. For example:\n   * ```js\n   * const fields = form.getFields()\n   * fields.forEach(field => {\n   *   const name = field.getName()\n   *   console.log('Field name:', name)\n   * })\n   * ```\n   * Note that PDF fields are structured as a tree. Each field is the\n   * descendent of a series of ancestor nodes all the way up to the form node,\n   * which is always the root of the tree. Each node in the tree (except for\n   * the form node) has a partial name. Partial names can be composed of any\n   * unicode characters except a period (`.`). The fully qualified name of a\n   * field is composed of the partial names of all its ancestors joined\n   * with periods. This means that splitting the fully qualified name on\n   * periods and taking the last element of the resulting array will give you\n   * the partial name of a specific field.\n   * @returns The fully qualified name of this field.\n   */\n  PDFField.prototype.getName = function () {\n    var _a;\n    return (_a = this.acroField.getFullyQualifiedName()) !== null && _a !== void 0 ? _a : '';\n  };\n  /**\n   * Returns `true` if this field is read only. This means that PDF readers\n   * will not allow users to interact with the field or change its value. See\n   * [[PDFField.enableReadOnly]] and [[PDFField.disableReadOnly]].\n   * For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * if (field.isReadOnly()) console.log('Read only is enabled')\n   * ```\n   * @returns Whether or not this is a read only field.\n   */\n  PDFField.prototype.isReadOnly = function () {\n    return this.acroField.hasFlag(core_1.AcroFieldFlags.ReadOnly);\n  };\n  /**\n   * Prevent PDF readers from allowing users to interact with this field or\n   * change its value. The field will not respond to mouse or keyboard input.\n   * For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * field.enableReadOnly()\n   * ```\n   * Useful for fields whose values are computed, imported from a database, or\n   * prefilled by software before being displayed to the user.\n   */\n  PDFField.prototype.enableReadOnly = function () {\n    this.acroField.setFlagTo(core_1.AcroFieldFlags.ReadOnly, true);\n  };\n  /**\n   * Allow users to interact with this field and change its value in PDF\n   * readers via mouse and keyboard input. For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * field.disableReadOnly()\n   * ```\n   */\n  PDFField.prototype.disableReadOnly = function () {\n    this.acroField.setFlagTo(core_1.AcroFieldFlags.ReadOnly, false);\n  };\n  /**\n   * Returns `true` if this field must have a value when the form is submitted.\n   * See [[PDFField.enableRequired]] and [[PDFField.disableRequired]].\n   * For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * if (field.isRequired()) console.log('Field is required')\n   * ```\n   * @returns Whether or not this field is required.\n   */\n  PDFField.prototype.isRequired = function () {\n    return this.acroField.hasFlag(core_1.AcroFieldFlags.Required);\n  };\n  /**\n   * Require this field to have a value when the form is submitted.\n   * For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * field.enableRequired()\n   * ```\n   */\n  PDFField.prototype.enableRequired = function () {\n    this.acroField.setFlagTo(core_1.AcroFieldFlags.Required, true);\n  };\n  /**\n   * Do not require this field to have a value when the form is submitted.\n   * For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * field.disableRequired()\n   * ```\n   */\n  PDFField.prototype.disableRequired = function () {\n    this.acroField.setFlagTo(core_1.AcroFieldFlags.Required, false);\n  };\n  /**\n   * Returns `true` if this field's value should be exported when the form is\n   * submitted. See [[PDFField.enableExporting]] and\n   * [[PDFField.disableExporting]].\n   * For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * if (field.isExported()) console.log('Exporting is enabled')\n   * ```\n   * @returns Whether or not this field's value should be exported.\n   */\n  PDFField.prototype.isExported = function () {\n    return !this.acroField.hasFlag(core_1.AcroFieldFlags.NoExport);\n  };\n  /**\n   * Indicate that this field's value should be exported when the form is\n   * submitted in a PDF reader. For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * field.enableExporting()\n   * ```\n   */\n  PDFField.prototype.enableExporting = function () {\n    this.acroField.setFlagTo(core_1.AcroFieldFlags.NoExport, false);\n  };\n  /**\n   * Indicate that this field's value should **not** be exported when the form\n   * is submitted in a PDF reader. For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * field.disableExporting()\n   * ```\n   */\n  PDFField.prototype.disableExporting = function () {\n    this.acroField.setFlagTo(core_1.AcroFieldFlags.NoExport, true);\n  };\n  /** @ignore */\n  PDFField.prototype.needsAppearancesUpdate = function () {\n    throw new core_1.MethodNotImplementedError(this.constructor.name, 'needsAppearancesUpdate');\n  };\n  /** @ignore */\n  PDFField.prototype.defaultUpdateAppearances = function (_font) {\n    throw new core_1.MethodNotImplementedError(this.constructor.name, 'defaultUpdateAppearances');\n  };\n  PDFField.prototype.markAsDirty = function () {\n    this.doc.getForm().markFieldAsDirty(this.ref);\n  };\n  PDFField.prototype.markAsClean = function () {\n    this.doc.getForm().markFieldAsClean(this.ref);\n  };\n  PDFField.prototype.isDirty = function () {\n    return this.doc.getForm().fieldIsDirty(this.ref);\n  };\n  PDFField.prototype.createWidget = function (options) {\n    var _a;\n    var textColor = options.textColor;\n    var backgroundColor = options.backgroundColor;\n    var borderColor = options.borderColor;\n    var borderWidth = options.borderWidth;\n    var degreesAngle = rotations_1.toDegrees(options.rotate);\n    var caption = options.caption;\n    var x = options.x;\n    var y = options.y;\n    var width = options.width + borderWidth;\n    var height = options.height + borderWidth;\n    var hidden = Boolean(options.hidden);\n    var pageRef = options.page;\n    utils_1.assertMultiple(degreesAngle, 'degreesAngle', 90);\n    // Create a widget for this field\n    var widget = core_1.PDFWidgetAnnotation.create(this.doc.context, this.ref);\n    // Set widget properties\n    var rect = rotations_1.rotateRectangle({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }, borderWidth, degreesAngle);\n    widget.setRectangle(rect);\n    if (pageRef) widget.setP(pageRef);\n    var ac = widget.getOrCreateAppearanceCharacteristics();\n    if (backgroundColor) {\n      ac.setBackgroundColor(colors_1.colorToComponents(backgroundColor));\n    }\n    ac.setRotation(degreesAngle);\n    if (caption) ac.setCaptions({\n      normal: caption\n    });\n    if (borderColor) ac.setBorderColor(colors_1.colorToComponents(borderColor));\n    var bs = widget.getOrCreateBorderStyle();\n    if (borderWidth !== undefined) bs.setWidth(borderWidth);\n    widget.setFlagTo(core_1.AnnotationFlags.Print, true);\n    widget.setFlagTo(core_1.AnnotationFlags.Hidden, hidden);\n    widget.setFlagTo(core_1.AnnotationFlags.Invisible, false);\n    // Set acrofield properties\n    if (textColor) {\n      var da = (_a = this.acroField.getDefaultAppearance()) !== null && _a !== void 0 ? _a : '';\n      var newDa = da + '\\n' + colors_1.setFillingColor(textColor).toString();\n      this.acroField.setDefaultAppearance(newDa);\n    }\n    return widget;\n  };\n  PDFField.prototype.updateWidgetAppearanceWithFont = function (widget, font, _a) {\n    var normal = _a.normal,\n      rollover = _a.rollover,\n      down = _a.down;\n    this.updateWidgetAppearances(widget, {\n      normal: this.createAppearanceStream(widget, normal, font),\n      rollover: rollover && this.createAppearanceStream(widget, rollover, font),\n      down: down && this.createAppearanceStream(widget, down, font)\n    });\n  };\n  PDFField.prototype.updateOnOffWidgetAppearance = function (widget, onValue, _a) {\n    var normal = _a.normal,\n      rollover = _a.rollover,\n      down = _a.down;\n    this.updateWidgetAppearances(widget, {\n      normal: this.createAppearanceDict(widget, normal, onValue),\n      rollover: rollover && this.createAppearanceDict(widget, rollover, onValue),\n      down: down && this.createAppearanceDict(widget, down, onValue)\n    });\n  };\n  PDFField.prototype.updateWidgetAppearances = function (widget, _a) {\n    var normal = _a.normal,\n      rollover = _a.rollover,\n      down = _a.down;\n    widget.setNormalAppearance(normal);\n    if (rollover) {\n      widget.setRolloverAppearance(rollover);\n    } else {\n      widget.removeRolloverAppearance();\n    }\n    if (down) {\n      widget.setDownAppearance(down);\n    } else {\n      widget.removeDownAppearance();\n    }\n  };\n  // // TODO: Do we need to do this...?\n  // private foo(font: PDFFont, dict: PDFDict) {\n  //   if (!dict.lookup(PDFName.of('DR'))) {\n  //     dict.set(PDFName.of('DR'), dict.context.obj({}));\n  //   }\n  //   const DR = dict.lookup(PDFName.of('DR'), PDFDict);\n  //   if (!DR.lookup(PDFName.of('Font'))) {\n  //     DR.set(PDFName.of('Font'), dict.context.obj({}));\n  //   }\n  //   const Font = DR.lookup(PDFName.of('Font'), PDFDict);\n  //   Font.set(PDFName.of(font.name), font.ref);\n  // }\n  PDFField.prototype.createAppearanceStream = function (widget, appearance, font) {\n    var _a;\n    var context = this.acroField.dict.context;\n    var _b = widget.getRectangle(),\n      width = _b.width,\n      height = _b.height;\n    // TODO: Do we need to do this...?\n    // if (font) {\n    //   this.foo(font, widget.dict);\n    //   this.foo(font, this.doc.getForm().acroForm.dict);\n    // }\n    // END TODO\n    var Resources = font && {\n      Font: (_a = {}, _a[font.name] = font.ref, _a)\n    };\n    var stream = context.formXObject(appearance, {\n      Resources: Resources,\n      BBox: context.obj([0, 0, width, height]),\n      Matrix: context.obj([1, 0, 0, 1, 0, 0])\n    });\n    var streamRef = context.register(stream);\n    return streamRef;\n  };\n  /**\n   * Create a FormXObject of the supplied image and add it to context.\n   * The FormXObject size is calculated based on the widget (including\n   * the alignment).\n   * @param widget The widget that should display the image.\n   * @param alignment The alignment of the image.\n   * @param image The image that should be displayed.\n   * @returns The ref for the FormXObject that was added to the context.\n   */\n  PDFField.prototype.createImageAppearanceStream = function (widget, image, alignment) {\n    // NOTE: This implementation doesn't handle image borders.\n    // NOTE: Acrobat seems to resize the image (maybe even skewing its aspect\n    //       ratio) to fit perfectly within the widget's rectangle. This method\n    //       does not currently do that. Should there be an option for that?\n    var _a;\n    var _b;\n    var context = this.acroField.dict.context;\n    var rectangle = widget.getRectangle();\n    var ap = widget.getAppearanceCharacteristics();\n    var bs = widget.getBorderStyle();\n    var borderWidth = (_b = bs === null || bs === void 0 ? void 0 : bs.getWidth()) !== null && _b !== void 0 ? _b : 0;\n    var rotation = rotations_1.reduceRotation(ap === null || ap === void 0 ? void 0 : ap.getRotation());\n    var rotate = operations_1.rotateInPlace(tslib_1.__assign(tslib_1.__assign({}, rectangle), {\n      rotation: rotation\n    }));\n    var adj = rotations_1.adjustDimsForRotation(rectangle, rotation);\n    var imageDims = image.scaleToFit(adj.width - borderWidth * 2, adj.height - borderWidth * 2);\n    // Support borders on images and maybe other properties\n    var options = {\n      x: borderWidth,\n      y: borderWidth,\n      width: imageDims.width,\n      height: imageDims.height,\n      //\n      rotate: rotations_1.degrees(0),\n      xSkew: rotations_1.degrees(0),\n      ySkew: rotations_1.degrees(0)\n    };\n    if (alignment === image_1.ImageAlignment.Center) {\n      options.x += (adj.width - borderWidth * 2) / 2 - imageDims.width / 2;\n      options.y += (adj.height - borderWidth * 2) / 2 - imageDims.height / 2;\n    } else if (alignment === image_1.ImageAlignment.Right) {\n      options.x = adj.width - borderWidth - imageDims.width;\n      options.y = adj.height - borderWidth - imageDims.height;\n    }\n    var imageName = this.doc.context.addRandomSuffix('Image', 10);\n    var appearance = tslib_1.__spreadArrays(rotate, operations_1.drawImage(imageName, options));\n    ////////////\n    var Resources = {\n      XObject: (_a = {}, _a[imageName] = image.ref, _a)\n    };\n    var stream = context.formXObject(appearance, {\n      Resources: Resources,\n      BBox: context.obj([0, 0, rectangle.width, rectangle.height]),\n      Matrix: context.obj([1, 0, 0, 1, 0, 0])\n    });\n    return context.register(stream);\n  };\n  PDFField.prototype.createAppearanceDict = function (widget, appearance, onValue) {\n    var context = this.acroField.dict.context;\n    var onStreamRef = this.createAppearanceStream(widget, appearance.on);\n    var offStreamRef = this.createAppearanceStream(widget, appearance.off);\n    var appearanceDict = context.obj({});\n    appearanceDict.set(onValue, onStreamRef);\n    appearanceDict.set(core_1.PDFName.of('Off'), offStreamRef);\n    return appearanceDict;\n  };\n  return PDFField;\n}();\nexports.default = PDFField;","map":{"version":3,"names":["PDFDocument_1","tslib_1","__importDefault","require","colors_1","rotations_1","core_1","utils_1","image_1","operations_1","exports","assertFieldAppearanceOptions","options","assertOrUndefined","x","y","width","height","textColor","Object","backgroundColor","borderColor","borderWidth","rotate","PDFField","acroField","ref","doc","assertIs","PDFAcroTerminal","PDFRef","default","prototype","getName","_a","getFullyQualifiedName","isReadOnly","hasFlag","AcroFieldFlags","ReadOnly","enableReadOnly","setFlagTo","disableReadOnly","isRequired","Required","enableRequired","disableRequired","isExported","NoExport","enableExporting","disableExporting","needsAppearancesUpdate","MethodNotImplementedError","constructor","name","defaultUpdateAppearances","_font","markAsDirty","getForm","markFieldAsDirty","markAsClean","markFieldAsClean","isDirty","fieldIsDirty","createWidget","degreesAngle","toDegrees","caption","hidden","Boolean","pageRef","page","assertMultiple","widget","PDFWidgetAnnotation","create","context","rect","rotateRectangle","setRectangle","setP","ac","getOrCreateAppearanceCharacteristics","setBackgroundColor","colorToComponents","setRotation","setCaptions","normal","setBorderColor","bs","getOrCreateBorderStyle","undefined","setWidth","AnnotationFlags","Print","Hidden","Invisible","da","getDefaultAppearance","newDa","setFillingColor","toString","setDefaultAppearance","updateWidgetAppearanceWithFont","font","rollover","down","updateWidgetAppearances","createAppearanceStream","updateOnOffWidgetAppearance","onValue","createAppearanceDict","setNormalAppearance","setRolloverAppearance","removeRolloverAppearance","setDownAppearance","removeDownAppearance","appearance","dict","_b","getRectangle","Resources","Font","stream","formXObject","BBox","obj","Matrix","streamRef","register","createImageAppearanceStream","image","alignment","rectangle","ap","getAppearanceCharacteristics","getBorderStyle","getWidth","rotation","reduceRotation","getRotation","rotateInPlace","__assign","adj","adjustDimsForRotation","imageDims","scaleToFit","degrees","xSkew","ySkew","ImageAlignment","Center","Right","imageName","addRandomSuffix","__spreadArrays","drawImage","XObject","onStreamRef","on","offStreamRef","off","appearanceDict","set","PDFName","of"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/api/form/PDFField.ts"],"sourcesContent":["import PDFDocument from 'src/api/PDFDocument';\nimport PDFFont from 'src/api/PDFFont';\nimport { AppearanceMapping } from 'src/api/form/appearances';\nimport { Color, colorToComponents, setFillingColor } from 'src/api/colors';\nimport {\n  Rotation,\n  toDegrees,\n  rotateRectangle,\n  reduceRotation,\n  adjustDimsForRotation,\n  degrees,\n} from 'src/api/rotations';\n\nimport {\n  PDFRef,\n  PDFWidgetAnnotation,\n  PDFOperator,\n  PDFName,\n  PDFDict,\n  MethodNotImplementedError,\n  AcroFieldFlags,\n  PDFAcroTerminal,\n  AnnotationFlags,\n} from 'src/core';\nimport { assertIs, assertMultiple, assertOrUndefined } from 'src/utils';\nimport { ImageAlignment } from '../image';\nimport PDFImage from '../PDFImage';\nimport { drawImage, rotateInPlace } from '../operations';\n\nexport interface FieldAppearanceOptions {\n  x?: number;\n  y?: number;\n  width?: number;\n  height?: number;\n  textColor?: Color;\n  backgroundColor?: Color;\n  borderColor?: Color;\n  borderWidth?: number;\n  rotate?: Rotation;\n  font?: PDFFont;\n  hidden?: boolean;\n}\n\nexport const assertFieldAppearanceOptions = (\n  options?: FieldAppearanceOptions,\n) => {\n  assertOrUndefined(options?.x, 'options.x', ['number']);\n  assertOrUndefined(options?.y, 'options.y', ['number']);\n  assertOrUndefined(options?.width, 'options.width', ['number']);\n  assertOrUndefined(options?.height, 'options.height', ['number']);\n  assertOrUndefined(options?.textColor, 'options.textColor', [\n    [Object, 'Color'],\n  ]);\n  assertOrUndefined(options?.backgroundColor, 'options.backgroundColor', [\n    [Object, 'Color'],\n  ]);\n  assertOrUndefined(options?.borderColor, 'options.borderColor', [\n    [Object, 'Color'],\n  ]);\n  assertOrUndefined(options?.borderWidth, 'options.borderWidth', ['number']);\n  assertOrUndefined(options?.rotate, 'options.rotate', [[Object, 'Rotation']]);\n};\n\n/**\n * Represents a field of a [[PDFForm]].\n *\n * This class is effectively abstract. All fields in a [[PDFForm]] will\n * actually be an instance of a subclass of this class.\n *\n * Note that each field in a PDF is represented by a single field object.\n * However, a given field object may be rendered at multiple locations within\n * the document (across one or more pages). The rendering of a field is\n * controlled by its widgets. Each widget causes its field to be displayed at a\n * particular location in the document.\n *\n * Most of the time each field in a PDF has only a single widget, and thus is\n * only rendered once. However, if a field is rendered multiple times, it will\n * have multiple widgets - one for each location it is rendered.\n *\n * This abstraction of field objects and widgets is defined in the PDF\n * specification and dictates how PDF files store fields and where they are\n * to be rendered.\n */\nexport default class PDFField {\n  /** The low-level PDFAcroTerminal wrapped by this field. */\n  readonly acroField: PDFAcroTerminal;\n\n  /** The unique reference assigned to this field within the document. */\n  readonly ref: PDFRef;\n\n  /** The document to which this field belongs. */\n  readonly doc: PDFDocument;\n\n  protected constructor(\n    acroField: PDFAcroTerminal,\n    ref: PDFRef,\n    doc: PDFDocument,\n  ) {\n    assertIs(acroField, 'acroField', [[PDFAcroTerminal, 'PDFAcroTerminal']]);\n    assertIs(ref, 'ref', [[PDFRef, 'PDFRef']]);\n    assertIs(doc, 'doc', [[PDFDocument, 'PDFDocument']]);\n\n    this.acroField = acroField;\n    this.ref = ref;\n    this.doc = doc;\n  }\n\n  /**\n   * Get the fully qualified name of this field. For example:\n   * ```js\n   * const fields = form.getFields()\n   * fields.forEach(field => {\n   *   const name = field.getName()\n   *   console.log('Field name:', name)\n   * })\n   * ```\n   * Note that PDF fields are structured as a tree. Each field is the\n   * descendent of a series of ancestor nodes all the way up to the form node,\n   * which is always the root of the tree. Each node in the tree (except for\n   * the form node) has a partial name. Partial names can be composed of any\n   * unicode characters except a period (`.`). The fully qualified name of a\n   * field is composed of the partial names of all its ancestors joined\n   * with periods. This means that splitting the fully qualified name on\n   * periods and taking the last element of the resulting array will give you\n   * the partial name of a specific field.\n   * @returns The fully qualified name of this field.\n   */\n  getName(): string {\n    return this.acroField.getFullyQualifiedName() ?? '';\n  }\n\n  /**\n   * Returns `true` if this field is read only. This means that PDF readers\n   * will not allow users to interact with the field or change its value. See\n   * [[PDFField.enableReadOnly]] and [[PDFField.disableReadOnly]].\n   * For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * if (field.isReadOnly()) console.log('Read only is enabled')\n   * ```\n   * @returns Whether or not this is a read only field.\n   */\n  isReadOnly(): boolean {\n    return this.acroField.hasFlag(AcroFieldFlags.ReadOnly);\n  }\n\n  /**\n   * Prevent PDF readers from allowing users to interact with this field or\n   * change its value. The field will not respond to mouse or keyboard input.\n   * For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * field.enableReadOnly()\n   * ```\n   * Useful for fields whose values are computed, imported from a database, or\n   * prefilled by software before being displayed to the user.\n   */\n  enableReadOnly() {\n    this.acroField.setFlagTo(AcroFieldFlags.ReadOnly, true);\n  }\n\n  /**\n   * Allow users to interact with this field and change its value in PDF\n   * readers via mouse and keyboard input. For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * field.disableReadOnly()\n   * ```\n   */\n  disableReadOnly() {\n    this.acroField.setFlagTo(AcroFieldFlags.ReadOnly, false);\n  }\n\n  /**\n   * Returns `true` if this field must have a value when the form is submitted.\n   * See [[PDFField.enableRequired]] and [[PDFField.disableRequired]].\n   * For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * if (field.isRequired()) console.log('Field is required')\n   * ```\n   * @returns Whether or not this field is required.\n   */\n  isRequired(): boolean {\n    return this.acroField.hasFlag(AcroFieldFlags.Required);\n  }\n\n  /**\n   * Require this field to have a value when the form is submitted.\n   * For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * field.enableRequired()\n   * ```\n   */\n  enableRequired() {\n    this.acroField.setFlagTo(AcroFieldFlags.Required, true);\n  }\n\n  /**\n   * Do not require this field to have a value when the form is submitted.\n   * For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * field.disableRequired()\n   * ```\n   */\n  disableRequired() {\n    this.acroField.setFlagTo(AcroFieldFlags.Required, false);\n  }\n\n  /**\n   * Returns `true` if this field's value should be exported when the form is\n   * submitted. See [[PDFField.enableExporting]] and\n   * [[PDFField.disableExporting]].\n   * For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * if (field.isExported()) console.log('Exporting is enabled')\n   * ```\n   * @returns Whether or not this field's value should be exported.\n   */\n  isExported(): boolean {\n    return !this.acroField.hasFlag(AcroFieldFlags.NoExport);\n  }\n\n  /**\n   * Indicate that this field's value should be exported when the form is\n   * submitted in a PDF reader. For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * field.enableExporting()\n   * ```\n   */\n  enableExporting() {\n    this.acroField.setFlagTo(AcroFieldFlags.NoExport, false);\n  }\n\n  /**\n   * Indicate that this field's value should **not** be exported when the form\n   * is submitted in a PDF reader. For example:\n   * ```js\n   * const field = form.getField('some.field')\n   * field.disableExporting()\n   * ```\n   */\n  disableExporting() {\n    this.acroField.setFlagTo(AcroFieldFlags.NoExport, true);\n  }\n\n  /** @ignore */\n  needsAppearancesUpdate(): boolean {\n    throw new MethodNotImplementedError(\n      this.constructor.name,\n      'needsAppearancesUpdate',\n    );\n  }\n\n  /** @ignore */\n  defaultUpdateAppearances(_font: PDFFont) {\n    throw new MethodNotImplementedError(\n      this.constructor.name,\n      'defaultUpdateAppearances',\n    );\n  }\n\n  protected markAsDirty() {\n    this.doc.getForm().markFieldAsDirty(this.ref);\n  }\n\n  protected markAsClean() {\n    this.doc.getForm().markFieldAsClean(this.ref);\n  }\n\n  protected isDirty(): boolean {\n    return this.doc.getForm().fieldIsDirty(this.ref);\n  }\n\n  protected createWidget(options: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    textColor?: Color;\n    backgroundColor?: Color;\n    borderColor?: Color;\n    borderWidth: number;\n    rotate: Rotation;\n    caption?: string;\n    hidden?: boolean;\n    page?: PDFRef;\n  }): PDFWidgetAnnotation {\n    const textColor = options.textColor;\n    const backgroundColor = options.backgroundColor;\n    const borderColor = options.borderColor;\n    const borderWidth = options.borderWidth;\n    const degreesAngle = toDegrees(options.rotate);\n    const caption = options.caption;\n    const x = options.x;\n    const y = options.y;\n    const width = options.width + borderWidth;\n    const height = options.height + borderWidth;\n    const hidden = Boolean(options.hidden);\n    const pageRef = options.page;\n\n    assertMultiple(degreesAngle, 'degreesAngle', 90);\n\n    // Create a widget for this field\n    const widget = PDFWidgetAnnotation.create(this.doc.context, this.ref);\n\n    // Set widget properties\n    const rect = rotateRectangle(\n      { x, y, width, height },\n      borderWidth,\n      degreesAngle,\n    );\n    widget.setRectangle(rect);\n\n    if (pageRef) widget.setP(pageRef);\n\n    const ac = widget.getOrCreateAppearanceCharacteristics();\n    if (backgroundColor) {\n      ac.setBackgroundColor(colorToComponents(backgroundColor));\n    }\n    ac.setRotation(degreesAngle);\n    if (caption) ac.setCaptions({ normal: caption });\n    if (borderColor) ac.setBorderColor(colorToComponents(borderColor));\n\n    const bs = widget.getOrCreateBorderStyle();\n    if (borderWidth !== undefined) bs.setWidth(borderWidth);\n\n    widget.setFlagTo(AnnotationFlags.Print, true);\n    widget.setFlagTo(AnnotationFlags.Hidden, hidden);\n    widget.setFlagTo(AnnotationFlags.Invisible, false);\n\n    // Set acrofield properties\n    if (textColor) {\n      const da = this.acroField.getDefaultAppearance() ?? '';\n      const newDa = da + '\\n' + setFillingColor(textColor).toString();\n      this.acroField.setDefaultAppearance(newDa);\n    }\n\n    return widget;\n  }\n\n  protected updateWidgetAppearanceWithFont(\n    widget: PDFWidgetAnnotation,\n    font: PDFFont,\n    { normal, rollover, down }: AppearanceMapping<PDFOperator[]>,\n  ) {\n    this.updateWidgetAppearances(widget, {\n      normal: this.createAppearanceStream(widget, normal, font),\n      rollover: rollover && this.createAppearanceStream(widget, rollover, font),\n      down: down && this.createAppearanceStream(widget, down, font),\n    });\n  }\n\n  protected updateOnOffWidgetAppearance(\n    widget: PDFWidgetAnnotation,\n    onValue: PDFName,\n    {\n      normal,\n      rollover,\n      down,\n    }: AppearanceMapping<{ on: PDFOperator[]; off: PDFOperator[] }>,\n  ) {\n    this.updateWidgetAppearances(widget, {\n      normal: this.createAppearanceDict(widget, normal, onValue),\n      rollover:\n        rollover && this.createAppearanceDict(widget, rollover, onValue),\n      down: down && this.createAppearanceDict(widget, down, onValue),\n    });\n  }\n\n  protected updateWidgetAppearances(\n    widget: PDFWidgetAnnotation,\n    { normal, rollover, down }: AppearanceMapping<PDFRef | PDFDict>,\n  ) {\n    widget.setNormalAppearance(normal);\n\n    if (rollover) {\n      widget.setRolloverAppearance(rollover);\n    } else {\n      widget.removeRolloverAppearance();\n    }\n\n    if (down) {\n      widget.setDownAppearance(down);\n    } else {\n      widget.removeDownAppearance();\n    }\n  }\n\n  // // TODO: Do we need to do this...?\n  // private foo(font: PDFFont, dict: PDFDict) {\n  //   if (!dict.lookup(PDFName.of('DR'))) {\n  //     dict.set(PDFName.of('DR'), dict.context.obj({}));\n  //   }\n  //   const DR = dict.lookup(PDFName.of('DR'), PDFDict);\n\n  //   if (!DR.lookup(PDFName.of('Font'))) {\n  //     DR.set(PDFName.of('Font'), dict.context.obj({}));\n  //   }\n  //   const Font = DR.lookup(PDFName.of('Font'), PDFDict);\n\n  //   Font.set(PDFName.of(font.name), font.ref);\n  // }\n\n  private createAppearanceStream(\n    widget: PDFWidgetAnnotation,\n    appearance: PDFOperator[],\n    font?: PDFFont,\n  ): PDFRef {\n    const { context } = this.acroField.dict;\n    const { width, height } = widget.getRectangle();\n\n    // TODO: Do we need to do this...?\n    // if (font) {\n    //   this.foo(font, widget.dict);\n    //   this.foo(font, this.doc.getForm().acroForm.dict);\n    // }\n    // END TODO\n\n    const Resources = font && { Font: { [font.name]: font.ref } };\n    const stream = context.formXObject(appearance, {\n      Resources,\n      BBox: context.obj([0, 0, width, height]),\n      Matrix: context.obj([1, 0, 0, 1, 0, 0]),\n    });\n    const streamRef = context.register(stream);\n\n    return streamRef;\n  }\n\n  /**\n   * Create a FormXObject of the supplied image and add it to context.\n   * The FormXObject size is calculated based on the widget (including\n   * the alignment).\n   * @param widget The widget that should display the image.\n   * @param alignment The alignment of the image.\n   * @param image The image that should be displayed.\n   * @returns The ref for the FormXObject that was added to the context.\n   */\n  protected createImageAppearanceStream(\n    widget: PDFWidgetAnnotation,\n    image: PDFImage,\n    alignment: ImageAlignment,\n  ): PDFRef {\n    // NOTE: This implementation doesn't handle image borders.\n    // NOTE: Acrobat seems to resize the image (maybe even skewing its aspect\n    //       ratio) to fit perfectly within the widget's rectangle. This method\n    //       does not currently do that. Should there be an option for that?\n\n    const { context } = this.acroField.dict;\n\n    const rectangle = widget.getRectangle();\n    const ap = widget.getAppearanceCharacteristics();\n    const bs = widget.getBorderStyle();\n\n    const borderWidth = bs?.getWidth() ?? 0;\n    const rotation = reduceRotation(ap?.getRotation());\n\n    const rotate = rotateInPlace({ ...rectangle, rotation });\n\n    const adj = adjustDimsForRotation(rectangle, rotation);\n    const imageDims = image.scaleToFit(\n      adj.width - borderWidth * 2,\n      adj.height - borderWidth * 2,\n    );\n\n    // Support borders on images and maybe other properties\n    const options = {\n      x: borderWidth,\n      y: borderWidth,\n      width: imageDims.width,\n      height: imageDims.height,\n      //\n      rotate: degrees(0),\n      xSkew: degrees(0),\n      ySkew: degrees(0),\n    };\n\n    if (alignment === ImageAlignment.Center) {\n      options.x += (adj.width - borderWidth * 2) / 2 - imageDims.width / 2;\n      options.y += (adj.height - borderWidth * 2) / 2 - imageDims.height / 2;\n    } else if (alignment === ImageAlignment.Right) {\n      options.x = adj.width - borderWidth - imageDims.width;\n      options.y = adj.height - borderWidth - imageDims.height;\n    }\n\n    const imageName = this.doc.context.addRandomSuffix('Image', 10);\n    const appearance = [...rotate, ...drawImage(imageName, options)];\n    ////////////\n\n    const Resources = { XObject: { [imageName]: image.ref } };\n    const stream = context.formXObject(appearance, {\n      Resources,\n      BBox: context.obj([0, 0, rectangle.width, rectangle.height]),\n      Matrix: context.obj([1, 0, 0, 1, 0, 0]),\n    });\n\n    return context.register(stream);\n  }\n\n  private createAppearanceDict(\n    widget: PDFWidgetAnnotation,\n    appearance: { on: PDFOperator[]; off: PDFOperator[] },\n    onValue: PDFName,\n  ): PDFDict {\n    const { context } = this.acroField.dict;\n\n    const onStreamRef = this.createAppearanceStream(widget, appearance.on);\n    const offStreamRef = this.createAppearanceStream(widget, appearance.off);\n\n    const appearanceDict = context.obj({});\n    appearanceDict.set(onValue, onStreamRef);\n    appearanceDict.set(PDFName.of('Off'), offStreamRef);\n\n    return appearanceDict;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}