{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PNG = exports.PngType = void 0;\nvar tslib_1 = require(\"tslib\");\nvar upng_1 = tslib_1.__importDefault(require(\"@pdf-lib/upng\"));\nvar getImageType = function (ctype) {\n  if (ctype === 0) return PngType.Greyscale;\n  if (ctype === 2) return PngType.Truecolour;\n  if (ctype === 3) return PngType.IndexedColour;\n  if (ctype === 4) return PngType.GreyscaleWithAlpha;\n  if (ctype === 6) return PngType.TruecolourWithAlpha;\n  throw new Error(\"Unknown color type: \" + ctype);\n};\nvar splitAlphaChannel = function (rgbaChannel) {\n  var pixelCount = Math.floor(rgbaChannel.length / 4);\n  var rgbChannel = new Uint8Array(pixelCount * 3);\n  var alphaChannel = new Uint8Array(pixelCount * 1);\n  var rgbaOffset = 0;\n  var rgbOffset = 0;\n  var alphaOffset = 0;\n  while (rgbaOffset < rgbaChannel.length) {\n    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];\n    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];\n    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];\n    alphaChannel[alphaOffset++] = rgbaChannel[rgbaOffset++];\n  }\n  return {\n    rgbChannel: rgbChannel,\n    alphaChannel: alphaChannel\n  };\n};\nvar PngType;\n(function (PngType) {\n  PngType[\"Greyscale\"] = \"Greyscale\";\n  PngType[\"Truecolour\"] = \"Truecolour\";\n  PngType[\"IndexedColour\"] = \"IndexedColour\";\n  PngType[\"GreyscaleWithAlpha\"] = \"GreyscaleWithAlpha\";\n  PngType[\"TruecolourWithAlpha\"] = \"TruecolourWithAlpha\";\n})(PngType = exports.PngType || (exports.PngType = {}));\nvar PNG = /** @class */function () {\n  function PNG(pngData) {\n    var upng = upng_1.default.decode(pngData);\n    var frames = upng_1.default.toRGBA8(upng);\n    if (frames.length > 1) throw new Error(\"Animated PNGs are not supported\");\n    var frame = new Uint8Array(frames[0]);\n    var _a = splitAlphaChannel(frame),\n      rgbChannel = _a.rgbChannel,\n      alphaChannel = _a.alphaChannel;\n    this.rgbChannel = rgbChannel;\n    var hasAlphaValues = alphaChannel.some(function (a) {\n      return a < 255;\n    });\n    if (hasAlphaValues) this.alphaChannel = alphaChannel;\n    this.type = getImageType(upng.ctype);\n    this.width = upng.width;\n    this.height = upng.height;\n    this.bitsPerComponent = 8;\n  }\n  PNG.load = function (pngData) {\n    return new PNG(pngData);\n  };\n  return PNG;\n}();\nexports.PNG = PNG;","map":{"version":3,"names":["upng_1","tslib_1","__importDefault","require","getImageType","ctype","PngType","Greyscale","Truecolour","IndexedColour","GreyscaleWithAlpha","TruecolourWithAlpha","Error","splitAlphaChannel","rgbaChannel","pixelCount","Math","floor","length","rgbChannel","Uint8Array","alphaChannel","rgbaOffset","rgbOffset","alphaOffset","exports","PNG","pngData","upng","default","decode","frames","toRGBA8","frame","_a","hasAlphaValues","some","a","type","width","height","bitsPerComponent","load"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/utils/png.ts"],"sourcesContent":["import UPNG from '@pdf-lib/upng';\n\nconst getImageType = (ctype: number) => {\n  if (ctype === 0) return PngType.Greyscale;\n  if (ctype === 2) return PngType.Truecolour;\n  if (ctype === 3) return PngType.IndexedColour;\n  if (ctype === 4) return PngType.GreyscaleWithAlpha;\n  if (ctype === 6) return PngType.TruecolourWithAlpha;\n  throw new Error(`Unknown color type: ${ctype}`);\n};\n\nconst splitAlphaChannel = (rgbaChannel: Uint8Array) => {\n  const pixelCount = Math.floor(rgbaChannel.length / 4);\n\n  const rgbChannel = new Uint8Array(pixelCount * 3);\n  const alphaChannel = new Uint8Array(pixelCount * 1);\n\n  let rgbaOffset = 0;\n  let rgbOffset = 0;\n  let alphaOffset = 0;\n\n  while (rgbaOffset < rgbaChannel.length) {\n    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];\n    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];\n    rgbChannel[rgbOffset++] = rgbaChannel[rgbaOffset++];\n    alphaChannel[alphaOffset++] = rgbaChannel[rgbaOffset++];\n  }\n\n  return { rgbChannel, alphaChannel };\n};\n\nexport enum PngType {\n  Greyscale = 'Greyscale',\n  Truecolour = 'Truecolour',\n  IndexedColour = 'IndexedColour',\n  GreyscaleWithAlpha = 'GreyscaleWithAlpha',\n  TruecolourWithAlpha = 'TruecolourWithAlpha',\n}\n\nexport class PNG {\n  static load = (pngData: Uint8Array) => new PNG(pngData);\n\n  readonly rgbChannel: Uint8Array;\n  readonly alphaChannel?: Uint8Array;\n  readonly type: PngType;\n  readonly width: number;\n  readonly height: number;\n  readonly bitsPerComponent: number;\n\n  private constructor(pngData: Uint8Array) {\n    const upng = UPNG.decode(pngData);\n    const frames = UPNG.toRGBA8(upng);\n\n    if (frames.length > 1) throw new Error(`Animated PNGs are not supported`);\n\n    const frame = new Uint8Array(frames[0]);\n    const { rgbChannel, alphaChannel } = splitAlphaChannel(frame);\n\n    this.rgbChannel = rgbChannel;\n\n    const hasAlphaValues = alphaChannel.some((a) => a < 255);\n    if (hasAlphaValues) this.alphaChannel = alphaChannel;\n\n    this.type = getImageType(upng.ctype);\n\n    this.width = upng.width;\n    this.height = upng.height;\n    this.bitsPerComponent = 8;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}