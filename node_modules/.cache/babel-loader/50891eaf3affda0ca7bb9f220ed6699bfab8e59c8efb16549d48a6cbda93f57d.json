{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar errors_1 = require(\"../errors\");\nvar PDFArray_1 = tslib_1.__importDefault(require(\"../objects/PDFArray\"));\nvar PDFName_1 = tslib_1.__importDefault(require(\"../objects/PDFName\"));\nvar PDFNumber_1 = tslib_1.__importDefault(require(\"../objects/PDFNumber\"));\nvar PDFRef_1 = tslib_1.__importDefault(require(\"../objects/PDFRef\"));\nvar ByteStream_1 = tslib_1.__importDefault(require(\"./ByteStream\"));\nvar PDFXRefStreamParser = /** @class */function () {\n  function PDFXRefStreamParser(rawStream) {\n    this.alreadyParsed = false;\n    this.dict = rawStream.dict;\n    this.bytes = ByteStream_1.default.fromPDFRawStream(rawStream);\n    this.context = this.dict.context;\n    var Size = this.dict.lookup(PDFName_1.default.of('Size'), PDFNumber_1.default);\n    var Index = this.dict.lookup(PDFName_1.default.of('Index'));\n    if (Index instanceof PDFArray_1.default) {\n      this.subsections = [];\n      for (var idx = 0, len = Index.size(); idx < len; idx += 2) {\n        var firstObjectNumber = Index.lookup(idx + 0, PDFNumber_1.default).asNumber();\n        var length_1 = Index.lookup(idx + 1, PDFNumber_1.default).asNumber();\n        this.subsections.push({\n          firstObjectNumber: firstObjectNumber,\n          length: length_1\n        });\n      }\n    } else {\n      this.subsections = [{\n        firstObjectNumber: 0,\n        length: Size.asNumber()\n      }];\n    }\n    var W = this.dict.lookup(PDFName_1.default.of('W'), PDFArray_1.default);\n    this.byteWidths = [-1, -1, -1];\n    for (var idx = 0, len = W.size(); idx < len; idx++) {\n      this.byteWidths[idx] = W.lookup(idx, PDFNumber_1.default).asNumber();\n    }\n  }\n  PDFXRefStreamParser.prototype.parseIntoContext = function () {\n    if (this.alreadyParsed) {\n      throw new errors_1.ReparseError('PDFXRefStreamParser', 'parseIntoContext');\n    }\n    this.alreadyParsed = true;\n    this.context.trailerInfo = {\n      Root: this.dict.get(PDFName_1.default.of('Root')),\n      Encrypt: this.dict.get(PDFName_1.default.of('Encrypt')),\n      Info: this.dict.get(PDFName_1.default.of('Info')),\n      ID: this.dict.get(PDFName_1.default.of('ID'))\n    };\n    var entries = this.parseEntries();\n    // for (let idx = 0, len = entries.length; idx < len; idx++) {\n    // const entry = entries[idx];\n    // if (entry.deleted) this.context.delete(entry.ref);\n    // }\n    return entries;\n  };\n  PDFXRefStreamParser.prototype.parseEntries = function () {\n    var entries = [];\n    var _a = this.byteWidths,\n      typeFieldWidth = _a[0],\n      offsetFieldWidth = _a[1],\n      genFieldWidth = _a[2];\n    for (var subsectionIdx = 0, subsectionLen = this.subsections.length; subsectionIdx < subsectionLen; subsectionIdx++) {\n      var _b = this.subsections[subsectionIdx],\n        firstObjectNumber = _b.firstObjectNumber,\n        length_2 = _b.length;\n      for (var objIdx = 0; objIdx < length_2; objIdx++) {\n        var type = 0;\n        for (var idx = 0, len = typeFieldWidth; idx < len; idx++) {\n          type = type << 8 | this.bytes.next();\n        }\n        var offset = 0;\n        for (var idx = 0, len = offsetFieldWidth; idx < len; idx++) {\n          offset = offset << 8 | this.bytes.next();\n        }\n        var generationNumber = 0;\n        for (var idx = 0, len = genFieldWidth; idx < len; idx++) {\n          generationNumber = generationNumber << 8 | this.bytes.next();\n        }\n        // When the `type` field is absent, it defaults to 1\n        if (typeFieldWidth === 0) type = 1;\n        var objectNumber = firstObjectNumber + objIdx;\n        var entry = {\n          ref: PDFRef_1.default.of(objectNumber, generationNumber),\n          offset: offset,\n          deleted: type === 0,\n          inObjectStream: type === 2\n        };\n        entries.push(entry);\n      }\n    }\n    return entries;\n  };\n  PDFXRefStreamParser.forStream = function (rawStream) {\n    return new PDFXRefStreamParser(rawStream);\n  };\n  return PDFXRefStreamParser;\n}();\nexports.default = PDFXRefStreamParser;","map":{"version":3,"names":["errors_1","require","PDFArray_1","tslib_1","__importDefault","PDFName_1","PDFNumber_1","PDFRef_1","ByteStream_1","PDFXRefStreamParser","rawStream","alreadyParsed","dict","bytes","default","fromPDFRawStream","context","Size","lookup","of","Index","subsections","idx","len","size","firstObjectNumber","asNumber","length_1","push","length","W","byteWidths","prototype","parseIntoContext","ReparseError","trailerInfo","Root","get","Encrypt","Info","ID","entries","parseEntries","_a","typeFieldWidth","offsetFieldWidth","genFieldWidth","subsectionIdx","subsectionLen","_b","length_2","objIdx","type","next","offset","generationNumber","objectNumber","entry","ref","deleted","inObjectStream","forStream","exports"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/parser/PDFXRefStreamParser.ts"],"sourcesContent":["import { ReparseError } from 'src/core/errors';\nimport PDFArray from 'src/core/objects/PDFArray';\nimport PDFDict from 'src/core/objects/PDFDict';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFNumber from 'src/core/objects/PDFNumber';\nimport PDFRawStream from 'src/core/objects/PDFRawStream';\nimport PDFRef from 'src/core/objects/PDFRef';\nimport ByteStream from 'src/core/parser/ByteStream';\nimport PDFContext from 'src/core/PDFContext';\n\nexport interface Entry {\n  ref: PDFRef;\n  offset: number;\n  deleted: boolean;\n  inObjectStream: boolean;\n}\n\nclass PDFXRefStreamParser {\n  static forStream = (rawStream: PDFRawStream) =>\n    new PDFXRefStreamParser(rawStream);\n\n  private alreadyParsed: boolean;\n\n  private readonly dict: PDFDict;\n  private readonly context: PDFContext;\n  private readonly bytes: ByteStream;\n  private readonly subsections: {\n    firstObjectNumber: number;\n    length: number;\n  }[];\n  private readonly byteWidths: [number, number, number];\n\n  constructor(rawStream: PDFRawStream) {\n    this.alreadyParsed = false;\n\n    this.dict = rawStream.dict;\n    this.bytes = ByteStream.fromPDFRawStream(rawStream);\n    this.context = this.dict.context;\n\n    const Size = this.dict.lookup(PDFName.of('Size'), PDFNumber);\n\n    const Index = this.dict.lookup(PDFName.of('Index'));\n    if (Index instanceof PDFArray) {\n      this.subsections = [];\n      for (let idx = 0, len = Index.size(); idx < len; idx += 2) {\n        const firstObjectNumber = Index.lookup(idx + 0, PDFNumber).asNumber();\n        const length = Index.lookup(idx + 1, PDFNumber).asNumber();\n        this.subsections.push({ firstObjectNumber, length });\n      }\n    } else {\n      this.subsections = [{ firstObjectNumber: 0, length: Size.asNumber() }];\n    }\n\n    const W = this.dict.lookup(PDFName.of('W'), PDFArray);\n    this.byteWidths = [-1, -1, -1];\n    for (let idx = 0, len = W.size(); idx < len; idx++) {\n      this.byteWidths[idx] = W.lookup(idx, PDFNumber).asNumber();\n    }\n  }\n\n  parseIntoContext(): Entry[] {\n    if (this.alreadyParsed) {\n      throw new ReparseError('PDFXRefStreamParser', 'parseIntoContext');\n    }\n    this.alreadyParsed = true;\n\n    this.context.trailerInfo = {\n      Root: this.dict.get(PDFName.of('Root')),\n      Encrypt: this.dict.get(PDFName.of('Encrypt')),\n      Info: this.dict.get(PDFName.of('Info')),\n      ID: this.dict.get(PDFName.of('ID')),\n    };\n\n    const entries = this.parseEntries();\n\n    // for (let idx = 0, len = entries.length; idx < len; idx++) {\n    // const entry = entries[idx];\n    // if (entry.deleted) this.context.delete(entry.ref);\n    // }\n\n    return entries;\n  }\n\n  private parseEntries(): Entry[] {\n    const entries = [];\n    const [typeFieldWidth, offsetFieldWidth, genFieldWidth] = this.byteWidths;\n\n    for (\n      let subsectionIdx = 0, subsectionLen = this.subsections.length;\n      subsectionIdx < subsectionLen;\n      subsectionIdx++\n    ) {\n      const { firstObjectNumber, length } = this.subsections[subsectionIdx];\n\n      for (let objIdx = 0; objIdx < length; objIdx++) {\n        let type = 0;\n        for (let idx = 0, len = typeFieldWidth; idx < len; idx++) {\n          type = (type << 8) | this.bytes.next();\n        }\n\n        let offset = 0;\n        for (let idx = 0, len = offsetFieldWidth; idx < len; idx++) {\n          offset = (offset << 8) | this.bytes.next();\n        }\n\n        let generationNumber = 0;\n        for (let idx = 0, len = genFieldWidth; idx < len; idx++) {\n          generationNumber = (generationNumber << 8) | this.bytes.next();\n        }\n\n        // When the `type` field is absent, it defaults to 1\n        if (typeFieldWidth === 0) type = 1;\n\n        const objectNumber = firstObjectNumber + objIdx;\n        const entry = {\n          ref: PDFRef.of(objectNumber, generationNumber),\n          offset,\n          deleted: type === 0,\n          inObjectStream: type === 2,\n        };\n\n        entries.push(entry);\n      }\n    }\n\n    return entries;\n  }\n}\n\nexport default PDFXRefStreamParser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}