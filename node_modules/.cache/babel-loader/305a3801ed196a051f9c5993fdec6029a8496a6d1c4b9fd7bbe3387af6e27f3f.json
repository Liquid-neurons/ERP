{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createPDFAcroField = exports.createPDFAcroFields = void 0;\nvar tslib_1 = require(\"tslib\");\nvar PDFNumber_1 = tslib_1.__importDefault(require(\"../objects/PDFNumber\"));\nvar PDFDict_1 = tslib_1.__importDefault(require(\"../objects/PDFDict\"));\nvar PDFName_1 = tslib_1.__importDefault(require(\"../objects/PDFName\"));\nvar PDFArray_1 = tslib_1.__importDefault(require(\"../objects/PDFArray\"));\nvar PDFRef_1 = tslib_1.__importDefault(require(\"../objects/PDFRef\"));\nvar PDFAcroTerminal_1 = tslib_1.__importDefault(require(\"./PDFAcroTerminal\"));\nvar PDFAcroNonTerminal_1 = tslib_1.__importDefault(require(\"./PDFAcroNonTerminal\"));\nvar PDFAcroSignature_1 = tslib_1.__importDefault(require(\"./PDFAcroSignature\"));\nvar PDFAcroText_1 = tslib_1.__importDefault(require(\"./PDFAcroText\"));\nvar PDFAcroPushButton_1 = tslib_1.__importDefault(require(\"./PDFAcroPushButton\"));\nvar PDFAcroRadioButton_1 = tslib_1.__importDefault(require(\"./PDFAcroRadioButton\"));\nvar PDFAcroCheckBox_1 = tslib_1.__importDefault(require(\"./PDFAcroCheckBox\"));\nvar PDFAcroComboBox_1 = tslib_1.__importDefault(require(\"./PDFAcroComboBox\"));\nvar PDFAcroListBox_1 = tslib_1.__importDefault(require(\"./PDFAcroListBox\"));\nvar flags_1 = require(\"./flags\");\nexports.createPDFAcroFields = function (kidDicts) {\n  if (!kidDicts) return [];\n  var kids = [];\n  for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {\n    var ref = kidDicts.get(idx);\n    var dict = kidDicts.lookup(idx);\n    // if (dict instanceof PDFDict) kids.push(PDFAcroField.fromDict(dict));\n    if (ref instanceof PDFRef_1.default && dict instanceof PDFDict_1.default) {\n      kids.push([exports.createPDFAcroField(dict, ref), ref]);\n    }\n  }\n  return kids;\n};\nexports.createPDFAcroField = function (dict, ref) {\n  var isNonTerminal = isNonTerminalAcroField(dict);\n  if (isNonTerminal) return PDFAcroNonTerminal_1.default.fromDict(dict, ref);\n  return createPDFAcroTerminal(dict, ref);\n};\n// TODO: Maybe just check if the dict is *not* a widget? That might be better.\n// According to the PDF spec:\n//\n//   > A field's children in the hierarchy may also include widget annotations\n//   > that define its appearance on the page. A field that has children that\n//   > are fields is called a non-terminal field. A field that does not have\n//   > children that are fields is called a terminal field.\n//\n// The spec is not entirely clear about how to determine whether a given\n// dictionary represents an acrofield or a widget annotation. So we will assume\n// that a dictionary is an acrofield if it is a member of the `/Kids` array\n// and it contains a `/T` entry (widgets do not have `/T` entries). This isn't\n// a bullet proof solution, because the `/T` entry is technically defined as\n// optional for acrofields by the PDF spec. But in practice all acrofields seem\n// to have a `/T` entry defined.\nvar isNonTerminalAcroField = function (dict) {\n  var kids = dict.lookup(PDFName_1.default.of('Kids'));\n  if (kids instanceof PDFArray_1.default) {\n    for (var idx = 0, len = kids.size(); idx < len; idx++) {\n      var kid = kids.lookup(idx);\n      var kidIsField = kid instanceof PDFDict_1.default && kid.has(PDFName_1.default.of('T'));\n      if (kidIsField) return true;\n    }\n  }\n  return false;\n};\nvar createPDFAcroTerminal = function (dict, ref) {\n  var ftNameOrRef = getInheritableAttribute(dict, PDFName_1.default.of('FT'));\n  var type = dict.context.lookup(ftNameOrRef, PDFName_1.default);\n  if (type === PDFName_1.default.of('Btn')) return createPDFAcroButton(dict, ref);\n  if (type === PDFName_1.default.of('Ch')) return createPDFAcroChoice(dict, ref);\n  if (type === PDFName_1.default.of('Tx')) return PDFAcroText_1.default.fromDict(dict, ref);\n  if (type === PDFName_1.default.of('Sig')) return PDFAcroSignature_1.default.fromDict(dict, ref);\n  // We should never reach this line. But there are a lot of weird PDFs out\n  // there. So, just to be safe, we'll try to handle things gracefully instead\n  // of throwing an error.\n  return PDFAcroTerminal_1.default.fromDict(dict, ref);\n};\nvar createPDFAcroButton = function (dict, ref) {\n  var _a;\n  var ffNumberOrRef = getInheritableAttribute(dict, PDFName_1.default.of('Ff'));\n  var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber_1.default);\n  var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;\n  if (flagIsSet(flags, flags_1.AcroButtonFlags.PushButton)) {\n    return PDFAcroPushButton_1.default.fromDict(dict, ref);\n  } else if (flagIsSet(flags, flags_1.AcroButtonFlags.Radio)) {\n    return PDFAcroRadioButton_1.default.fromDict(dict, ref);\n  } else {\n    return PDFAcroCheckBox_1.default.fromDict(dict, ref);\n  }\n};\nvar createPDFAcroChoice = function (dict, ref) {\n  var _a;\n  var ffNumberOrRef = getInheritableAttribute(dict, PDFName_1.default.of('Ff'));\n  var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber_1.default);\n  var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;\n  if (flagIsSet(flags, flags_1.AcroChoiceFlags.Combo)) {\n    return PDFAcroComboBox_1.default.fromDict(dict, ref);\n  } else {\n    return PDFAcroListBox_1.default.fromDict(dict, ref);\n  }\n};\nvar flagIsSet = function (flags, flag) {\n  return (flags & flag) !== 0;\n};\nvar getInheritableAttribute = function (startNode, name) {\n  var attribute;\n  ascend(startNode, function (node) {\n    if (!attribute) attribute = node.get(name);\n  });\n  return attribute;\n};\nvar ascend = function (startNode, visitor) {\n  visitor(startNode);\n  var Parent = startNode.lookupMaybe(PDFName_1.default.of('Parent'), PDFDict_1.default);\n  if (Parent) ascend(Parent, visitor);\n};","map":{"version":3,"names":["PDFNumber_1","tslib_1","__importDefault","require","PDFDict_1","PDFName_1","PDFArray_1","PDFRef_1","PDFAcroTerminal_1","PDFAcroNonTerminal_1","PDFAcroSignature_1","PDFAcroText_1","PDFAcroPushButton_1","PDFAcroRadioButton_1","PDFAcroCheckBox_1","PDFAcroComboBox_1","PDFAcroListBox_1","flags_1","exports","createPDFAcroFields","kidDicts","kids","idx","len","size","ref","get","dict","lookup","default","push","createPDFAcroField","isNonTerminal","isNonTerminalAcroField","fromDict","createPDFAcroTerminal","of","kid","kidIsField","has","ftNameOrRef","getInheritableAttribute","type","context","createPDFAcroButton","createPDFAcroChoice","ffNumberOrRef","ffNumber","lookupMaybe","flags","_a","asNumber","flagIsSet","AcroButtonFlags","PushButton","Radio","AcroChoiceFlags","Combo","flag","startNode","name","attribute","ascend","node","visitor","Parent"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/acroform/utils.ts"],"sourcesContent":["import PDFObject from 'src/core/objects/PDFObject';\nimport PDFNumber from 'src/core/objects/PDFNumber';\nimport PDFDict from 'src/core/objects/PDFDict';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFArray from 'src/core/objects/PDFArray';\nimport PDFRef from 'src/core/objects/PDFRef';\n\nimport PDFAcroField from 'src/core/acroform/PDFAcroField';\nimport PDFAcroTerminal from 'src/core/acroform/PDFAcroTerminal';\nimport PDFAcroNonTerminal from 'src/core/acroform/PDFAcroNonTerminal';\nimport PDFAcroButton from 'src/core/acroform/PDFAcroButton';\nimport PDFAcroSignature from 'src/core/acroform/PDFAcroSignature';\nimport PDFAcroChoice from 'src/core/acroform/PDFAcroChoice';\nimport PDFAcroText from 'src/core/acroform/PDFAcroText';\nimport PDFAcroPushButton from 'src/core/acroform/PDFAcroPushButton';\nimport PDFAcroRadioButton from 'src/core/acroform/PDFAcroRadioButton';\nimport PDFAcroCheckBox from 'src/core/acroform/PDFAcroCheckBox';\nimport PDFAcroComboBox from 'src/core/acroform/PDFAcroComboBox';\nimport PDFAcroListBox from 'src/core/acroform/PDFAcroListBox';\nimport { AcroButtonFlags, AcroChoiceFlags } from 'src/core/acroform/flags';\n\nexport const createPDFAcroFields = (\n  kidDicts?: PDFArray,\n): [PDFAcroField, PDFRef][] => {\n  if (!kidDicts) return [];\n\n  const kids: [PDFAcroField, PDFRef][] = [];\n  for (let idx = 0, len = kidDicts.size(); idx < len; idx++) {\n    const ref = kidDicts.get(idx);\n    const dict = kidDicts.lookup(idx);\n    // if (dict instanceof PDFDict) kids.push(PDFAcroField.fromDict(dict));\n    if (ref instanceof PDFRef && dict instanceof PDFDict) {\n      kids.push([createPDFAcroField(dict, ref), ref]);\n    }\n  }\n\n  return kids;\n};\n\nexport const createPDFAcroField = (\n  dict: PDFDict,\n  ref: PDFRef,\n): PDFAcroField => {\n  const isNonTerminal = isNonTerminalAcroField(dict);\n  if (isNonTerminal) return PDFAcroNonTerminal.fromDict(dict, ref);\n  return createPDFAcroTerminal(dict, ref);\n};\n\n// TODO: Maybe just check if the dict is *not* a widget? That might be better.\n\n// According to the PDF spec:\n//\n//   > A field's children in the hierarchy may also include widget annotations\n//   > that define its appearance on the page. A field that has children that\n//   > are fields is called a non-terminal field. A field that does not have\n//   > children that are fields is called a terminal field.\n//\n// The spec is not entirely clear about how to determine whether a given\n// dictionary represents an acrofield or a widget annotation. So we will assume\n// that a dictionary is an acrofield if it is a member of the `/Kids` array\n// and it contains a `/T` entry (widgets do not have `/T` entries). This isn't\n// a bullet proof solution, because the `/T` entry is technically defined as\n// optional for acrofields by the PDF spec. But in practice all acrofields seem\n// to have a `/T` entry defined.\nconst isNonTerminalAcroField = (dict: PDFDict): boolean => {\n  const kids = dict.lookup(PDFName.of('Kids'));\n\n  if (kids instanceof PDFArray) {\n    for (let idx = 0, len = kids.size(); idx < len; idx++) {\n      const kid = kids.lookup(idx);\n      const kidIsField = kid instanceof PDFDict && kid.has(PDFName.of('T'));\n      if (kidIsField) return true;\n    }\n  }\n\n  return false;\n};\n\nconst createPDFAcroTerminal = (dict: PDFDict, ref: PDFRef): PDFAcroTerminal => {\n  const ftNameOrRef = getInheritableAttribute(dict, PDFName.of('FT'));\n  const type = dict.context.lookup(ftNameOrRef, PDFName);\n\n  if (type === PDFName.of('Btn')) return createPDFAcroButton(dict, ref);\n  if (type === PDFName.of('Ch')) return createPDFAcroChoice(dict, ref);\n  if (type === PDFName.of('Tx')) return PDFAcroText.fromDict(dict, ref);\n  if (type === PDFName.of('Sig')) return PDFAcroSignature.fromDict(dict, ref);\n\n  // We should never reach this line. But there are a lot of weird PDFs out\n  // there. So, just to be safe, we'll try to handle things gracefully instead\n  // of throwing an error.\n  return PDFAcroTerminal.fromDict(dict, ref);\n};\n\nconst createPDFAcroButton = (dict: PDFDict, ref: PDFRef): PDFAcroButton => {\n  const ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n  const ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n  const flags = ffNumber?.asNumber() ?? 0;\n\n  if (flagIsSet(flags, AcroButtonFlags.PushButton)) {\n    return PDFAcroPushButton.fromDict(dict, ref);\n  } else if (flagIsSet(flags, AcroButtonFlags.Radio)) {\n    return PDFAcroRadioButton.fromDict(dict, ref);\n  } else {\n    return PDFAcroCheckBox.fromDict(dict, ref);\n  }\n};\n\nconst createPDFAcroChoice = (dict: PDFDict, ref: PDFRef): PDFAcroChoice => {\n  const ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n  const ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n  const flags = ffNumber?.asNumber() ?? 0;\n\n  if (flagIsSet(flags, AcroChoiceFlags.Combo)) {\n    return PDFAcroComboBox.fromDict(dict, ref);\n  } else {\n    return PDFAcroListBox.fromDict(dict, ref);\n  }\n};\n\nconst flagIsSet = (flags: number, flag: number): boolean =>\n  (flags & flag) !== 0;\n\nconst getInheritableAttribute = (startNode: PDFDict, name: PDFName) => {\n  let attribute: PDFObject | undefined;\n  ascend(startNode, (node) => {\n    if (!attribute) attribute = node.get(name);\n  });\n  return attribute;\n};\n\nconst ascend = (startNode: PDFDict, visitor: (node: PDFDict) => any) => {\n  visitor(startNode);\n  const Parent = startNode.lookupMaybe(PDFName.of('Parent'), PDFDict);\n  if (Parent) ascend(Parent, visitor);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}