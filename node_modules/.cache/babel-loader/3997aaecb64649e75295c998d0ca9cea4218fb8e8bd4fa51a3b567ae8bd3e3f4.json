{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar PDFName_1 = tslib_1.__importDefault(require(\"./PDFName\"));\nvar PDFNull_1 = tslib_1.__importDefault(require(\"./PDFNull\"));\nvar PDFObject_1 = tslib_1.__importDefault(require(\"./PDFObject\"));\nvar CharCodes_1 = tslib_1.__importDefault(require(\"../syntax/CharCodes\"));\nvar PDFDict = /** @class */function (_super) {\n  tslib_1.__extends(PDFDict, _super);\n  function PDFDict(map, context) {\n    var _this = _super.call(this) || this;\n    _this.dict = map;\n    _this.context = context;\n    return _this;\n  }\n  PDFDict.prototype.keys = function () {\n    return Array.from(this.dict.keys());\n  };\n  PDFDict.prototype.values = function () {\n    return Array.from(this.dict.values());\n  };\n  PDFDict.prototype.entries = function () {\n    return Array.from(this.dict.entries());\n  };\n  PDFDict.prototype.set = function (key, value) {\n    this.dict.set(key, value);\n  };\n  PDFDict.prototype.get = function (key,\n  // TODO: `preservePDFNull` is for backwards compatibility. Should be\n  // removed in next breaking API change.\n  preservePDFNull) {\n    if (preservePDFNull === void 0) {\n      preservePDFNull = false;\n    }\n    var value = this.dict.get(key);\n    if (value === PDFNull_1.default && !preservePDFNull) return undefined;\n    return value;\n  };\n  PDFDict.prototype.has = function (key) {\n    var value = this.dict.get(key);\n    return value !== undefined && value !== PDFNull_1.default;\n  };\n  PDFDict.prototype.lookupMaybe = function (key) {\n    var _a;\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      types[_i - 1] = arguments[_i];\n    }\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    var preservePDFNull = types.includes(PDFNull_1.default);\n    var value = (_a = this.context).lookupMaybe.apply(_a, tslib_1.__spreadArrays([this.get(key, preservePDFNull)], types));\n    if (value === PDFNull_1.default && !preservePDFNull) return undefined;\n    return value;\n  };\n  PDFDict.prototype.lookup = function (key) {\n    var _a;\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      types[_i - 1] = arguments[_i];\n    }\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    var preservePDFNull = types.includes(PDFNull_1.default);\n    var value = (_a = this.context).lookup.apply(_a, tslib_1.__spreadArrays([this.get(key, preservePDFNull)], types));\n    if (value === PDFNull_1.default && !preservePDFNull) return undefined;\n    return value;\n  };\n  PDFDict.prototype.delete = function (key) {\n    return this.dict.delete(key);\n  };\n  PDFDict.prototype.asMap = function () {\n    return new Map(this.dict);\n  };\n  /** Generate a random key that doesn't exist in current key set */\n  PDFDict.prototype.uniqueKey = function (tag) {\n    if (tag === void 0) {\n      tag = '';\n    }\n    var existingKeys = this.keys();\n    var key = PDFName_1.default.of(this.context.addRandomSuffix(tag, 10));\n    while (existingKeys.includes(key)) {\n      key = PDFName_1.default.of(this.context.addRandomSuffix(tag, 10));\n    }\n    return key;\n  };\n  PDFDict.prototype.clone = function (context) {\n    var clone = PDFDict.withContext(context || this.context);\n    var entries = this.entries();\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        key = _a[0],\n        value = _a[1];\n      clone.set(key, value);\n    }\n    return clone;\n  };\n  PDFDict.prototype.toString = function () {\n    var dictString = '<<\\n';\n    var entries = this.entries();\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        key = _a[0],\n        value = _a[1];\n      dictString += key.toString() + ' ' + value.toString() + '\\n';\n    }\n    dictString += '>>';\n    return dictString;\n  };\n  PDFDict.prototype.sizeInBytes = function () {\n    var size = 5;\n    var entries = this.entries();\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        key = _a[0],\n        value = _a[1];\n      size += key.sizeInBytes() + value.sizeInBytes() + 2;\n    }\n    return size;\n  };\n  PDFDict.prototype.copyBytesInto = function (buffer, offset) {\n    var initialOffset = offset;\n    buffer[offset++] = CharCodes_1.default.LessThan;\n    buffer[offset++] = CharCodes_1.default.LessThan;\n    buffer[offset++] = CharCodes_1.default.Newline;\n    var entries = this.entries();\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        key = _a[0],\n        value = _a[1];\n      offset += key.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes_1.default.Space;\n      offset += value.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes_1.default.Newline;\n    }\n    buffer[offset++] = CharCodes_1.default.GreaterThan;\n    buffer[offset++] = CharCodes_1.default.GreaterThan;\n    return offset - initialOffset;\n  };\n  PDFDict.withContext = function (context) {\n    return new PDFDict(new Map(), context);\n  };\n  PDFDict.fromMapWithContext = function (map, context) {\n    return new PDFDict(map, context);\n  };\n  return PDFDict;\n}(PDFObject_1.default);\nexports.default = PDFDict;","map":{"version":3,"names":["PDFName_1","tslib_1","__importDefault","require","PDFNull_1","PDFObject_1","CharCodes_1","PDFDict","_super","__extends","map","context","_this","call","dict","prototype","keys","Array","from","values","entries","set","key","value","get","preservePDFNull","default","undefined","has","lookupMaybe","types","_i","arguments","length","includes","_a","apply","__spreadArrays","lookup","delete","asMap","Map","uniqueKey","tag","existingKeys","of","addRandomSuffix","clone","withContext","idx","len","toString","dictString","sizeInBytes","size","copyBytesInto","buffer","offset","initialOffset","LessThan","Newline","Space","GreaterThan","fromMapWithContext","exports"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/objects/PDFDict.ts"],"sourcesContent":["import PDFArray from 'src/core/objects/PDFArray';\nimport PDFBool from 'src/core/objects/PDFBool';\nimport PDFHexString from 'src/core/objects/PDFHexString';\nimport PDFName from 'src/core/objects/PDFName';\nimport PDFNull from 'src/core/objects/PDFNull';\nimport PDFNumber from 'src/core/objects/PDFNumber';\nimport PDFObject from 'src/core/objects/PDFObject';\nimport PDFRef from 'src/core/objects/PDFRef';\nimport PDFStream from 'src/core/objects/PDFStream';\nimport PDFString from 'src/core/objects/PDFString';\nimport PDFContext from 'src/core/PDFContext';\nimport CharCodes from 'src/core/syntax/CharCodes';\n\nexport type DictMap = Map<PDFName, PDFObject>;\n\nclass PDFDict extends PDFObject {\n  static withContext = (context: PDFContext) => new PDFDict(new Map(), context);\n\n  static fromMapWithContext = (map: DictMap, context: PDFContext) =>\n    new PDFDict(map, context);\n\n  readonly context: PDFContext;\n\n  private readonly dict: DictMap;\n\n  protected constructor(map: DictMap, context: PDFContext) {\n    super();\n    this.dict = map;\n    this.context = context;\n  }\n\n  keys(): PDFName[] {\n    return Array.from(this.dict.keys());\n  }\n\n  values(): PDFObject[] {\n    return Array.from(this.dict.values());\n  }\n\n  entries(): [PDFName, PDFObject][] {\n    return Array.from(this.dict.entries());\n  }\n\n  set(key: PDFName, value: PDFObject): void {\n    this.dict.set(key, value);\n  }\n\n  get(\n    key: PDFName,\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    preservePDFNull = false,\n  ): PDFObject | undefined {\n    const value = this.dict.get(key);\n    if (value === PDFNull && !preservePDFNull) return undefined;\n    return value;\n  }\n\n  has(key: PDFName): boolean {\n    const value = this.dict.get(key);\n    return value !== undefined && value !== PDFNull;\n  }\n\n  lookupMaybe(key: PDFName, type: typeof PDFArray): PDFArray | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFBool): PDFBool | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFDict): PDFDict | undefined;\n  lookupMaybe(\n    key: PDFName,\n    type: typeof PDFHexString,\n  ): PDFHexString | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFName): PDFName | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFNull): typeof PDFNull | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFNumber): PDFNumber | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFStream): PDFStream | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFRef): PDFRef | undefined;\n  lookupMaybe(key: PDFName, type: typeof PDFString): PDFString | undefined;\n  lookupMaybe(\n    ref: PDFName,\n    type1: typeof PDFString,\n    type2: typeof PDFHexString,\n  ): PDFString | PDFHexString | undefined;\n  lookupMaybe(\n    ref: PDFName,\n    type1: typeof PDFDict,\n    type2: typeof PDFStream,\n  ): PDFDict | PDFStream | undefined;\n  lookupMaybe(\n    ref: PDFName,\n    type1: typeof PDFString,\n    type2: typeof PDFHexString,\n    type3: typeof PDFArray,\n  ): PDFString | PDFHexString | PDFArray | undefined;\n\n  lookupMaybe(key: PDFName, ...types: any[]) {\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    const preservePDFNull = types.includes(PDFNull);\n\n    const value = this.context.lookupMaybe(\n      this.get(key, preservePDFNull),\n      // @ts-ignore\n      ...types,\n    ) as any;\n\n    if (value === PDFNull && !preservePDFNull) return undefined;\n\n    return value;\n  }\n\n  lookup(key: PDFName): PDFObject | undefined;\n  lookup(key: PDFName, type: typeof PDFArray): PDFArray;\n  lookup(key: PDFName, type: typeof PDFBool): PDFBool;\n  lookup(key: PDFName, type: typeof PDFDict): PDFDict;\n  lookup(key: PDFName, type: typeof PDFHexString): PDFHexString;\n  lookup(key: PDFName, type: typeof PDFName): PDFName;\n  lookup(key: PDFName, type: typeof PDFNull): typeof PDFNull;\n  lookup(key: PDFName, type: typeof PDFNumber): PDFNumber;\n  lookup(key: PDFName, type: typeof PDFStream): PDFStream;\n  lookup(key: PDFName, type: typeof PDFRef): PDFRef;\n  lookup(key: PDFName, type: typeof PDFString): PDFString;\n  lookup(\n    ref: PDFName,\n    type1: typeof PDFString,\n    type2: typeof PDFHexString,\n  ): PDFString | PDFHexString;\n  lookup(\n    ref: PDFName,\n    type1: typeof PDFDict,\n    type2: typeof PDFStream,\n  ): PDFDict | PDFStream;\n  lookup(\n    ref: PDFName,\n    type1: typeof PDFString,\n    type2: typeof PDFHexString,\n    type3: typeof PDFArray,\n  ): PDFString | PDFHexString | PDFArray;\n\n  lookup(key: PDFName, ...types: any[]) {\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    const preservePDFNull = types.includes(PDFNull);\n\n    const value = this.context.lookup(\n      this.get(key, preservePDFNull),\n      // @ts-ignore\n      ...types,\n    ) as any;\n\n    if (value === PDFNull && !preservePDFNull) return undefined;\n\n    return value;\n  }\n\n  delete(key: PDFName): boolean {\n    return this.dict.delete(key);\n  }\n\n  asMap(): Map<PDFName, PDFObject> {\n    return new Map(this.dict);\n  }\n\n  /** Generate a random key that doesn't exist in current key set */\n  uniqueKey(tag = ''): PDFName {\n    const existingKeys = this.keys();\n    let key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n    while (existingKeys.includes(key)) {\n      key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n    }\n    return key;\n  }\n\n  clone(context?: PDFContext): PDFDict {\n    const clone = PDFDict.withContext(context || this.context);\n    const entries = this.entries();\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\n      const [key, value] = entries[idx];\n      clone.set(key, value);\n    }\n    return clone;\n  }\n\n  toString(): string {\n    let dictString = '<<\\n';\n    const entries = this.entries();\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\n      const [key, value] = entries[idx];\n      dictString += key.toString() + ' ' + value.toString() + '\\n';\n    }\n    dictString += '>>';\n    return dictString;\n  }\n\n  sizeInBytes(): number {\n    let size = 5;\n    const entries = this.entries();\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\n      const [key, value] = entries[idx];\n      size += key.sizeInBytes() + value.sizeInBytes() + 2;\n    }\n    return size;\n  }\n\n  copyBytesInto(buffer: Uint8Array, offset: number): number {\n    const initialOffset = offset;\n\n    buffer[offset++] = CharCodes.LessThan;\n    buffer[offset++] = CharCodes.LessThan;\n    buffer[offset++] = CharCodes.Newline;\n\n    const entries = this.entries();\n    for (let idx = 0, len = entries.length; idx < len; idx++) {\n      const [key, value] = entries[idx];\n      offset += key.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes.Space;\n      offset += value.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes.Newline;\n    }\n\n    buffer[offset++] = CharCodes.GreaterThan;\n    buffer[offset++] = CharCodes.GreaterThan;\n\n    return offset - initialOffset;\n  }\n}\n\nexport default PDFDict;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}