{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2012 Mozilla Foundation\n *\n * The RunLengthStream class contained in this file is a TypeScript port of the\n * JavaScript RunLengthStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar DecodeStream_1 = tslib_1.__importDefault(require(\"./DecodeStream\"));\nvar RunLengthStream = /** @class */function (_super) {\n  tslib_1.__extends(RunLengthStream, _super);\n  function RunLengthStream(stream, maybeLength) {\n    var _this = _super.call(this, maybeLength) || this;\n    _this.stream = stream;\n    return _this;\n  }\n  RunLengthStream.prototype.readBlock = function () {\n    // The repeatHeader has following format. The first byte defines type of run\n    // and amount of bytes to repeat/copy: n = 0 through 127 - copy next n bytes\n    // (in addition to the second byte from the header), n = 129 through 255 -\n    // duplicate the second byte from the header (257 - n) times, n = 128 - end.\n    var repeatHeader = this.stream.getBytes(2);\n    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {\n      this.eof = true;\n      return;\n    }\n    var buffer;\n    var bufferLength = this.bufferLength;\n    var n = repeatHeader[0];\n    if (n < 128) {\n      // copy n bytes\n      buffer = this.ensureBuffer(bufferLength + n + 1);\n      buffer[bufferLength++] = repeatHeader[1];\n      if (n > 0) {\n        var source = this.stream.getBytes(n);\n        buffer.set(source, bufferLength);\n        bufferLength += n;\n      }\n    } else {\n      n = 257 - n;\n      var b = repeatHeader[1];\n      buffer = this.ensureBuffer(bufferLength + n + 1);\n      for (var i = 0; i < n; i++) {\n        buffer[bufferLength++] = b;\n      }\n    }\n    this.bufferLength = bufferLength;\n  };\n  return RunLengthStream;\n}(DecodeStream_1.default);\nexports.default = RunLengthStream;","map":{"version":3,"names":["DecodeStream_1","tslib_1","__importDefault","require","RunLengthStream","_super","__extends","stream","maybeLength","_this","call","prototype","readBlock","repeatHeader","getBytes","length","eof","buffer","bufferLength","n","ensureBuffer","source","set","b","i","default","exports"],"sources":["/Users/casarulez/Projects/Liquid-neurons/database_forms/data_entry_forms/node_modules/pdf-lib/src/core/streams/RunLengthStream.ts"],"sourcesContent":["/*\n * Copyright 2012 Mozilla Foundation\n *\n * The RunLengthStream class contained in this file is a TypeScript port of the\n * JavaScript RunLengthStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\n\nimport DecodeStream from 'src/core/streams/DecodeStream';\nimport { StreamType } from 'src/core/streams/Stream';\n\nclass RunLengthStream extends DecodeStream {\n  private stream: StreamType;\n\n  constructor(stream: StreamType, maybeLength?: number) {\n    super(maybeLength);\n    this.stream = stream;\n  }\n\n  protected readBlock() {\n    // The repeatHeader has following format. The first byte defines type of run\n    // and amount of bytes to repeat/copy: n = 0 through 127 - copy next n bytes\n    // (in addition to the second byte from the header), n = 129 through 255 -\n    // duplicate the second byte from the header (257 - n) times, n = 128 - end.\n    const repeatHeader = this.stream.getBytes(2);\n    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {\n      this.eof = true;\n      return;\n    }\n\n    let buffer;\n    let bufferLength = this.bufferLength;\n    let n = repeatHeader[0];\n    if (n < 128) {\n      // copy n bytes\n      buffer = this.ensureBuffer(bufferLength + n + 1);\n      buffer[bufferLength++] = repeatHeader[1];\n      if (n > 0) {\n        const source = this.stream.getBytes(n);\n        buffer.set(source, bufferLength);\n        bufferLength += n;\n      }\n    } else {\n      n = 257 - n;\n      const b = repeatHeader[1];\n      buffer = this.ensureBuffer(bufferLength + n + 1);\n      for (let i = 0; i < n; i++) {\n        buffer[bufferLength++] = b;\n      }\n    }\n    this.bufferLength = bufferLength;\n  }\n}\n\nexport default RunLengthStream;\n"],"mappings":";;AAAA;;;;;;;;;;;AAQA,IAAAA,cAAA,GAAAC,OAAA,CAAAC,eAAA,CAAAC,OAAA;AAGA,IAAAC,eAAA,0BAAAC,MAAA;EAA8BJ,OAAA,CAAAK,SAAA,CAAAF,eAAA,EAAAC,MAAA;EAG5B,SAAAD,gBAAYG,MAAkB,EAAEC,WAAoB;IAApD,IAAAC,KAAA,GACEJ,MAAA,CAAAK,IAAA,OAAMF,WAAW,CAAC;IAClBC,KAAI,CAACF,MAAM,GAAGA,MAAM;;EACtB;EAEUH,eAAA,CAAAO,SAAA,CAAAC,SAAS,GAAnB;IACE;IACA;IACA;IACA;IACA,IAAMC,YAAY,GAAG,IAAI,CAACN,MAAM,CAACO,QAAQ,CAAC,CAAC,CAAC;IAC5C,IAAI,CAACD,YAAY,IAAIA,YAAY,CAACE,MAAM,GAAG,CAAC,IAAIF,YAAY,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MACvE,IAAI,CAACG,GAAG,GAAG,IAAI;MACf;;IAGF,IAAIC,MAAM;IACV,IAAIC,YAAY,GAAG,IAAI,CAACA,YAAY;IACpC,IAAIC,CAAC,GAAGN,YAAY,CAAC,CAAC,CAAC;IACvB,IAAIM,CAAC,GAAG,GAAG,EAAE;MACX;MACAF,MAAM,GAAG,IAAI,CAACG,YAAY,CAACF,YAAY,GAAGC,CAAC,GAAG,CAAC,CAAC;MAChDF,MAAM,CAACC,YAAY,EAAE,CAAC,GAAGL,YAAY,CAAC,CAAC,CAAC;MACxC,IAAIM,CAAC,GAAG,CAAC,EAAE;QACT,IAAME,MAAM,GAAG,IAAI,CAACd,MAAM,CAACO,QAAQ,CAACK,CAAC,CAAC;QACtCF,MAAM,CAACK,GAAG,CAACD,MAAM,EAAEH,YAAY,CAAC;QAChCA,YAAY,IAAIC,CAAC;;KAEpB,MAAM;MACLA,CAAC,GAAG,GAAG,GAAGA,CAAC;MACX,IAAMI,CAAC,GAAGV,YAAY,CAAC,CAAC,CAAC;MACzBI,MAAM,GAAG,IAAI,CAACG,YAAY,CAACF,YAAY,GAAGC,CAAC,GAAG,CAAC,CAAC;MAChD,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,CAAC,EAAEK,CAAC,EAAE,EAAE;QAC1BP,MAAM,CAACC,YAAY,EAAE,CAAC,GAAGK,CAAC;;;IAG9B,IAAI,CAACL,YAAY,GAAGA,YAAY;EAClC,CAAC;EACH,OAAAd,eAAC;AAAD,CAAC,CAzC6BJ,cAAA,CAAAyB,OAAY;AA2C1CC,OAAA,CAAAD,OAAA,GAAerB,eAAe","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}